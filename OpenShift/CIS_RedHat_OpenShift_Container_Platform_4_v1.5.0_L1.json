{
    "custom_item_1": {
        "description": "1.2.2 Ensure that the --basic-auth-file argument is not set - openshift-kube-apiserver",
        "info": "Do not use basic authentication.\n\nRationale:\n\nBasic authentication uses plaintext credentials for authentication. Currently, the basic authentication credentials last indefinitely, and the password cannot be changed without restarting the API server. The basic authentication is currently supported for convenience. Hence, basic authentication should not be used.\n\nImpact:\n\nOpenShift uses tokens and certificates for authentication.",
        "solution": "None required. --basic-auth-file cannot be configured on OpenShift.\n\nDefault Value:\n\nBy default, --basic-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Basic Auth: \\(.apiServerArguments.\"basic-auth-file\")\"",
        "expect": "Basic Auth: null"
    },
    "custom_item_2": {
        "description": "1.2.2 Ensure that the --basic-auth-file argument is not set - openshift-apiserver",
        "info": "Do not use basic authentication.\n\nRationale:\n\nBasic authentication uses plaintext credentials for authentication. Currently, the basic authentication credentials last indefinitely, and the password cannot be changed without restarting the API server. The basic authentication is currently supported for convenience. Hence, basic authentication should not be used.\n\nImpact:\n\nOpenShift uses tokens and certificates for authentication.",
        "solution": "None required. --basic-auth-file cannot be configured on OpenShift.\n\nDefault Value:\n\nBy default, --basic-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Basic Auth: \\(.apiServerArguments.\"basic-auth-file\")\"",
        "expect": "Basic Auth: null"
    },
    "custom_item_3": {
        "description": "1.2.2 Ensure that the --basic-auth-file argument is not set - ClusterOperators",
        "info": "Do not use basic authentication.\n\nRationale:\n\nBasic authentication uses plaintext credentials for authentication. Currently, the basic authentication credentials last indefinitely, and the password cannot be changed without restarting the API server. The basic authentication is currently supported for convenience. Hence, basic authentication should not be used.\n\nImpact:\n\nOpenShift uses tokens and certificates for authentication.",
        "solution": "None required. --basic-auth-file cannot be configured on OpenShift.\n\nDefault Value:\n\nBy default, --basic-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getClusterOperators",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.name == \"authentication\") | .kind as $kind | .metadata.name as $name | .status.conditions[] | select(.type == \"Available\") | \"Cluster ID: \\($clusterID), Kind: \\($kind), Name: \\($name), Available: \\(.status)\"",
        "expect": "Available: True"
    },
    "custom_item_4": {
        "description": "1.2.3 Ensure that the --token-auth-file parameter is not set - openshift-kube-apiserver",
        "info": "Do not use token based authentication.\n\nRationale:\n\nThe token-based authentication utilizes static tokens to authenticate requests to the apiserver. The tokens are stored in clear-text in a file on the apiserver, and cannot be revoked or rotated without restarting the apiserver. Hence, do not use static token-based authentication.\n\nImpact:\n\nOpenShift does not use the token-auth-file flag. OpenShift includes a built-in OAuth server rather than relying on a static token file. The OAuth server is integrated with the API server.",
        "solution": "None is required.\n\nDefault Value:\n\nBy default, --token-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Token Auth: \\(.apiServerArguments.\"token-auth-file\")\"",
        "expect": "Token Auth: null"
    },
    "custom_item_5": {
        "description": "1.2.3 Ensure that the --token-auth-file parameter is not set - openshift-apiserver",
        "info": "Do not use token based authentication.\n\nRationale:\n\nThe token-based authentication utilizes static tokens to authenticate requests to the apiserver. The tokens are stored in clear-text in a file on the apiserver, and cannot be revoked or rotated without restarting the apiserver. Hence, do not use static token-based authentication.\n\nImpact:\n\nOpenShift does not use the token-auth-file flag. OpenShift includes a built-in OAuth server rather than relying on a static token file. The OAuth server is integrated with the API server.",
        "solution": "None is required.\n\nDefault Value:\n\nBy default, --token-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Token Auth: \\(.apiServerArguments.\"token-auth-file\")\"",
        "expect": "Token Auth: null"
    },
    "custom_item_6": {
        "description": "1.2.3 Ensure that the --token-auth-file parameter is not set - KubeApiServers",
        "info": "Do not use token based authentication.\n\nRationale:\n\nThe token-based authentication utilizes static tokens to authenticate requests to the apiserver. The tokens are stored in clear-text in a file on the apiserver, and cannot be revoked or rotated without restarting the apiserver. Hence, do not use static token-based authentication.\n\nImpact:\n\nOpenShift does not use the token-auth-file flag. OpenShift includes a built-in OAuth server rather than relying on a static token file. The OAuth server is integrated with the API server.",
        "solution": "None is required.\n\nDefault Value:\n\nBy default, --token-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getKubeApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Token Auth: \\(.spec.observedConfig.apiServerArguments.\"token-auth-file\")\"",
        "expect": "Token Auth: null"
    },
    "custom_item_7": {
        "description": "1.2.3 Ensure that the --token-auth-file parameter is not set - ClusterOperators",
        "info": "Do not use token based authentication.\n\nRationale:\n\nThe token-based authentication utilizes static tokens to authenticate requests to the apiserver. The tokens are stored in clear-text in a file on the apiserver, and cannot be revoked or rotated without restarting the apiserver. Hence, do not use static token-based authentication.\n\nImpact:\n\nOpenShift does not use the token-auth-file flag. OpenShift includes a built-in OAuth server rather than relying on a static token file. The OAuth server is integrated with the API server.",
        "solution": "None is required.\n\nDefault Value:\n\nBy default, --token-auth-file argument is not set and OAuth authentication is configured.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.7.5,800-53|CM-7,800-53|MA-4,800-53r5|CM-7,800-53r5|MA-4,CSCv7|16.4,CSCv8|4.6,CSF|PR.IP-1,CSF|PR.MA-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-7,ITSG-33|MA-4,LEVEL|1M,NESA|T2.3.4,NESA|T5.4.4,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3,TBA-FIISB|45.2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getClusterOperators",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.name == \"authentication\") | .kind as $kind | .metadata.name as $name | .status.conditions[] | select(.type == \"Available\") | \"Cluster ID: \\($clusterID), Kind: \\($kind), Name: \\($name), Available: \\(.status)\"",
        "expect": "Available: True"
    },
    "custom_item_8": {
        "description": "1.2.4 Use https for kubelet connections - ConfigMaps",
        "info": "Use https for kubelet connections.\n\nRationale:\n\nConnections from apiserver to kubelets could potentially carry sensitive data such as secrets and keys. It is thus important to use in-transit encryption for any communication between the apiserver and kubelets.\n\nImpact:\n\nYou require TLS to be configured on apiserver as well as kubelets.",
        "solution": "No remediation is required. OpenShift platform components use X.509 certificates for authentication. OpenShift manages the CAs and certificates for platform components. This is not configurable.\n\nDefault Value:\n\nBy default, kubelet connections are encrypted.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Certificate: \\(.apiServerArguments.\"kubelet-client-certificate\"), Key: \\(.apiServerArguments.\"kubelet-client-key\")\"",
        "expect": "Certificate: \\[\"/etc/kubernetes/static-pod-certs/secrets/kubelet-client/tls.crt\"\\], Key: \\[\"/etc/kubernetes/static-pod-certs/secrets/kubelet-client/tls.key\"\\]"
    },
    "custom_item_9": {
        "description": "1.2.4 Use https for kubelet connections - Secrets",
        "info": "Use https for kubelet connections.\n\nRationale:\n\nConnections from apiserver to kubelets could potentially carry sensitive data such as secrets and keys. It is thus important to use in-transit encryption for any communication between the apiserver and kubelets.\n\nImpact:\n\nYou require TLS to be configured on apiserver as well as kubelets.",
        "solution": "No remediation is required. OpenShift platform components use X.509 certificates for authentication. OpenShift manages the CAs and certificates for platform components. This is not configurable.\n\nDefault Value:\n\nBy default, kubelet connections are encrypted.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecrets_openshift-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.name==\"serving-cert\") | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Type: \\(.type)\"",
        "expect": "Type: kubernetes.io/tls"
    },
    "custom_item_10": {
        "description": "1.2.5 Ensure that the kubelet uses certificates to authenticate - ConfigMaps",
        "info": "Enable certificate based kubelet authentication.\n\nRationale:\n\nThe apiserver, by default, does not authenticate itself to the kubelet's HTTPS endpoints. The requests from the apiserver are treated anonymously. You should set up certificate-based kubelet authentication to ensure that the apiserver authenticates itself to kubelets when submitting requests.\n\nImpact:\n\nRequire TLS to be configured on the apiserver as well as kubelets.",
        "solution": "No remediation is required. OpenShift platform components use X.509 certificates for authentication. OpenShift manages the CAs and certificates for platform components. This is not configurable.\n\nDefault Value:\n\nBy default, kubelet authentication is managed with X.509 certificates.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|1.8,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Certificate: \\(.apiServerArguments.\"kubelet-client-certificate\"), Key: \\(.apiServerArguments.\"kubelet-client-key\")\"",
        "expect": "Certificate: \\[\"/etc/kubernetes/static-pod-certs/secrets/kubelet-client/tls.crt\"\\], Key: \\[\"/etc/kubernetes/static-pod-certs/secrets/kubelet-client/tls.key\"\\]"
    },
    "custom_item_11": {
        "description": "1.2.5 Ensure that the kubelet uses certificates to authenticate - Secrets",
        "info": "Enable certificate based kubelet authentication.\n\nRationale:\n\nThe apiserver, by default, does not authenticate itself to the kubelet's HTTPS endpoints. The requests from the apiserver are treated anonymously. You should set up certificate-based kubelet authentication to ensure that the apiserver authenticates itself to kubelets when submitting requests.\n\nImpact:\n\nRequire TLS to be configured on the apiserver as well as kubelets.",
        "solution": "No remediation is required. OpenShift platform components use X.509 certificates for authentication. OpenShift manages the CAs and certificates for platform components. This is not configurable.\n\nDefault Value:\n\nBy default, kubelet authentication is managed with X.509 certificates.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|1.8,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecrets_openshift-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.name==\"serving-cert\") | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Type: \\(.type)\"",
        "expect": "Type: kubernetes.io/tls"
    },
    "custom_item_12": {
        "description": "1.2.6 Verify that the kubelet certificate authority is set as appropriate",
        "info": "Verify kubelet's certificate before establishing connection.\n\nRationale:\n\nThe connections from the apiserver to the kubelet are used for fetching logs for pods, attaching (through kubectl) to running pods, and using the kubelet's port-forwarding functionality. These connections terminate at the kubelet's HTTPS endpoint. By default, the apiserver does not verify the kubelet's serving certificate, which makes the connection subject to man-in-the-middle attacks, and unsafe to run over untrusted and/or public networks.\n\nImpact:\n\nYou require TLS to be configured on apiserver as well as kubelets.",
        "solution": "No remediation is required. OpenShift platform components use X.509 certificates for authentication. OpenShift manages the CAs and certificates for platform components. This is not configurable.\n\nDefault Value:\n\nBy default, kubelet authentication is managed with X.509 certificates.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|1.8,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), CA: \\(.apiServerArguments.\"kubelet-certificate-authority\")\"",
        "expect": "CA: \\[\"/etc/kubernetes/static-pod-resources/configmaps/kubelet-serving-ca/ca-bundle.crt\"\\]"
    },
    "custom_item_13": {
        "description": "1.2.7 Ensure that the --authorization-mode argument is not set to AlwaysAllow",
        "info": "Do not always authorize all requests.\n\nRationale:\n\nThe API Server, can be configured to allow all requests. This mode should not be used on any production cluster.\n\nImpact:\n\nOnly authorized requests will be served.",
        "solution": "None. RBAC is always on and the OpenShift API server does not use the values assigned to the flag authorization-mode.\n\nDefault Value:\n\nOpenShift uses RBAC by default.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|9.2,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Authorization Mode: \\(.apiServerArguments.\"authorization-mode\")\"",
        "expect": "Authorization Mode: .*\"RBAC\".*"
    },
    "custom_item_14": {
        "description": "1.2.8 Verify that RBAC is enabled",
        "info": "Turn on Role Based Access Control.\n\nRationale:\n\nRole Based Access Control (RBAC) allows fine-grained control over the operations that different entities can perform on different objects in the cluster. It is recommended to use the RBAC authorization mode.\n\nImpact:\n\nWhen RBAC is enabled you will need to ensure that appropriate RBAC settings (including Roles, RoleBindings, ClusterRoles, and ClusterRoleBindings) are configured to allow appropriate access.",
        "solution": "None.\n\nDefault Value:\n\nOpenShift uses RBAC by default. OpenShift includes default roles and role bindings. Custom roles and role bindings can be added for additional granularity.\n\nPlease refer to the OpenShift documentation for more information on RBAC.",
        "reference": "800-171|3.1.1,800-171|3.1.5,800-171|3.3.8,800-171|3.3.9,800-53|AC-2,800-53|AC-3,800-53|AC-6,800-53|AC-6(1),800-53|AC-6(7),800-53|AU-9(4),800-53r5|AC-2,800-53r5|AC-3,800-53r5|AC-6,800-53r5|AC-6(1),800-53r5|AC-6(7),800-53r5|AU-9(4),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(d),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(d),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|6.8,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.9.2.1,ISO/IEC-27001|A.9.2.5,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.4,ISO/IEC-27001|A.9.4.5,ISO/IEC-27001|A.12.4.2,ITSG-33|AC-2,ITSG-33|AC-3,ITSG-33|AC-6,ITSG-33|AC-6(1),ITSG-33|AU-9(4),ITSG-33|AU-9(4)(a),ITSG-33|AU-9(4)(b),LEVEL|1M,NESA|M1.1.3,NESA|M1.2.2,NESA|M5.2.3,NESA|M5.5.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM28,NIAv2|AM31,NIAv2|GS3,NIAv2|GS4,NIAv2|GS8c,NIAv2|NS5j,NIAv2|SM5,NIAv2|SM6,NIAv2|SS13c,NIAv2|SS14e,NIAv2|SS15c,NIAv2|SS29,NIAv2|VL3b,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.5,PCI-DSSv3.2.1|10.5.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.3.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Authorization Mode: \\(.apiServerArguments.\"authorization-mode\")\"",
        "expect": "Authorization Mode: .*\"RBAC\".*"
    },
    "custom_item_15": {
        "description": "1.2.9 Ensure that the APIPriorityAndFairness feature gate is enabled - FeatureGates",
        "info": "Limit the rate at which the API server accepts requests.\n\nRationale:\n\nUsing EventRateLimit admission control enforces a limit on the number of events that the API Server will accept in a given time slice. A misbehaving workload could overwhelm and DoS the API Server, making it unavailable. This particularly applies to a multi-tenant cluster, where there might be a small percentage of misbehaving tenants which could have a significant impact on the performance of the cluster overall. Hence, it is recommended to limit the rate of events that the API server will accept.\n\nNote: This is an Alpha feature in the Kubernetes 1.15 release.\n\nImpact:\n\nNone, as the OpenShift kubelet has been fixed to send fewer requests.",
        "solution": "No remediation is required.\n\nDefault Value:\n\nBy default, the OpenShift kubelet has been fixed to send fewer requests. Version 4.6+ it is enabled by default.",
        "reference": "800-171|3.1.16,800-171|3.13.15,800-53|AC-18,800-53|SC-23,800-53r5|AC-18,800-53r5|SC-23,CSCv7|8.3,CSCv8|12.6,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ITSG-33|AC-18,ITSG-33|SC-23,ITSG-33|SC-23a.,LEVEL|1M,NESA|T4.5.1,QCSC-v1|5.2.1,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getKubeApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Feature Gates: \\(.spec.observedConfig.apiServerArguments.\"feature-gates\")\"",
        "expect": "Feature Gates: .*\"APIPriorityAndFairness=true\".*"
    },
    "custom_item_16": {
        "description": "1.2.9 Ensure that the APIPriorityAndFairness feature gate is enabled - ConfigMaps",
        "info": "Limit the rate at which the API server accepts requests.\n\nRationale:\n\nUsing EventRateLimit admission control enforces a limit on the number of events that the API Server will accept in a given time slice. A misbehaving workload could overwhelm and DoS the API Server, making it unavailable. This particularly applies to a multi-tenant cluster, where there might be a small percentage of misbehaving tenants which could have a significant impact on the performance of the cluster overall. Hence, it is recommended to limit the rate of events that the API server will accept.\n\nNote: This is an Alpha feature in the Kubernetes 1.15 release.\n\nImpact:\n\nNone, as the OpenShift kubelet has been fixed to send fewer requests.",
        "solution": "No remediation is required.\n\nDefault Value:\n\nBy default, the OpenShift kubelet has been fixed to send fewer requests. Version 4.6+ it is enabled by default.",
        "reference": "800-171|3.1.16,800-171|3.13.15,800-53|AC-18,800-53|SC-23,800-53r5|AC-18,800-53r5|SC-23,CSCv7|8.3,CSCv8|12.6,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ITSG-33|AC-18,ITSG-33|SC-23,ITSG-33|SC-23a.,LEVEL|1M,NESA|T4.5.1,QCSC-v1|5.2.1,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "not_expect": "Admission Plugins: .*\"EventRateLimit\".*"
    },
    "custom_item_17": {
        "description": "1.2.9 Ensure that the APIPriorityAndFairness feature gate is enabled - Overrides",
        "info": "Limit the rate at which the API server accepts requests.\n\nRationale:\n\nUsing EventRateLimit admission control enforces a limit on the number of events that the API Server will accept in a given time slice. A misbehaving workload could overwhelm and DoS the API Server, making it unavailable. This particularly applies to a multi-tenant cluster, where there might be a small percentage of misbehaving tenants which could have a significant impact on the performance of the cluster overall. Hence, it is recommended to limit the rate of events that the API server will accept.\n\nNote: This is an Alpha feature in the Kubernetes 1.15 release.\n\nImpact:\n\nNone, as the OpenShift kubelet has been fixed to send fewer requests.",
        "solution": "No remediation is required.\n\nDefault Value:\n\nBy default, the OpenShift kubelet has been fixed to send fewer requests. Version 4.6+ it is enabled by default.",
        "reference": "800-171|3.1.16,800-171|3.13.15,800-53|AC-18,800-53|SC-23,800-53r5|AC-18,800-53r5|SC-23,CSCv7|8.3,CSCv8|12.6,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ITSG-33|AC-18,ITSG-33|SC-23,ITSG-33|SC-23a.,LEVEL|1M,NESA|T4.5.1,QCSC-v1|5.2.1,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getKubeApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Unsupported Config Overrides: \\(.spec.unsupportedConfigOverrides)\"",
        "expect": "Unsupported Config Overrides: null"
    },
    "custom_item_18": {
        "description": "1.2.10 Ensure that the admission control plugin AlwaysAdmit is not set",
        "info": "Do not allow all requests.\n\nRationale:\n\nSetting admission control plugin AlwaysAdmit allows all requests and does not filter any requests.\n\nThe AlwaysAdmit admission controller was deprecated in Kubernetes v1.13. Its behavior was equivalent to turning off all admission controllers.\n\nImpact:\n\nOnly requests explicitly allowed by the admissions control plugins would be served.",
        "solution": "None.\n\nDefault Value:\n\nThis AlwaysAdmit controller is disabled by default in OpenShift and cannot be enabled.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "not_expect": "Admission Plugins: .*\"AlwaysAdmit\".*"
    },
    "custom_item_19": {
        "description": "1.2.11 Ensure that the admission control plugin AlwaysPullImages is not set",
        "info": "Always pull images.\n\nRationale:\n\nSetting admission control policy to AlwaysPullImages forces every new pod to pull the required images every time. In a multi-tenant cluster users can be assured that their private images can only be used by those who have the credentials to pull them. Without this admission control policy, once an image has been pulled to a node, any pod from any user can use it simply by knowing the image's name, without any authorization check against the image ownership. When this plug-in is enabled, images are always pulled prior to starting containers, which means valid credentials are required.\n\nHowever, turning on this admission plugin can introduce new kinds of cluster failure modes. OpenShift 4 master and infrastructure components are deployed as pods. Enabling this feature can result in cases where loss of contact to an image registry can cause a redeployed infrastructure pod (oauth-server for example) to fail on an image pull for an image that is currently present on the node. We use PullIfNotPresent so that a loss of image registry access does not prevent the pod from starting. If it becomes PullAlways, then an image registry access outage can cause key infrastructure components to fail.\n\nThis can be managed per container. When OpenShift Container Platform creates containers, it uses the container's imagePullPolicy to determine if the image should be pulled prior to starting the container. There are three possible values for imagePullPolicy: Always, IfNotPresent, Never. If a container's imagePullPolicy parameter is not specified, OpenShift Container Platform sets it based on the image's tag. If the tag is latest, OpenShift Container Platform defaults imagePullPolicy to Always. Otherwise, OpenShift Container Platform defaults imagePullPolicy to IfNotPresent.\n\nImpact:\n\nCredentials would be required to pull the private images every time. Also, in trusted environments, this might increases load on network, registry, and decreases speed.\n\nThis setting could impact offline or isolated clusters, which have images pre-loaded and do not have access to a registry to pull in-use images. This setting is not appropriate for clusters which use this configuration.",
        "solution": "None.\n\nDefault Value:\n\nWhen OpenShift Container Platform creates containers, it uses the container's imagePullPolicy to determine if the image should be pulled prior to starting the container.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "not_expect": "Admission Plugins: .*\"AlwaysPullImages\".*"
    },
    "custom_item_20": {
        "description": "1.2.12 Ensure that the admission control plugin ServiceAccount is set",
        "info": "Automate service accounts management.\n\nRationale:\n\nWhen you create a pod, if you do not specify a service account, it is automatically assigned the default service account in the same namespace. You should create your own service account and let the API server manage its security tokens.\n\nImpact:\n\nNone.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift configures the ServiceAccount admission controller.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "expect": "Admission Plugins: .*\"ServiceAccount\".*"
    },
    "custom_item_21": {
        "description": "1.2.13 Ensure that the admission control plugin NamespaceLifecycle is set",
        "info": "Reject creating objects in a namespace that is undergoing termination.\n\nRationale:\n\nSetting admission control policy to NamespaceLifecycle ensures that objects cannot be created in non-existent namespaces, and that namespaces undergoing termination are not used for creating the new objects. This is recommended to enforce the integrity of the namespace termination process and also for the availability of the newer objects.\n\nImpact:\n\nNone.",
        "solution": "None.\n\nDefault Value:\n\nOpenShift configures NamespaceLifecycle admission controller by default.",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|14.6,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "expect": "Admission Plugins: .*\"NamespaceLifecycle\".*"
    },
    "custom_item_22": {
        "description": "1.2.14 Ensure that the admission control plugin SecurityContextConstraint is set",
        "info": "Reject creating pods that do not match Pod Security Policies.\n\nRationale:\n\nA Pod Security Policy is a cluster-level resource that controls the actions that a pod can perform and what it has the ability to access. The PodSecurityPolicy objects define a set of conditions that a pod must run with in order to be accepted into the system. Pod Security Policies are composed of settings and strategies that control the security features a pod has access to and hence this must be used to control pod access permissions.\n\nNote: When the PodSecurityPolicy admission plugin is in use, there needs to be at least one PodSecurityPolicy in place for ANY pods to be admitted. See section 5.2 for recommendations on PodSecurityPolicy settings.\n\nImpact:\n\nDefault Security Context Constraint objects are present on the cluster and granted by default based on roles. Custom SCCs can be created and granted as needed.",
        "solution": "None.\n\nDefault Value:\n\nBy default, the SecurityContextConstraints admission controller is configured and cannot be disabled.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|9.4,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "expect": "Admission Plugins: .*\"security.openshift.io/SecurityContextConstraint\".*"
    },
    "custom_item_23": {
        "description": "1.2.15 Ensure that the admission control plugin NodeRestriction is set",
        "info": "Limit the Node and Pod objects that a kubelet could modify.\n\nRationale:\n\nUsing the NodeRestriction plug-in ensures that the kubelet is restricted to the Node and Pod objects that it could modify as defined. Such kubelets will only be allowed to modify their own Node API object, and only modify Pod API objects that are bound to their node.\n\nImpact:\n\nNone.",
        "solution": "None.\n\nDefault Value:\n\nIn OpenShift, the NodeRestriction admission plugin is enabled by default and cannot be disabled.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|9.4,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Admission Plugins: \\(.apiServerArguments.\"enable-admission-plugins\")\"",
        "expect": "Admission Plugins: .*\"NodeRestriction\".*"
    },
    "custom_item_24": {
        "description": "1.2.16 Ensure that the --insecure-bind-address argument is not set - feature-gates",
        "info": "Do not bind the insecure API service.\n\nRationale:\n\nIf you bind the apiserver to an insecure address, basically anyone who could connect to it over the insecure port, would have unauthenticated and unencrypted access to your master node. The apiserver doesn't do any authentication checking for insecure binds and traffic to the Insecure API port is not encrypted, allowing attackers to potentially read sensitive data in transit.\n\nImpact:\n\nConnections to the API server will require valid authentication credentials.",
        "solution": "None.\n\nDefault Value:\n\nBy default, the openshift-kube-apiserver is served over HTTPS with authentication and authorization; the secure API endpoint is bound to 0.0.0.0:6443. Note that the openshift-apiserver is not running in the host network namespace. The port is not exposed on the node, but only through the pod network.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|9.2,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getKubeApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Feature Gates: \\(.spec.observedConfig.apiServerArguments.\"feature-gates\")\"",
        "not_expect": "Feature Gates:.*\"InsecureBindAddress=true\".*"
    },
    "custom_item_25": {
        "description": "1.2.16 Ensure that the --insecure-bind-address argument is not set - openshift-kube-apiserver",
        "info": "Do not bind the insecure API service.\n\nRationale:\n\nIf you bind the apiserver to an insecure address, basically anyone who could connect to it over the insecure port, would have unauthenticated and unencrypted access to your master node. The apiserver doesn't do any authentication checking for insecure binds and traffic to the Insecure API port is not encrypted, allowing attackers to potentially read sensitive data in transit.\n\nImpact:\n\nConnections to the API server will require valid authentication credentials.",
        "solution": "None.\n\nDefault Value:\n\nBy default, the openshift-kube-apiserver is served over HTTPS with authentication and authorization; the secure API endpoint is bound to 0.0.0.0:6443. Note that the openshift-apiserver is not running in the host network namespace. The port is not exposed on the node, but only through the pod network.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|9.2,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getEndpoints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.namespace == \"openshift-kube-apiserver\") | .metadata.name as $name | .metadata.uid as $uid | .subsets[] | .ports[] | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Port: \\(.port)\"",
        "expect": "Port: 6443$"
    },
    "custom_item_26": {
        "description": "1.2.16 Ensure that the --insecure-bind-address argument is not set - openshift-apiserver",
        "info": "Do not bind the insecure API service.\n\nRationale:\n\nIf you bind the apiserver to an insecure address, basically anyone who could connect to it over the insecure port, would have unauthenticated and unencrypted access to your master node. The apiserver doesn't do any authentication checking for insecure binds and traffic to the Insecure API port is not encrypted, allowing attackers to potentially read sensitive data in transit.\n\nImpact:\n\nConnections to the API server will require valid authentication credentials.",
        "solution": "None.\n\nDefault Value:\n\nBy default, the openshift-kube-apiserver is served over HTTPS with authentication and authorization; the secure API endpoint is bound to 0.0.0.0:6443. Note that the openshift-apiserver is not running in the host network namespace. The port is not exposed on the node, but only through the pod network.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|9.2,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getEndpoints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.namespace == \"openshift-apiserver\") | .metadata.name as $name | .metadata.uid as $uid | .subsets[] | .ports[] | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Port: \\(.port)\"",
        "expect": "Port: 8443$"
    },
    "custom_item_27": {
        "description": "1.2.17 Ensure that the --insecure-port argument is set to 0",
        "info": "Do not bind to insecure port.\n\nRationale:\n\nSetting up the apiserver to serve on an insecure port would allow unauthenticated and unencrypted access to your master node. This would allow attackers who could access this port, to easily take control of the cluster.\n\nImpact:\n\nAll components that use the API must connect via the secured port, authenticate themselves, and be authorized to use the API.\n\nThis includes:\n\nkube-controller-manager\n\nkube-proxy\n\nkube-scheduler\n\nkubelets",
        "solution": "None.\n\nDefault Value:\n\nBy default, the openshift-kube-server is served over HTTPS with authentication and authorization; the secure API endpoint is bound to 0.0.0.0:6443 and the insecure-port has been removed in Kubernetes 1.20+.",
        "reference": "800-53|SA-15,800-53r5|SA-15,CSCv7|9.4,CSCv8|16.11,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getEndpoints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.namespace == \"openshift-kube-apiserver\") | .metadata.name as $name | .metadata.uid as $uid | .subsets[] | .ports[] | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Port: \\(.port)\"",
        "expect": "Port: 6443$"
    },
    "custom_item_28": {
        "description": "1.2.18 Ensure that the --secure-port argument is not set to 0 - KubeApiServers",
        "info": "Do not disable the secure port.\n\nRationale:\n\nThe secure port is used to serve https with authentication and authorization. If you disable it, no https traffic is served and all traffic is served unencrypted.\n\nImpact:\n\nYou need to set the API Server up with the right TLS certificates.",
        "solution": "None.\n\nDefault Value:\n\nBy default, the openshift-kube-apiserver is served over HTTPS with authentication and authorization; the secure API endpoint is bound to 0.0.0.0:6443. Note that the openshift-apiserver is not running in the host network namespace. The port is not exposed on the node, but only through the pod network.\n\nThe OpenShift platform manages the TLS certificates for the API servers. External access is only available through the load balancer and then through the internal service.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getKubeApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Bind Address: \\(.spec.observedConfig.servingInfo.\"bindAddress\")\"",
        "expect": "Bind Address: 0.0.0.0:6443"
    },
    "custom_item_29": {
        "description": "1.2.18 Ensure that the --secure-port argument is not set to 0 - Pods",
        "info": "Do not disable the secure port.\n\nRationale:\n\nThe secure port is used to serve https with authentication and authorization. If you disable it, no https traffic is served and all traffic is served unencrypted.\n\nImpact:\n\nYou need to set the API Server up with the right TLS certificates.",
        "solution": "None.\n\nDefault Value:\n\nBy default, the openshift-kube-apiserver is served over HTTPS with authentication and authorization; the secure API endpoint is bound to 0.0.0.0:6443. Note that the openshift-apiserver is not running in the host network namespace. The port is not exposed on the node, but only through the pod network.\n\nThe OpenShift platform manages the TLS certificates for the API servers. External access is only available through the load balancer and then through the internal service.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getPods_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.name as $name | .metadata.uid as $uid | .spec.containers[] | select(.name == \"kube-apiserver\") | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Port: \\(.ports[].containerPort)\"",
        "expect": "Port: 6443"
    },
    "custom_item_30": {
        "description": "1.2.22 Ensure that the maximumRetainedFiles argument is set to 10 or as appropriate",
        "info": "Retain 10 or an appropriate number of old log files.\n\nRationale:\n\nKubernetes automatically rotates the log files. Retaining old log files ensures that you would have sufficient log data available for carrying out any investigation or correlation. For example, if you have set file size of 100 MB and the number of old log files to keep as 10, you would have approximately 1 GB of log data that you could potentially use for your analysis.\n\nImpact:\n\nNone.",
        "solution": "None.\n\nDefault Value:\n\nBy default, auditing is enabled and the maximum audit log backup is set to 10.",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1M,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Maximum Retained Files: \\(.apiServerArguments.\"audit-log-maxbackup\")\"",
        "expect": "Maximum Retained Files: \\[\"@AUDIT_LOG_MAXBACKUP@\"\\]$"
    },
    "custom_item_31": {
        "description": "1.2.23 Ensure that the maximumFileSizeMegabytes argument is set to 100",
        "info": "Audit logs are rotated upon reaching a maximum size, which is 100 MB by default.\n\nRationale:\n\nOpenShift automatically rotates the log files. Retaining old log files ensures that you would have sufficient log data available for carrying out any investigation or correlation. If you have set file size of 100 MB and the number of old log files to keep as 10, you would have approximately 1 GB of log data that you could potentially use for your analysis.\n\nImpact:\n\nNone",
        "solution": "None. The audit-log-maxsize parameter is by default set to 100 and not supported to change.\n\nmaximumFileSizeMegabytes: 100\n\nDefault Value:\n\nBy default, auditing is enabled.",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1M,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Maximum File Size: \\(.apiServerArguments.\"audit-log-maxsize\")\"",
        "expect": "Maximum File Size: \\[\"@AUDIT_LOG_MAXSIZE@\"\\]$"
    },
    "custom_item_32": {
        "description": "1.2.24 Ensure that the --request-timeout argument is set",
        "info": "The API server minimum request timeout defines the minimum number of seconds a handler must keep a request open before timing it out.\n\nRationale:\n\nSetting global request timeout allows extending the API server request timeout limit to a duration appropriate to the user's connection speed. By default, it is set to 3600 seconds in OpenShift 4. Allowing users to set this timeout limit to be too small can be insufficient for some connections and too large can exhaust the API server resources making it prone to Denial-of-Service attack. Hence, it is not supported to adjust this value in OpenShift 4.\n\nImpact:\n\nNone",
        "solution": "None\n\nDefault Value:\n\nBy default, min-request-timeout is set to 3600 seconds in OpenShift 4",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Request Timeout Seconds: \\(.apiServerArguments.\"min-request-timeout\")\"",
        "expect": "Request Timeout Seconds: \\[\"@REQUEST_TIMEOUT@\"\\]"
    },
    "custom_item_33": {
        "description": "1.2.25 Ensure that the --service-account-lookup argument is set to true",
        "info": "Validate service account before validating token.\n\nRationale:\n\nIf --service-account-lookup is not enabled, the apiserver only verifies that the authentication token is valid, and does not validate that the service account token mentioned in the request is actually present in etcd. This allows using a service account token even after the corresponding service account is deleted. This is an example of time of check to time of use security issue.\n\nImpact:\n\nNone.",
        "solution": "None.\n\nDefault Value:\n\nService account lookup is enabled by default.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.7,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Service Account Lookup: \\(.apiServerArguments.\"service-account-lookup\")\"",
        "expect": "Service Account Lookup: \\[\"true\"\\]"
    },
    "custom_item_34": {
        "description": "1.2.26 Ensure that the --service-account-key-file argument is set as appropriate",
        "info": "Explicitly set a service account public key file for service accounts on the apiserver.\n\nRationale:\n\nBy default, if no --service-account-key-file is specified to the apiserver, it uses the private key from the TLS serving certificate to verify service account tokens. To ensure that the keys for service account tokens could be rotated as needed, a separate public/private key pair should be used for signing service account tokens. Hence, the public key should be specified to the apiserver with --service-account-key-file.\n\nImpact:\n\nThe corresponding private key must be provided to the controller manager. You would need to securely maintain the key file and rotate the keys based on your organization's key rotation policy.",
        "solution": "The OpenShift API server does not use the service-account-key-file argument. The ServiceAccount token authenticator is configured with serviceAccountConfig.publicKeyFiles. OpenShift does not reuse the apiserver TLS key. This is not configurable.\n\nDefault Value:\n\nThe OpenShift API server does not use the service-account-key-file argument. The ServiceAccount token authenticator is configured with serviceAccountConfig.publicKeyFiles. OpenShift does not reuse the apiserver TLS key.",
        "reference": "800-171|3.5.2,800-53|IA-5(1),800-53r5|IA-5(1),CSCv7|4.4,CSCv8|5.2,CSF|PR.AC-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),ITSG-33|IA-5(1),LEVEL|1M,NESA|T5.2.3,QCSC-v1|5.2.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Service Account Public Key Files: \\(.serviceAccountPublicKeyFiles | sort)\"",
        "expect": "Service Account Public Key Files: \\[\"/etc/kubernetes/static-pod-resources/configmaps/bound-sa-token-signing-certs\",\"/etc/kubernetes/static-pod-resources/configmaps/sa-token-signing-certs\"\\]"
    },
    "custom_item_35": {
        "description": "1.2.27 Ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate",
        "info": "etcd should be configured to make use of TLS encryption for client connections.\n\nRationale:\n\netcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be protected by client authentication. This requires the API server to identify itself to the etcd server using a client certificate and key.\n\nImpact:\n\nTLS and client certificate authentication are configured by default for etcd.",
        "solution": "OpenShift automatically manages TLS and client certificate authentication for etcd. This is not configurable.\n\nDefault Value:\n\nBy default, OpenShift uses X.509 certificates to provide secure communication to etcd. OpenShift configures these automatically. OpenShift does not use the etcd-certfile or etcd-keyfile flags. OpenShift generates the necessary files and sets the arguments appropriately.",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|1M,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Cert File: \\(.apiServerArguments.\"etcd-certfile\"), Key File: \\(.apiServerArguments.\"etcd-keyfile\")\"",
        "expect": "Cert File: \\[\"/etc/kubernetes/static-pod-resources/secrets/etcd-client/tls.crt\"\\], Key File: \\[\"/etc/kubernetes/static-pod-resources/secrets/etcd-client/tls.key\"\\]"
    },
    "custom_item_36": {
        "description": "1.2.28 Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate",
        "info": "Setup TLS connection on the API server.\n\nRationale:\n\nAPI server communication contains sensitive parameters that should remain encrypted in transit. Configure the API server to serve only HTTPS traffic.\n\nImpact:\n\nTLS and client certificate authentication must be configured for your Kubernetes cluster deployment. By default, OpenShift uses X.509 certificates to provide secure connections between the API server and node/kubelet. OpenShift Container Platform monitors certificates for proper validity, for the cluster certificates it issues and manages. The OpenShift Container Platform manages certificate rotation and the alerting framework has rules to help identify when a certificate issue is about to occur.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift uses X.509 certificates to provide secure connections between the API server and node/kubelet. OpenShift does not use values assigned to the tls-cert-file or tls-private-key-file flags.\n\nYou may optionally set a custom default certificate to be used by the API server when serving content in order to enable clients to access the API server at a different host name or without the need to distribute the cluster-managed certificate authority (CA) certificates to the clients. Follow the directions in the OpenShift documentation\n\nUser-provided certificates for the API server",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Cert File: \\(.apiServerArguments.\"tls-cert-file\"), Key File: \\(.apiServerArguments.\"tls-private-key-file\")\"",
        "expect": "Cert File: \\[\"/etc/kubernetes/static-pod-certs/secrets/service-network-serving-certkey/tls.crt\"\\], Key File: \\[\"/etc/kubernetes/static-pod-certs/secrets/service-network-serving-certkey/tls.key\"\\]"
    },
    "custom_item_37": {
        "description": "1.2.29 Ensure that the --client-ca-file argument is set as appropriate",
        "info": "Setup TLS connection on the API server.\n\nRationale:\n\nAPI server communication contains sensitive parameters that should remain encrypted in transit. Configure the API server to serve only HTTPS traffic. If --client-ca-file argument is set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate.\n\nImpact:\n\nTLS and client certificate authentication must be configured for your Kubernetes cluster deployment. By default, OpenShift uses X.509 certificates to provide secure connections between the API server and node/kubelet. OpenShift Container Platform monitors certificates for proper validity, for the cluster certificates it issues and manages. The OpenShift Container Platform alerting framework has rules to help identify when a certificate issue is about to occur. These rules consist of the following checks:\n\nAPI server client certificate expiration is less than five minutes.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift configures the client-ca-file and automatically manages the certificate. It does not use the value assigned to the client-ca-file flag.\n\nYou may optionally set a custom default certificate to be used by the API server when serving content in order to enable clients to access the API server at a different host name or without the need to distribute the cluster-managed certificate authority (CA) certificates to the clients.\n\nPlease follow the OpenShift documentation for providing certificates for OpenShift to use.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Client CA: \\(.apiServerArguments.\"client-ca-file\")\"",
        "expect": "Client CA: \\[\"/etc/kubernetes/static-pod-certs/configmaps/client-ca/ca-bundle.crt\"\\]"
    },
    "custom_item_38": {
        "description": "1.2.30 Ensure that the --etcd-cafile argument is set as appropriate",
        "info": "etcd should be configured to make use of TLS encryption for client connections.\n\nRationale:\n\netcd is a highly-available key value store used by Kubernetes deployments for persistent storage of all of its REST API objects. These objects are sensitive in nature and should be protected by client authentication. This requires the API server to identify itself to the etcd server using a SSL Certificate Authority file.\n\nImpact:\n\nTLS and client certificate authentication must be configured for etcd.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift uses X.509 certificates to provide secure communication to etcd. OpenShift does not use values assigned to etcd-cafile. OpenShift generates the etcd-cafile and sets the arguments appropriately in the API server. Communication with etcd is secured by the etcd serving CA.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Client CA: \\(.apiServerArguments.\"etcd-cafile\")\"",
        "expect": "CA: \\[\"/etc/kubernetes/static-pod-resources/configmaps/etcd-serving-ca/ca-bundle.crt\"\\]"
    },
    "custom_item_39": {
        "description": "1.2.31 Ensure that encryption providers are appropriately configured",
        "info": "Where etcd encryption is used, appropriate providers should be configured.\n\nRationale:\n\nWhere etcd encryption is used, it is important to ensure that the appropriate set of encryption providers is used. Currently, the aescbc, kms and secretbox are likely to be appropriate options.\n\nImpact:\n\nWhen you enable etcd encryption, the following OpenShift API server and Kubernetes API server resources are encrypted:\n\nSecrets\n\nConfigMaps\n\nRoutes\n\nOAuth access tokens\n\nOAuth authorize tokens\n\nWhen you enable etcd encryption, encryption keys are created. These keys are rotated on a weekly basis. You must have these keys in order to restore from an etcd backup.",
        "solution": "Follow the OpenShift documentation for encrypting etcd data.\n\nDefault Value:\n\nBy default, no encryption provider is set.",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|1M,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getOpenShiftApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.name as $name | .metadata.uid as $uid | .status.conditions[] | select(.type == \"Encrypted\") | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Type: \\(.type), Reason: \\(.reason), Message: \\(.message)\"",
        "expect": "Reason: EncryptionCompleted$"
    },
    "custom_item_40": {
        "description": "1.2.33 Ensure unsupported configuration overrides are not used",
        "info": "OpenShift supported an option called unsupportedConfigOverrides that allowed users to opt into unsupported behavior. This option is no longer supported by OpenShift and should not be used.\n\nRationale:\n\nUsers should stop using deprecated and unmaintained features in favor of supported features.\n\nImpact:\n\nNone. The feature is set to null by default and isn't used by default.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift sets this value to null and doesn't support overriding configuration with unsupported features.",
        "reference": "800-53|SA-22,800-53r5|SA-22,CSCv7|2.2,CSCv8|2.2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getKubeApiServers",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Unsupported Config Overrides: \\(.spec.unsupportedConfigOverrides)\"",
        "expect": "Unsupported Config Overrides: null"
    },
    "custom_item_41": {
        "description": "1.3.2 Ensure that the --use-service-account-credentials argument is set to true",
        "info": "Use individual service account credentials for each controller.\n\nRationale:\n\nThe controller manager creates a service account per controller in the kube-system namespace, generates a credential for it, and builds a dedicated API client with that service account credential for each controller loop to use. Setting the --use-service-account-credentials to true runs each control loop within the controller manager using a separate service account credential. When used in combination with RBAC, this ensures that the control loops run with the minimum permissions required to perform their intended tasks.\n\nImpact:\n\nWhatever authorizer is configured for the cluster, it must grant sufficient permissions to the service accounts to perform their intended tasks. When using the RBAC authorizer, those roles are created and bound to the appropriate service accounts in the kube-system namespace automatically with default roles and rolebindings that are auto-reconciled on startup.\n\nIf using other authorization methods (ABAC, Webhook, etc), the cluster deployer is responsible for granting appropriate permissions to the service accounts (the required permissions can be seen by inspecting the controller-roles.yaml and controller-role-bindings.yaml files for the RBAC roles.",
        "solution": "None.\n\nDefault Value:\n\nBy default, in OpenShift 4 --use-service-account-credentials is set to true.\n\nThe OpenShift Controller Manager operator manages and updates the OpenShift Controller Manager. The Kubernetes Controller Manager operator manages and updates the Kubernetes Controller Manager deployed on top of OpenShift. This operator is configured via KubeControllerManager custom resource.",
        "reference": "800-171|3.5.2,800-53|IA-5(1),800-53r5|IA-5(1),CSCv7|4.4,CSCv8|5.2,CSF|PR.AC-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),ITSG-33|IA-5(1),LEVEL|1M,NESA|T5.2.3,QCSC-v1|5.2.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-controller-manager",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | select(.extendedArguments != null) | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Use Service Account Credentials: \\(.extendedArguments.\"use-service-account-credentials\")\"",
        "expect": "Use Service Account Credentials: \\[\"true\"\\]"
    },
    "custom_item_42": {
        "description": "1.3.3 Ensure that the --service-account-private-key-file argument is set as appropriate",
        "info": "Explicitly set a service account private key file for service accounts on the controller manager.\n\nRationale:\n\nTo ensure that keys for service account tokens can be rotated as needed, a separate public/private key pair should be used for signing service account tokens. The private key should be specified to the controller manager with --service-account-private-key-file as appropriate.\n\nImpact:\n\nYou would need to securely maintain the key file and rotate the keys based on your organization's key rotation policy.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift starts the controller manager with service-account-private-key-file set to /etc/kubernetes/static-pod-resources/secrets/service-account-private-key/service-account.key. OpenShift manages the service account credentials for the scheduler automatically.",
        "reference": "800-171|3.5.2,800-53|IA-5(1),800-53r5|IA-5(1),CSCv7|4.4,CSCv8|5.2,CSF|PR.AC-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),ITSG-33|IA-5(1),LEVEL|1M,NESA|T5.2.3,QCSC-v1|5.2.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-controller-manager",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | select(.extendedArguments != null) | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Service Account Private Key File: \\(.extendedArguments.\"service-account-private-key-file\")\"",
        "expect": "Service Account Private Key File: \\[\"/etc/kubernetes/static-pod-resources/secrets/service-account-private-key/service-account.key\"\\]"
    },
    "custom_item_43": {
        "description": "1.3.4 Ensure that the --root-ca-file argument is set as appropriate",
        "info": "Allow pods to verify the API server's serving certificate before establishing connections.\n\nRationale:\n\nProcesses running within pods that need to contact the API server must verify the API server's serving certificate. Failing to do so could be a subject to man-in-the-middle attacks.\n\nProviding the root certificate for the API server's serving certificate to the controller manager with the --root-ca-file argument allows the controller manager to inject the trusted bundle into pods so that they can verify TLS connections to the API server.\n\nImpact:\n\nOpenShift clusters manage and maintain certificate authorities and certificates for cluster components.",
        "solution": "None.\n\nDefault Value:\n\nBy default, OpenShift sets the Kubernetes Controller Manager root-ca-file to /etc/kubernetes/static-pod-resources/configmaps/serviceaccount-ca/ca-bundle.crt.\n\nCertificates for OpenShift platform components are automatically created and rotated by the OpenShift Container Platform.",
        "reference": "800-171|3.13.1,800-53|SC-7(8),800-53r5|SC-7(8),CN-L3|8.1.10.6(j),CSCv7|4.4,CSCv8|13.10,CSF|PR.AC-5,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7(8),LEVEL|1M,NESA|T4.5.4,NIAv2|SU4,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-controller-manager",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | select(.extendedArguments != null) | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Root CA File: \\(.extendedArguments.\"root-ca-file\")\"",
        "expect": "Root CA File: \\[\"/etc/kubernetes/static-pod-resources/configmaps/serviceaccount-ca/ca-bundle.crt\"\\]"
    },
    "custom_item_44": {
        "description": "4.2.5 Verify that the read only port is not used or is set to 0",
        "info": "Disable the read-only port.\n\nRationale:\n\nThe Kubelet process provides a read-only API in addition to the main Kubelet API. Unauthenticated access is provided to this read-only API which could possibly retrieve potentially sensitive information about the cluster.\n\nImpact:\n\nRemoval of the read-only port will require that any service which made use of it will need to be re-configured to use the main Kubelet API.",
        "solution": "In earlier versions of OpenShift 4, the read-only-port argument is not used.\nFollow the instructions in the documentation to create a kubeletconfig CRD and set the kubelet-read-only-port is set to 0.\n\nDefault Value:\n\nBy default, in OpenShift 4.5 and earlier, the --read-only-port is not used. In OpenShift 4.6 and above, the kubelet-read-only-port is set to 0.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Read Only Port: \\(.apiServerArguments.\"kubelet-read-only-port\")\"",
        "expect": "Read Only Port: \\[\"0\"\\]"
    },
    "custom_item_45": {
        "description": "4.2.9 Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate",
        "info": "Setup TLS connection on the Kubelets.\n\nRationale:\n\nThe connections from the apiserver to the kubelet are used for fetching logs for pods, attaching (through kubectl) to running pods, and using the kubelet's port-forwarding functionality. These connections terminate at the kubelet's HTTPS endpoint. By default, the apiserver does not verify the kubelet's serving certificate, which makes the connection subject to man-in-the-middle attacks, and unsafe to run over untrusted and/or public networks.\n\nImpact:\n\nTLS and client certificate authentication must be configured for your Kubernetes cluster deployment.",
        "solution": "OpenShift automatically manages TLS authentication for the API server communication with the node/kublet. This is not configurable.\n\nDefault Value:\n\nBy default, OpenShift uses X.509 certificates to provide secure connections between the API server and node/kubelet. OpenShift does not use values assigned to the tls-cert-file or tls-private-key-file flags.",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getConfigMaps_openshift-kube-apiserver",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.uid as $uid | .metadata.name as $name | select($name == \"config\") | select(.data.\"config.yaml\" | length > 0) | .data.\"config.yaml\" | fromjson | \"Cluster ID: \\($clusterID), Name: \\($name), UID: \\($uid), Certificate: \\(.apiServerArguments.\"kubelet-client-certificate\"), Key: \\(.apiServerArguments.\"kubelet-client-key\")\"",
        "expect": "Certificate: \\[\"/etc/kubernetes/static-pod-certs/secrets/kubelet-client/tls.crt\"\\], Key: \\[\"/etc/kubernetes/static-pod-certs/secrets/kubelet-client/tls.key\"\\]"
    },
    "custom_item_46": {
        "description": "5.1.1 Ensure that the cluster-admin role is only used where required - ClusterRoleBindings",
        "info": "The RBAC role cluster-admin provides wide-ranging powers over the environment and should be used only where and when needed.\n\nRationale:\n\nKubernetes provides a set of default roles where RBAC is used. Some of these roles such as cluster-admin provide wide-ranging privileges which should only be applied where absolutely necessary. Roles such as cluster-admin allow super-user access to perform any action on any resource. When used in a ClusterRoleBinding, it gives full control over every resource in the cluster and in all namespaces. When used in a RoleBinding, it gives full control over every resource in the rolebinding's namespace, including the namespace itself.\n\nImpact:\n\nCare should be taken before removing any clusterrolebindings from the environment to ensure they were not required for operation of the cluster. Specifically, modifications should not be made to clusterrolebindings with the system: prefix as they are required for the operation of system components.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Identify all clusterrolebindings to the cluster-admin role. Check if they are used and if they need this role or if they could use a role with fewer privileges.\nWhere possible, first bind users to a lower privileged role and then remove the clusterrolebinding to the cluster-admin role :\n\noc delete clusterrolebinding [name]\n\nDefault Value:\n\nBy default a single clusterrolebinding called cluster-admin is provided with the system:masters group as its principal.\n\nThe principal for cluster-admin also includes system:cluster-admins (Group) and system:admin (User).",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getClusterRoleBindings",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | .metadata.name as $name | .metadata.uid as $uid | .subjects[]  | \"Cluster ID: \\($clusterID), Role: \\($name), UID: \\($uid), Name: \\(.name), Kind: \\(.kind)\"",
        "regex": "Role: cluster-admin",
        "expect": "MANUAL_REVIEW_REQUIRED"
    },
    "custom_item_47": {
        "description": "5.1.1 Ensure that the cluster-admin role is only used where required - Secrets",
        "info": "The RBAC role cluster-admin provides wide-ranging powers over the environment and should be used only where and when needed.\n\nRationale:\n\nKubernetes provides a set of default roles where RBAC is used. Some of these roles such as cluster-admin provide wide-ranging privileges which should only be applied where absolutely necessary. Roles such as cluster-admin allow super-user access to perform any action on any resource. When used in a ClusterRoleBinding, it gives full control over every resource in the cluster and in all namespaces. When used in a RoleBinding, it gives full control over every resource in the rolebinding's namespace, including the namespace itself.\n\nImpact:\n\nCare should be taken before removing any clusterrolebindings from the environment to ensure they were not required for operation of the cluster. Specifically, modifications should not be made to clusterrolebindings with the system: prefix as they are required for the operation of system components.",
        "solution": "Identify all clusterrolebindings to the cluster-admin role. Check if they are used and if they need this role or if they could use a role with fewer privileges.\nWhere possible, first bind users to a lower privileged role and then remove the clusterrolebinding to the cluster-admin role :\n\noc delete clusterrolebinding [name]\n\nDefault Value:\n\nBy default a single clusterrolebinding called cluster-admin is provided with the system:masters group as its principal.\n\nThe principal for cluster-admin also includes system:cluster-admins (Group) and system:admin (User).",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecrets_kube-system",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.metadata.name==\"kubeadmin\") | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid)\"",
        "not_expect": "Name: kubeadmin"
    },
    "custom_item_48": {
        "description": "5.1.3 Minimize wildcard use in Roles and ClusterRoles - Roles",
        "info": "Kubernetes Roles and ClusterRoles provide access to resources based on sets of objects and actions that can be taken on those objects. It is possible to set either of these to be the wildcard '*' which matches all items.\n\nUse of wildcards is not optimal from a security perspective as it may allow for inadvertent access to be granted when new resources are added to the Kubernetes API either as CRDs or in later versions of the product.\n\nRationale:\n\nThe principle of least privilege recommends that users are provided only the access required for their role and nothing more. The use of wildcard rights grants is likely to provide excessive rights to the Kubernetes API.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Where possible replace any use of wildcards in clusterroles and roles with specific objects or actions.",
        "reference": "800-171|3.1.1,800-171|3.1.5,800-171|3.3.8,800-171|3.3.9,800-53|AC-2,800-53|AC-3,800-53|AC-6,800-53|AC-6(1),800-53|AC-6(7),800-53|AU-9(4),800-53r5|AC-2,800-53r5|AC-3,800-53r5|AC-6,800-53r5|AC-6(1),800-53r5|AC-6(7),800-53r5|AU-9(4),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(d),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(d),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|4.4,CSCv7|14.6,CSCv8|6.8,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.9.2.1,ISO/IEC-27001|A.9.2.5,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.4,ISO/IEC-27001|A.9.4.5,ISO/IEC-27001|A.12.4.2,ITSG-33|AC-2,ITSG-33|AC-3,ITSG-33|AC-6,ITSG-33|AC-6(1),ITSG-33|AU-9(4),ITSG-33|AU-9(4)(a),ITSG-33|AU-9(4)(b),LEVEL|1M,NESA|M1.1.3,NESA|M1.2.2,NESA|M5.2.3,NESA|M5.5.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM28,NIAv2|AM31,NIAv2|GS3,NIAv2|GS4,NIAv2|GS8c,NIAv2|NS5j,NIAv2|SM5,NIAv2|SM6,NIAv2|SS13c,NIAv2|SS14e,NIAv2|SS15c,NIAv2|SS29,NIAv2|VL3b,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.5,PCI-DSSv3.2.1|10.5.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.3.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getRoles",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Namespace: \\(.metadata.namespace), Rules: \\(.rules[])\"",
        "regex": "\\*",
        "not_expect": "\\*"
    },
    "custom_item_49": {
        "description": "5.1.3 Minimize wildcard use in Roles and ClusterRoles - ClusterRoles",
        "info": "Kubernetes Roles and ClusterRoles provide access to resources based on sets of objects and actions that can be taken on those objects. It is possible to set either of these to be the wildcard '*' which matches all items.\n\nUse of wildcards is not optimal from a security perspective as it may allow for inadvertent access to be granted when new resources are added to the Kubernetes API either as CRDs or in later versions of the product.\n\nRationale:\n\nThe principle of least privilege recommends that users are provided only the access required for their role and nothing more. The use of wildcard rights grants is likely to provide excessive rights to the Kubernetes API.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Where possible replace any use of wildcards in clusterroles and roles with specific objects or actions.",
        "reference": "800-171|3.1.1,800-171|3.1.5,800-171|3.3.8,800-171|3.3.9,800-53|AC-2,800-53|AC-3,800-53|AC-6,800-53|AC-6(1),800-53|AC-6(7),800-53|AU-9(4),800-53r5|AC-2,800-53r5|AC-3,800-53r5|AC-6,800-53r5|AC-6(1),800-53r5|AC-6(7),800-53r5|AU-9(4),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(d),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(d),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|4.4,CSCv7|14.6,CSCv8|6.8,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.9.2.1,ISO/IEC-27001|A.9.2.5,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.4,ISO/IEC-27001|A.9.4.5,ISO/IEC-27001|A.12.4.2,ITSG-33|AC-2,ITSG-33|AC-3,ITSG-33|AC-6,ITSG-33|AC-6(1),ITSG-33|AU-9(4),ITSG-33|AU-9(4)(a),ITSG-33|AU-9(4)(b),LEVEL|1M,NESA|M1.1.3,NESA|M1.2.2,NESA|M5.2.3,NESA|M5.5.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM28,NIAv2|AM31,NIAv2|GS3,NIAv2|GS4,NIAv2|GS8c,NIAv2|NS5j,NIAv2|SM5,NIAv2|SM6,NIAv2|SS13c,NIAv2|SS14e,NIAv2|SS15c,NIAv2|SS29,NIAv2|VL3b,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.5,PCI-DSSv3.2.1|10.5.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.3.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getClusterRoles",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Rules: \\(.rules[])\"",
        "regex": "\\*",
        "not_expect": "\\*"
    },
    "custom_item_50": {
        "description": "5.1.6 Ensure that Service Account Tokens are only mounted where necessary - Pods",
        "info": "Service accounts tokens should not be mounted in pods except where the workload running in the pod explicitly needs to communicate with the API server\n\nRationale:\n\nMounting service account tokens inside pods can provide an avenue for privilege escalation attacks where an attacker is able to compromise a single pod in the cluster.\n\nAvoiding mounting these tokens removes this attack avenue.\n\nImpact:\n\nPods mounted without service account tokens will not be able to communicate with the API server, except where the resource is available to unauthenticated principals.",
        "solution": "Modify the definition of pods and service accounts which do not need to mount service account tokens to disable it.\n\nDefault Value:\n\nBy default, all pods get a service account token mounted in them.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|13.4,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getPods",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Automount Service Account Token: \\(.spec.automountServiceAccountToken)\"",
        "not_expect": "Automount Service Account Token: true"
    },
    "custom_item_51": {
        "description": "5.1.6 Ensure that Service Account Tokens are only mounted where necessary - ServiceAccounts",
        "info": "Service accounts tokens should not be mounted in pods except where the workload running in the pod explicitly needs to communicate with the API server\n\nRationale:\n\nMounting service account tokens inside pods can provide an avenue for privilege escalation attacks where an attacker is able to compromise a single pod in the cluster.\n\nAvoiding mounting these tokens removes this attack avenue.\n\nImpact:\n\nPods mounted without service account tokens will not be able to communicate with the API server, except where the resource is available to unauthenticated principals.",
        "solution": "Modify the definition of pods and service accounts which do not need to mount service account tokens to disable it.\n\nDefault Value:\n\nBy default, all pods get a service account token mounted in them.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|13.4,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getServiceAccounts",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Automount Service Account Token: \\(.automountServiceAccountToken)\"",
        "not_expect": "Automount Service Account Token: true"
    },
    "custom_item_52": {
        "description": "5.2.1 Minimize the admission of privileged containers",
        "info": "Do not generally permit containers to be run with the securityContext.privileged flag set to true.\n\nRationale:\n\nPrivileged containers have access to all Linux Kernel capabilities and devices. A container running with full privileges can do almost everything that the host can do. This flag exists to allow special use-cases, like manipulating the network stack and accessing devices.\n\nThere should be at least one Security Context Constraint (SCC) defined which does not permit privileged containers.\n\nIf you need to run privileged containers, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods defined with spec.containers[].securityContext.privileged: true will not be permitted.",
        "solution": "Create an SCC that sets allowPrivilegedContainer to false and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default, the following SCCs do not allow users to create privileged containers:\n\n'anyuid'\n\n'hostaccess'\n\n'hostmount-anyuid'\n\n'hostnetwork'\n\n'hostnetwork-v2'\n\n'machine-api-termination-handler'\n\n'nonroot'\n\n'nonroot-v2'\n\n'restricted'\n\n'restricted-v2'",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-171|3.1.14,800-53|AC-6(2),800-53|AC-6(5),800-53|AC-17(3),800-53|SI-7,800-53r5|AC-6(2),800-53r5|AC-6(5),800-53r5|AC-17(3),800-53r5|SI-7,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.4(c),CN-L3|8.1.10.6(a),CN-L3|8.1.10.6(i),CSCv7|4.3,CSCv8|5.4,CSCv8|12.8,CSF|PR.AC-3,CSF|PR.AC-4,CSF|PR.DS-6,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(c)(1),HIPAA|164.312(c)(2),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),ITSG-33|AC-17(3),ITSG-33|SI-7,ITSG-33|SI-7a.,LEVEL|1M,NESA|T3.4.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.6,NESA|T5.6.1,NESA|T7.3.2,NESA|T7.3.3,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.5.5,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|2.3,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Allow Privileged Container: \\(.allowPrivilegedContainer)\"",
        "expect": "Allow Privileged Container: false"
    },
    "custom_item_53": {
        "description": "5.2.2 Minimize the admission of containers wishing to share the host process ID namespace",
        "info": "Do not generally permit containers to be run with the hostPID flag set to true.\n\nRationale:\n\nA container running in the host's PID namespace can inspect processes running outside the container. If the container also has access to ptrace capabilities this can be used to escalate privileges outside of the container.\n\nThere should be at least one Security Context Constraint (SCC) defined which does not permit containers to share the host PID namespace.\n\nIf you need to run containers which require hostPID, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods defined with Allow Host PID: true will not be permitted unless they are run under a specific SCC.",
        "solution": "Create an SCC that sets allowHostPID to false and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default, the following SCCs do not allow users to run within the host process namespace:\n\n'anyuid'\n\n'hostmount-anyuid'\n\n'hostnetwork'\n\n'hostnetwork-v2'\n\n'machine-api-termination-handler'\n\n'nonroot'\n\n'nonroot-v2'\n\n'restricted'\n\n'restricted-v2'",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|5.2,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Allow Host PID: \\(.allowHostPID)\"",
        "expect": "Allow Host PID: false"
    },
    "custom_item_54": {
        "description": "5.2.3 Minimize the admission of containers wishing to share the host IPC namespace",
        "info": "Do not generally permit containers to be run with the hostIPC flag set to true.\n\nRationale:\n\nA container running in the host's IPC namespace can use IPC to interact with processes outside the container.\n\nThere should be at least one Security Context Constraint (SCC) defined which does not permit containers to share the host IPC namespace.\n\nIf you have a requirement to containers which require hostIPC, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods defined with Allow Host IPC: true will not be permitted unless they are run under a specific SCC.",
        "solution": "Create an SCC that sets allowHostIPC to false and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default, the following SCCs do not allow users to run within the host IPC namespace:\n\n'anyuid'\n\n'hostmount-anyuid'\n\n'hostnetwork'\n\n'hostnetwork-v2'\n\n'machine-api-termination-handler'\n\n'node-exporter'\n\n'nonroot'\n\n'nonroot-v2'\n\n'restricted'\n\n'restricted-v2'",
        "reference": "800-171|3.13.1,800-53|SC-7(8),800-53r5|SC-7(8),CN-L3|8.1.10.6(j),CSCv7|12.9,CSCv8|13.10,CSF|PR.AC-5,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7(8),LEVEL|1M,NESA|T4.5.4,NIAv2|SU4,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Allow Host IPC: \\(.allowHostIPC)\"",
        "expect": "Allow Host IPC: false"
    },
    "custom_item_55": {
        "description": "5.2.4 Minimize the admission of containers wishing to share the host network namespace",
        "info": "Do not generally permit containers to be run with the hostNetwork flag set to true.\n\nRationale:\n\nA container running in the host's network namespace could access the local loopback device, and could access network traffic to and from other pods.\n\nThere should be at least one Security Context Constraint (SCC) defined which does not permit containers to share the host network namespace.\n\nIf you have need to run containers which require hostNetwork, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods defined with Allow Host Network: true will not be permitted unless they are run under a specific SCC.",
        "solution": "Create an SCC that sets allowHostNetwork to false and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default, the following SCCs do not allow access to the host network:\n\n'anyuid'\n\n'hostmount-anyuid'\n\n'nonroot'\n\n'nonroot-v2'\n\n'restricted'\n\n'restricted-v2'",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|14.1,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Allow Host Network: \\(.allowHostNetwork)\"",
        "expect": "Allow Host Network: false"
    },
    "custom_item_56": {
        "description": "5.2.5 Minimize the admission of containers with allowPrivilegeEscalation",
        "info": "Do not generally permit containers to be run with the allowPrivilegeEscalation flag set to true.\n\nRationale:\n\nA container running with the allowPrivilegeEscalation flag set to true may have processes that can gain more privileges than their parent.\n\nThere should be at least one Security Context Constraint (SCC) defined which does not permit containers to allow privilege escalation. The option exists (and is defaulted to true) to permit setuid binaries to run.\n\nIf you have need to run containers which use setuid binaries or require privilege escalation, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods defined with Allow Privilege Escalation: true will not be permitted unless they are run under a specific SCC.",
        "solution": "Create an SCC that sets allowPrivilegeEscalation to false and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default, the following SCCs do not allow privilege escalation:\n\n'hostnetwork-v2'\n\n'nonroot-v2'\n\n'restricted-v2'",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-171|3.1.14,800-53|AC-6(2),800-53|AC-6(5),800-53|AC-17(3),800-53|SI-7,800-53r5|AC-6(2),800-53r5|AC-6(5),800-53r5|AC-17(3),800-53r5|SI-7,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.4(c),CN-L3|8.1.10.6(a),CN-L3|8.1.10.6(i),CSCv7|4.3,CSCv8|5.4,CSCv8|12.8,CSF|PR.AC-3,CSF|PR.AC-4,CSF|PR.DS-6,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(c)(1),HIPAA|164.312(c)(2),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),ITSG-33|AC-17(3),ITSG-33|SI-7,ITSG-33|SI-7a.,LEVEL|1M,NESA|T3.4.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.6,NESA|T5.6.1,NESA|T7.3.2,NESA|T7.3.3,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.5.5,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|2.3,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Allow Privilege Escalation: \\(.allowPrivilegeEscalation)\"",
        "expect": "Allow Privilege Escalation: false"
    },
    "custom_item_57": {
        "description": "5.2.7 Minimize the admission of containers with the NET_RAW capability",
        "info": "Do not generally permit containers with the potentially dangerous NET_RAW capability.\n\nRationale:\n\nContainers run with a default set of capabilities as assigned by the Container Runtime. By default this can include potentially dangerous capabilities. With Docker as the container runtime the NET_RAW capability is enabled which may be misused by malicious containers.\n\nIdeally, all containers should drop this capability.\n\nThere should be at least one Security Context Constraint (SCC) defined which prevents containers with the NET_RAW capability from launching.\n\nIf you need to run containers with this capability, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods with containers which run with the NET_RAW capability will not be permitted.",
        "solution": "Create an SCC that sets requiredDropCapabilities to include ALL or at least NET_RAW and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default, the following SCCs drop all capabilities:\n\n'hostnetwork-v2'\n\n'nonroot-v2'\n\n'restricted-v2'",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|5.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Required Drop Capabilities: \\(.requiredDropCapabilities)\"",
        "expect": "Required Drop Capabilities:.*\"ALL\""
    },
    "custom_item_58": {
        "description": "5.2.8 Minimize the admission of containers with added capabilities - allowedCapabilities",
        "info": "Do not generally permit containers with capabilities assigned beyond the default set.\n\nRationale:\n\nContainers run with a default set of capabilities as assigned by the Container Runtime. Capabilities outside this set can be added to containers which could expose them to risks of container breakout attacks.\n\nThere should be at least one Security Context Constraint (SCC) defined which prevents containers with capabilities beyond the default set from launching.\n\nIf you need to run containers with additional capabilities, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods with containers which require capabilities outside the default set will not be permitted.",
        "solution": "Utilize the restricted-v2 SCC or create an SCC that sets allowedCapabilities and defaultAddCapabilities to an empty list and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default authenticated users are allowed to use the restricted-v2 SCC, which drops all container capabilities.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|5.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Allowed Capabilities: \\(.allowedCapabilities)\"",
        "expect": "Allowed Capabilities: null"
    },
    "custom_item_59": {
        "description": "5.2.8 Minimize the admission of containers with added capabilities - defaultAddCapabilities",
        "info": "Do not generally permit containers with capabilities assigned beyond the default set.\n\nRationale:\n\nContainers run with a default set of capabilities as assigned by the Container Runtime. Capabilities outside this set can be added to containers which could expose them to risks of container breakout attacks.\n\nThere should be at least one Security Context Constraint (SCC) defined which prevents containers with capabilities beyond the default set from launching.\n\nIf you need to run containers with additional capabilities, this should be defined in a separate SCC and you should carefully check RBAC controls to ensure that only limited service accounts and users are given permission to access that SCC.\n\nImpact:\n\nPods with containers which require capabilities outside the default set will not be permitted.",
        "solution": "Utilize the restricted-v2 SCC or create an SCC that sets allowedCapabilities and defaultAddCapabilities to an empty list and take it into use by assigning it to applicable users and groups.\n\nDefault Value:\n\nBy default authenticated users are allowed to use the restricted-v2 SCC, which drops all container capabilities.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|5.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getSecurityContextConstraints",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid), Default Add Capabilities: \\(.defaultAddCapabilities)\"",
        "expect": "Default Add Capabilities: null"
    },
    "custom_item_60": {
        "description": "5.7.1 Create administrative boundaries between resources using namespaces",
        "info": "Use namespaces to isolate your Kubernetes objects.\n\nRationale:\n\nLimiting the scope of user permissions can reduce the impact of mistakes or malicious activities. A Kubernetes namespace allows you to partition created resources into logically named groups. Resources created in one namespace can be hidden from other namespaces. By default, each resource created by a user in Kubernetes cluster runs in a default namespace, called default. You can create additional namespaces and attach resources and users to them. You can use Kubernetes Authorization plugins to create policies that segregate access to namespace resources between different users.\n\nImpact:\n\nYou need to switch between namespaces for administration.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Follow the documentation and create namespaces for objects in your deployment as you need them.\n\nDefault Value:\n\nBy default, Kubernetes starts with two initial namespaces:\n\ndefault - The default namespace for objects with no other namespace\n\nkube-system - The namespace for objects created by the Kubernetes system\n\nopenshift -\n\nopenshift-* - The namespace for objects created by OpenShift",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.5,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|1M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/14166",
        "request": "getNamespaces",
        "json_transform": ".items[] | .spec.clusterID as $clusterID | .items[] | select(.status.phase == \"Active\") | \"Cluster ID: \\($clusterID), Name: \\(.metadata.name), UID: \\(.metadata.uid)\"",
        "expect": "Name: (assisted-installer|default|kube-node-lease|kube-public|kube-system|openshift|openshift-[a-z-]*),"
    }
}