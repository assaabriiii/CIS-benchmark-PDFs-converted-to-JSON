{
    "custom_item_1": {
        "description": "1.8 Ensure That Separation of Duties Is Enforced While Assigning Service Account Related Roles to Users",
        "info": "It is recommended that the principle of 'Separation of Duties' is enforced while assigning service-account related roles to users.\n\nRationale:\n\nThe built-in/predefined IAM role Service Account admin allows the user/identity to create, delete, and manage service account(s). The built-in/predefined IAM role Service Account User allows the user/identity (with adequate privileges on Compute and App Engine) to assign service account(s) to Apps/Compute Instances.\n\nSeparation of duties is the concept of ensuring that one individual does not have all necessary permissions to be able to complete a malicious action. In Cloud IAM - service accounts, this could be an action such as using a service account to access resources that user should not normally have access to.\n\nSeparation of duties is a business control typically used in larger organizations, meant to help avoid security or privacy incidents and errors. It is considered best practice.\n\nNo user should have Service Account Admin and Service Account User roles assigned at the same time.\n\nImpact:\n\nThe removed role should be assigned to a different user based on business needs.",
        "solution": "From Google Cloud Console\n\nGo to IAM & Admin/IAM using https://console.cloud.google.com/iam-admin/iam.\n\nFor any member having both Service Account Admin and Service account User roles granted/assigned, click the Delete Bin icon to remove either role from the member.\nRemoval of a role should be done based on the business requirements.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listProjectIAM",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value | ( [.bindings[] | select((.role == \"roles/iam.serviceAccountAdmin\") or (.role == \"roles/iam.serviceAccountUser\")).members[] ]) | group_by(.) | map({User: ., Count: length}) | .[] | select(.Count == 2).User | unique as $user | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Service Account Admin and User: \\($user[])\"",
        "regex": "Service Account Admin and User:",
        "not_expect": "Service Account Admin and User: .+"
    },
    "custom_item_2": {
        "description": "Encrypter/Decrypter",
        "request": "listProjectIAM",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value | ( [.bindings[] | select((.role == \"roles/cloudkms.admin\") or (.role == \"roles/cloudkms.cryptoKeyEncrypterDecrypter\")).members[] ]) | group_by(.) | map({User: ., Count: length}) | .[] | select(.Count == 2).User | unique as $user | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Service Account Admin and Cloud KMS CryptoKey Encrypter/Decrypter: \\($user[])\"",
        "regex": "Service Account Admin and Cloud KMS CryptoKey Encrypter/Decrypter:",
        "not_expect": "Service Account Admin and Cloud KMS CryptoKey Encrypter/Decrypter: .+"
    },
    "custom_item_3": {
        "description": "Encrypter",
        "request": "listProjectIAM",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value | ( [.bindings[] | select((.role == \"roles/cloudkms.admin\") or (.role == \"roles/cloudkms.cryptoKeyEncrypter\")).members[] ]) | group_by(.) | map({User: ., Count: length}) | .[] | select(.Count == 2).User | unique as $user | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Service Account Admin and Cloud KMS CryptoKey Encrypter: \\($user[])\"",
        "regex": "Service Account Admin and Cloud KMS CryptoKey Encrypter:",
        "not_expect": "Service Account Admin and Cloud KMS CryptoKey Encrypter: .+"
    },
    "custom_item_4": {
        "description": "Decrypter",
        "request": "listProjectIAM",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value | ( [.bindings[] | select((.role == \"roles/cloudkms.admin\") or (.role == \"roles/cloudkms.cryptoKeyDecrypter\")).members[] ]) | group_by(.) | map({User: ., Count: length}) | .[] | select(.Count == 2).User | unique as $user | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Service Account Admin and Cloud KMS CryptoKey Decrypter: \\($user[])\"",
        "regex": "Service Account Admin and Cloud KMS CryptoKey Decrypter:",
        "not_expect": "Service Account Admin and Cloud KMS CryptoKey Decrypter: .+"
    },
    "custom_item_5": {
        "description": "1.12 Ensure API Keys Only Exist for Active Services",
        "info": "API Keys should only be used for services in cases where other authentication methods are unavailable. Unused keys with their permissions in tact may still exist within a project. Keys are insecure because they can be viewed publicly, such as from within a browser, or they can be accessed on a device where the key resides. It is recommended to use standard authentication flow instead.\n\nRationale:\n\nTo avoid the security risk in using API keys, it is recommended to use standard authentication flow instead. Security risks involved in using API-Keys appear below:\n\nAPI keys are simple encrypted strings\n\nAPI keys do not identify the user or the application making the API request\n\nAPI keys are typically accessible to clients, making it easy to discover and steal an API key\n\nImpact:\n\nDeleting an API key will break dependent applications (if any).",
        "solution": "From Console:\n\nGo to APIs & Services\\Credentials using\n\nIn the section API Keys, to delete API Keys: Click the Delete Bin Icon in front of every API Key Name.\n\nFrom Google Cloud Command Line\n\nRun the following from within the project you wish to audit gcloud services api-keys list --filter\n\n**Pipe the results into **\ngcloud alpha services api-keys delete\n\nDefault Value:\n\nBy default, API keys are not created for a project.",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|PL-8,800-53|SA-8,800-53r5|PL-8,800-53r5|SA-8,CSCv7|16.8,CSCv8|16.10,CSF|ID.AM-3,CSF|PR.IP-2,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|2A,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2,QCSC-v1|4.2,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listServicesApiKeys",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.keys[] | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Name: \\(.name), Display Name: \\(.displayName), Create Time: \\(.createTime)\"",
        "regex": "Name:",
        "not_expect": "Name:"
    },
    "custom_item_6": {
        "description": "1.14 Ensure API Keys Are Restricted to Only APIs That Application Needs Access",
        "info": "API Keys should only be used for services in cases where other authentication methods are unavailable. API keys are always at risk because they can be viewed publicly, such as from within a browser, or they can be accessed on a device where the key resides. It is recommended to restrict API keys to use (call) only APIs required by an application.\n\nRationale:\n\nSecurity risks involved in using API-Keys are below:\n\nAPI keys are simple encrypted strings\n\nAPI keys do not identify the user or the application making the API request\n\nAPI keys are typically accessible to clients, making it easy to discover and steal an API key\n\nIn light of these potential risks, Google recommends using the standard authentication flow instead of API-Keys. However, there are limited cases where API keys are more appropriate. For example, if there is a mobile application that needs to use the Google Cloud Translation API, but doesn't otherwise need a backend server, API keys are the simplest way to authenticate to that API.\n\nIn order to reduce attack surfaces by providing least privileges, API-Keys can be restricted to use (call) only APIs required by an application.\n\nImpact:\n\nSetting API restrictions may break existing application functioning, if not done carefully.",
        "solution": "From Console:\n\nGo to APIs & Services\\Credentials using https://console.cloud.google.com/apis/credentials\n\nIn the section API Keys, Click the API Key Name. The API Key properties display on a new page.\n\nIn the Key restrictions section go to API restrictions.\n\nClick the Select API drop-down to choose an API.\n\nClick Save.\n\nRepeat steps 2,3,4,5 for every unrestricted API key\n\nNote: Do not set API restrictions to Google Cloud APIs, as this option allows access to all services offered by Google cloud.\nFrom Google Cloud CLI\n\nList all API keys.\n\ngcloud services api-keys list\n\nNote the UID of the key to add restrictions to.\n\nRun the update command with the appropriate flags to add the required restrictions.\n\ngcloud alpha services api-keys updateNote- Flags can be found by running\n\ngcloud alpha services api-keys update --help\n\nor in this documentation\nhttps://cloud.google.com/sdk/gcloud/reference/alpha/services/api-keys/update\n\nDefault Value:\n\nBy default, API restrictions are set to None.",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|PL-8,800-53|SA-8,800-53r5|PL-8,800-53r5|SA-8,CSCv8|16.10,CSF|ID.AM-3,CSF|PR.IP-2,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|2A,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2,QCSC-v1|4.2,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listServicesApiKeys",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.keys[] | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Name: \\(.name), Display Name: \\(.displayName), Restrictions: \\(.restrictions)\"",
        "regex": "Restrictions:",
        "not_expect": "Restrictions: (null|.*\"cloudapis.googleapis.com\")"
    },
    "custom_item_7": {
        "description": "1.15 Ensure API Keys Are Rotated Every 90 Days",
        "info": "API Keys should only be used for services in cases where other authentication methods are unavailable. If they are in use it is recommended to rotate API keys every 90 days.\n\nRationale:\n\nSecurity risks involved in using API-Keys are listed below:\n\nAPI keys are simple encrypted strings\n\nAPI keys do not identify the user or the application making the API request\n\nAPI keys are typically accessible to clients, making it easy to discover and steal an API key\n\nBecause of these potential risks, Google recommends using the standard authentication flow instead of API Keys. However, there are limited cases where API keys are more appropriate. For example, if there is a mobile application that needs to use the Google Cloud Translation API, but doesn't otherwise need a backend server, API keys are the simplest way to authenticate to that API.\n\nOnce a key is stolen, it has no expiration, meaning it may be used indefinitely unless the project owner revokes or regenerates the key. Rotating API keys will reduce the window of opportunity for an access key that is associated with a compromised or terminated account to be used.\n\nAPI keys should be rotated to ensure that data cannot be accessed with an old key that might have been lost, cracked, or stolen.\n\nImpact:\n\nRegenerating Key may break existing client connectivity as the client will try to connect with older API keys they have stored on devices.",
        "solution": "From Google Cloud Console\n\nGo to APIs & Services\\Credentials using https://console.cloud.google.com/apis/credentials\n\nIn the section API Keys, Click the API Key Name. The API Key properties display on a new page.\n\nClick REGENERATE KEY to rotate API key.\n\nClick Save.\n\nRepeat steps 2,3,4 for every API key that has not been rotated in the last 90 days.\n\nNote: Do not set HTTP referrers to wild-cards (* or *.[TLD] or .[TLD]/) allowing access to any/wide HTTP referrer(s)\nDo not set IP addresses and referrer to any host (0.0.0.0 or 0.0.0.0/0 or ::0)\nFrom Google Cloud CLI\nThere is not currently a way to regenerate and API key using gcloud commands. To 'regenerate' a key you will need to create a new one, duplicate the restrictions from the key being rotated, and delete the old key.\n\nList existing keys.\n\ngcloud services api-keys list\n\nNote the UID and restrictions of the key to regenerate.\n\nRun this command to create a new API key.is the display name of the new key.\n\ngcloud alpha services api-keys create --display-name=''\n\nNote the UID of the newly created key\n\nRun the update command to add required restrictions.\n\nNote - the restriction may vary for each key. Refer to this documentation for the appropriate flags.\nhttps://cloud.google.com/sdk/gcloud/reference/alpha/services/api-keys/update\n\ngcloud alpha services api-keys updateDelete the old key.\n\ngcloud alpha services api-keys delete",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|PL-8,800-53|SA-8,800-53r5|PL-8,800-53r5|SA-8,CSCv8|16.10,CSF|ID.AM-3,CSF|PR.IP-2,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|2A,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2,QCSC-v1|4.2,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listServicesApiKeys",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.keys[] | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Name: \\(.name), Display Name: \\(.displayName), Create Time: \\(.createTime) (\\(.createTime | iso_8601_days_ago) days ago)\"",
        "regex": "Create Time:",
        "expect": "Create Time:.*\\([1-8]*[0-9] days ago\\)"
    },
    "custom_item_8": {
        "description": "8.1 Ensure that Dataproc Cluster is encrypted using Customer-Managed Encryption Key",
        "info": "When you use Dataproc, cluster and job data is stored on Persistent Disks (PDs) associated with the Compute Engine VMs in your cluster and in a Cloud Storage staging bucket. This PD and bucket data is encrypted using a Google-generated data encryption key (DEK) and key encryption key (KEK). The CMEK feature allows you to create, use, and revoke the key encryption key (KEK). Google still controls the data encryption key (DEK).\n\nRationale:\n\n'Cloud services offer the ability to protect data related to those services using encryption keys managed by the customer within Cloud KMS. These encryption keys are called customer-managed encryption keys (CMEK). When you protect data in Google Cloud services with CMEK, the CMEK key is within your control.\n\nImpact:\n\nUsing Customer Managed Keys involves additional overhead in maintenance by administrators.",
        "solution": "From Google Cloud Console\n\nLogin to the GCP Console and navigate to the Dataproc Cluster page by visiting https://console.cloud.google.com/dataproc/clusters.\n\nSelect the project from the projects dropdown list.\n\nOn the Dataproc Cluster page, click on the Create Cluster to create a new cluster with Customer managed encryption keys.\n\nOn Create a cluster page, perform below steps:\n\nInside Set up cluster section perform below steps:\n-In the Name textbox, provide a name for your cluster.\n\nFrom Location select the location in which you want to deploy a cluster.\n\nConfigure other configurations as per your requirements.\n\nInside Configure Nodes and Customize cluster section configure the settings as per your requirements.\n\nInside Manage security section, perform below steps:\n\nFrom Encryption, select Customer-managed key.\n\nSelect a customer-managed key from dropdown list.\n\nEnsure that the selected KMS Key have Cloud KMS CryptoKey Encrypter/Decrypter role assign to Dataproc Cluster service account ('serviceAccount:service-@compute-system.iam.gserviceaccount.com').\n\nClick on Create to create a cluster.\n\nOnce the cluster is created migrate all your workloads from the older cluster to the new cluster and delete the old cluster by performing the below steps:\n\nOn the Clusters page, select the old cluster and click on Delete cluster.\n\nOn the Confirm deletion window, click on Confirm to delete the cluster.\n\nRepeat step above for other Dataproc clusters available in the selected project.\n\nChange the project from the project dropdown list and repeat the remediation procedure for other Dataproc clusters available in other projects.\n\nFrom Google Cloud CLI\nBefore creating cluster ensure that the selected KMS Key have Cloud KMS CryptoKey Encrypter/Decrypter role assign to Dataproc Cluster service account ('serviceAccount:service-@compute-system.iam.gserviceaccount.com').\nRun clusters create command to create new cluster with customer-managed key:\n\ngcloud dataproc clusters create--region=us-central1 --gce-pd-kms-key=The above command will create a new cluster in the selected region.\nOnce the cluster is created migrate all your workloads from the older cluster to the new cluster and Run clusters delete command to delete cluster:\n\ngcloud dataproc clusters delete--region=us-central1\n\nRepeat step no. 1 to create a new Dataproc cluster.\nChange the project by running the below command and repeat the remediation procedure for other projects:\n\ngcloud config set project'",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|2A,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listDataprocs",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.items[] | .name as $regionName | .value.clusters[] | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Region Name: \\($regionName), Cluster Name: \\(.clusterName), Cluster UUID: \\(.clusterUuid), Kms Key Name: \\(.config.encryptionConfig.gcePdKmsKeyName)\"",
        "regex": "Kms Key Name",
        "not_expect": "Kms Key Name: null"
    },
    "custom_item_9": {
        "description": "2.3 Ensure That Retention Policies on Cloud Storage Buckets Used for Exporting Logs Are Configured Using Bucket Lock",
        "info": "Enabling retention policies on log buckets will protect logs stored in cloud storage buckets from being overwritten or accidentally deleted. It is recommended to set up retention policies and configure Bucket Lock on all storage buckets that are used as log sinks.\n\nRationale:\n\nLogs can be exported by creating one or more sinks that include a log filter and a destination. As Cloud Logging receives new log entries, they are compared against each sink. If a log entry matches a sink's filter, then a copy of the log entry is written to the destination.\n\nSinks can be configured to export logs in storage buckets. It is recommended to configure a data retention policy for these cloud storage buckets and to lock the data retention policy; thus permanently preventing the policy from being reduced or removed. This way, if the system is ever compromised by an attacker or a malicious insider who wants to cover their tracks, the activity logs are definitely preserved for forensics and security investigations.\n\nImpact:\n\nLocking a bucket is an irreversible action. Once you lock a bucket, you cannot remove the retention policy from the bucket or decrease the retention period for the policy. You will then have to wait for the retention period for all items within the bucket before you can delete them, and then the bucket.",
        "solution": "From Google Cloud Console\n\nIf sinks are not configured, first follow the instructions in the recommendation: Ensure that sinks are configured for all Log entries.\n\nFor each storage bucket configured as a sink, go to the Cloud Storage browser at https://console.cloud.google.com/storage/browser/.\n\nSelect the Bucket Lock tab near the top of the page.\n\nIn the Retention policy entry, click the Add Duration link. The Set a retention policy dialog box appears.\n\nEnter the desired length of time for the retention period and click Save policy.\n\nSet the Lock status for this retention policy to Locked.\n\nFrom Google Cloud CLI\n\nTo list all sinks destined to storage buckets:\n\ngcloud logging sinks list --folder=FOLDER_ID | --organization=ORGANIZATION_ID | --project=PROJECT_ID\n\nFor each storage bucket listed above, set a retention policy and lock it:\n\ngsutil retention set [TIME_DURATION] gs://[BUCKET_NAME]\ngsutil retention lock gs://[BUCKET_NAME]\n\nFor more information, visit https://cloud.google.com/storage/docs/using-bucket-lock#set-policy.\n\nDefault Value:\n\nBy default, storage buckets used as log sinks do not have retention policies and Bucket Lock configured.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listLoggingSinkBucketRetention",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.sinks[] | .name as $sink | select(.value.name != null) | .value | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Bucket: \\(.name), Retention Lock: \\(.retentionPolicy.isLocked), Retention Period: \\(.retentionPolicy.retentionPeriod)\"",
        "regex": "Retention Lock:",
        "expect": "Retention Lock: true, Retention Period: [1-9]"
    },
    "custom_item_10": {
        "description": "metric",
        "request": "listLoggingMetrics",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Metrics: \\([.value.metrics[] | {name, filter}])\"",
        "expect": "\"filter\":\"resource\\.type[\\s]*=[\\s]*\\\\\"gce_firewall_rule\\\\\".*AND.*protoPayload\\.methodName:\\\\\"compute\\.firewalls\\.patch\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.firewalls\\.insert\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.firewalls\\.delete\\\\\"[\\s]*\\).*\""
    },
    "custom_item_11": {
        "description": "alert",
        "request": "listAlertPolicies",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Alert Policies: \\([.value.alertPolicies[] | select(.enabled == true) | .conditions[] | {name, \"filter\": .conditionThreshold.filter}])\"",
        "expect": "\"filter\":\"metric\\.type=\\\\\"logging\\.googleapis\\.com/user/"
    },
    "custom_item_12": {
        "description": "metric",
        "request": "listLoggingMetrics",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Metrics: \\([.value.metrics[] | {name, filter}])\"",
        "expect": "\"filter\":\"resource\\.type=\\\\\"gce_route\\\\\".*AND.*\\([\\s]*protoPayload\\.methodName:\\\\\"compute\\.routes\\.delete\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.routes\\.insert\\\\\"[\\s]*\\).*\""
    },
    "custom_item_13": {
        "description": "alert",
        "request": "listAlertPolicies",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Alert Policies: \\([.value.alertPolicies[] | select(.enabled == true) | .conditions[] | {name, \"filter\": .conditionThreshold.filter}])\"",
        "expect": "\"filter\":\"metric\\.type=\\\\\"logging\\.googleapis\\.com/user/"
    },
    "custom_item_14": {
        "description": "metric",
        "request": "listLoggingMetrics",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Metrics: \\([.value.metrics[] | {name, filter}])\"",
        "expect": "\"filter\":\"resource\\.type=\\\\\"gce_network\\\\\".*AND.*\\([\\s]*protoPayload\\.methodName:\\\\\"compute\\.networks\\.insert\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.networks\\.patch\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.networks\\.delete\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.networks\\.removePeering\\\\\".*OR.*protoPayload\\.methodName:\\\\\"compute\\.networks\\.addPeering\\\\\"[\\s]*\\).*\""
    },
    "custom_item_15": {
        "description": "alert",
        "request": "listAlertPolicies",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Alert Policies: \\([.value.alertPolicies[] | select(.enabled == true) | .conditions[] | {name, \"filter\": .conditionThreshold.filter}])\"",
        "expect": "\"filter\":\"metric\\.type=\\\\\"logging\\.googleapis\\.com/user/"
    },
    "custom_item_16": {
        "description": "metric",
        "request": "listLoggingMetrics",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Metrics: \\([.value.metrics[] | {name, filter}])\"",
        "expect": "\"filter\":\"resource\\.type[\\s]*=[\\s]*\\\\\"gcs_bucket\\\\\".*AND.*protoPayload\\.methodName[\\s]*=[\\s]*\\\\\"storage\\.setIamPermissions\\\\\"\""
    },
    "custom_item_17": {
        "description": "alert",
        "request": "listAlertPolicies",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Alert Policies: \\([.value.alertPolicies[] | select(.enabled == true) | .conditions[] | {name, \"filter\": .conditionThreshold.filter}])\"",
        "expect": "\"filter\":\"metric\\.type=\\\\\"logging\\.googleapis\\.com/user/"
    },
    "custom_item_18": {
        "description": "metric",
        "request": "listLoggingMetrics",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Metrics: \\([.value.metrics[] | {name, filter}])\"",
        "expect": "\"filter\":\"protoPayload\\.methodName[\\s]*=[\\s]*\\\\\"cloudsql\\.instances\\.update\\\\\"\""
    },
    "custom_item_19": {
        "description": "alert",
        "request": "listAlertPolicies",
        "json_transform": ".projects[] | \"Project Number: \\(.projectNumber), Project ID: \\(.projectId), Alert Policies: \\([.value.alertPolicies[] | select(.enabled == true) | .conditions[] | {name, \"filter\": .conditionThreshold.filter}])\"",
        "expect": "\"filter\":\"metric\\.type=\\\\\"logging\\.googleapis\\.com/user/"
    },
    "custom_item_20": {
        "description": "2.16 Ensure Logging is enabled for HTTP(S) Load Balancer",
        "info": "Logging enabled on a HTTPS Load Balancer will show all network traffic and its destination.\n\nRationale:\n\nLogging will allow you to view HTTPS network traffic to your web applications.\n\nImpact:\n\nOn high use systems with a high percentage sample rate, the logging file may grow to high capacity in a short amount of time. Ensure that the sample rate is set appropriately so that storage costs are not exorbitant.",
        "solution": "From Google Cloud Console\n\nFrom Google Cloud home open the Navigation Menu in the top left.\n\nUnder the Networking heading select Network services.\n\nSelect the HTTPS load-balancer you wish to audit.\n\nSelect Edit then Backend Configuration.\n\nSelect Edit on the corresponding backend service.\n\nClick Enable Logging.\n\nSet Sample Rate to a desired value. This is a percentage as a decimal point. 1.0 is 100%.\n\nFrom Google Cloud CLI\n\nRun the following command\n\ngcloud compute backend-services update--region=REGION --enable-logging --logging-sample-rate=Default Value:\n\nBy default logging for https load balancing is disabled. When logging is enabled it sets the default sample rate as 1.0 or 100%. Ensure this value fits the need of your organization to avoid high storage costs.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listBackendServices",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.items | keys[] as $k | .[$k].backendServices[] | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Backend Service: \\(.selfLink), Logging Enabled: \\(.logConfig.enable), Sample Rate: \\(.logConfig.sampleRate)\"",
        "regex": "Logging Enabled:",
        "expect": "Logging Enabled: true, Sample Rate: @SAMPLE_RATE@"
    },
    "custom_item_21": {
        "description": "3.1 Ensure That the Default Network Does Not Exist in a Project",
        "info": "To prevent use of default network, a project should not have a default network.\n\nRationale:\n\nThe default network has a preconfigured network configuration and automatically generates the following insecure firewall rules:\n\ndefault-allow-internal: Allows ingress connections for all protocols and ports among instances in the network.\n\ndefault-allow-ssh: Allows ingress connections on TCP port 22(SSH) from any source to any instance in the network.\n\ndefault-allow-rdp: Allows ingress connections on TCP port 3389(RDP) from any source to any instance in the network.\n\ndefault-allow-icmp: Allows ingress ICMP traffic from any source to any instance in the network.\n\nThese automatically created firewall rules do not get audit logged by default.\n\nFurthermore, the default network is an auto mode network, which means that its subnets use the same predefined range of IP addresses, and as a result, it's not possible to use Cloud VPN or VPC Network Peering with the default network.\n\nBased on organization security and networking requirements, the organization should create a new network and delete the default network.\n\nImpact:\n\nWhen an organization deletes the default network, it will need to remove all asests from that network and migrate them to a new network.",
        "solution": "From Google Cloud Console\n\nGo to the VPC networks page by visiting: https://console.cloud.google.com/networking/networks/list.\n\nClick the network named default.\n\nOn the network detail page, click EDIT.\n\nClick DELETE VPC NETWORK.\n\nIf needed, create a new network to replace the default network.\n\nFrom Google Cloud CLI\nFor each Google Cloud Platform project,\n\nDelete the default network:\n\ngcloud compute networks delete default\n\nIf needed, create a new network to replace it:\n\ngcloud compute networks create NETWORK_NAME\n\nPrevention:\nThe user can prevent the default network and its insecure default firewall rules from being created by setting up an Organization Policy to Skip default network creation at https://console.cloud.google.com/iam-admin/orgpolicies/compute-skipDefaultNetworkCreation.\n\nDefault Value:\n\nBy default, for each project, a default network is created.",
        "reference": "800-171|3.1.16,800-171|3.1.17,800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|AC-18,800-53|AC-18(1),800-53|AC-18(3),800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53r5|AC-18,800-53r5|AC-18(1),800-53r5|AC-18(3),800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,CSCv7|11.1,CSCv8|4.2,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.PT-3,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ITSG-33|AC-18,ITSG-33|AC-18(1),ITSG-33|AC-18(3),ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,LEVEL|2A,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T5.4.2,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NIAv2|NS33,NIAv2|NS34,NIAv2|NS38,NIAv2|SS15a,NIAv2|SS16,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeNetworks",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | [(.value.items[] | {\"name\": .name})] as $networks | [(.value.items[] | select(.name == \"default\") | {\"name\": .name})] as $default | if ($default | length) > 0 then \"Project Number: \\($projectNumber), Project ID: \\($projectId), Default Network: YES - \\($networks)\" else \"Project Number: \\($projectNumber), Project ID: \\($projectId), Default Network: NO \\($networks)\" end",
        "regex": "Default Network:",
        "expect": "Default Network: NO"
    },
    "custom_item_22": {
        "description": "3.6 Ensure That SSH Access Is Restricted From the Internet",
        "info": "GCP Firewall Rules are specific to a VPC Network. Each rule either allows or denies traffic when its conditions are met. Its conditions allow the user to specify the type of traffic, such as ports and protocols, and the source or destination of the traffic, including IP addresses, subnets, and instances.\n\nFirewall rules are defined at the VPC network level and are specific to the network in which they are defined. The rules themselves cannot be shared among networks. Firewall rules only support IPv4 traffic. When specifying a source for an ingress rule or a destination for an egress rule by address, only an IPv4 address or IPv4 block in CIDR notation can be used. Generic (0.0.0.0/0) incoming traffic from the internet to VPC or VM instance using SSH on Port 22 can be avoided.\n\nRationale:\n\nGCP Firewall Rules within a VPC Network apply to outgoing (egress) traffic from instances and incoming (ingress) traffic to instances in the network. Egress and ingress traffic flows are controlled even if the traffic stays within the network (for example, instance-to-instance communication). For an instance to have outgoing Internet access, the network must have a valid Internet gateway route or custom route whose destination IP is specified. This route simply defines the path to the Internet, to avoid the most general (0.0.0.0/0) destination IP Range specified from the Internet through SSH with the default Port 22. Generic access from the Internet to a specific IP Range needs to be restricted.\n\nImpact:\n\nAll Secure Shell (SSH) connections from outside of the network to the concerned VPC(s) will be blocked. There could be a business need where SSH access is required from outside of the network to access resources associated with the VPC. In that case, specific source IP(s) should be mentioned in firewall rules to white-list access to SSH port for the concerned VPC(s).",
        "solution": "From Google Cloud Console\n\nGo to VPC Network.\n\nGo to the Firewall Rules.\n\nClick the Firewall Rule you want to modify.\n\nClick Edit.\n\nModify Source IP ranges to specific IP.\n\nClick Save.\n\nFrom Google Cloud CLI\n1.Update the Firewall rule with the new SOURCE_RANGE from the below command:\n\ngcloud compute firewall-rules update FirewallName --allow=[PROTOCOL[:PORT[-PORT]],...] --source-ranges=[CIDR_RANGE,...]",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.2,CSCv7|12.4,CSCv8|4.4,CSCv8|4.5,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeFirewallRules",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.items[] | .selfLink as $selfLink | select(.direction == \"INGRESS\") | select(.sourceRanges[] == \"0.0.0.0/0\") | .sourceRanges as $sourceRanges | .allowed[] | .IPProtocol as $ipProtocol | .ports[] as $ports | \"Rule: \\($selfLink), IP Protocol: \\($ipProtocol), Ports: \\($ports)\"",
        "regex": "IP Protocol: (tcp|null)",
        "not_expect": "Ports: (null|([0-9]|1[0-9]|2[0-2])-(2[2-9]|[3-9][0-9]|[1-9][0-9]{2,})|22$)"
    },
    "custom_item_23": {
        "description": "3.7 Ensure That RDP Access Is Restricted From the Internet",
        "info": "GCP Firewall Rules are specific to a VPC Network. Each rule either allows or denies traffic when its conditions are met. Its conditions allow users to specify the type of traffic, such as ports and protocols, and the source or destination of the traffic, including IP addresses, subnets, and instances.\n\nFirewall rules are defined at the VPC network level and are specific to the network in which they are defined. The rules themselves cannot be shared among networks. Firewall rules only support IPv4 traffic. When specifying a source for an ingress rule or a destination for an egress rule by address, an IPv4 address or IPv4 block in CIDR notation can be used. Generic (0.0.0.0/0) incoming traffic from the Internet to a VPC or VM instance using RDP on Port 3389 can be avoided.\n\nRationale:\n\nGCP Firewall Rules within a VPC Network. These rules apply to outgoing (egress) traffic from instances and incoming (ingress) traffic to instances in the network. Egress and ingress traffic flows are controlled even if the traffic stays within the network (for example, instance-to-instance communication). For an instance to have outgoing Internet access, the network must have a valid Internet gateway route or custom route whose destination IP is specified. This route simply defines the path to the Internet, to avoid the most general (0.0.0.0/0) destination IP Range specified from the Internet through RDP with the default Port 3389. Generic access from the Internet to a specific IP Range should be restricted.\n\nImpact:\n\nAll Remote Desktop Protocol (RDP) connections from outside of the network to the concerned VPC(s) will be blocked. There could be a business need where secure shell access is required from outside of the network to access resources associated with the VPC. In that case, specific source IP(s) should be mentioned in firewall rules to white-list access to RDP port for the concerned VPC(s).",
        "solution": "From Google Cloud Console\n\nGo to VPC Network.\n\nGo to the Firewall Rules.\n\nClick the Firewall Rule to be modified.\n\nClick Edit.\n\nModify Source IP ranges to specific IP.\n\nClick Save.\n\nFrom Google Cloud CLI\n1.Update RDP Firewall rule with new SOURCE_RANGE from the below command:\n\ngcloud compute firewall-rules update FirewallName --allow=[PROTOCOL[:PORT[-PORT]],...] --source-ranges=[CIDR_RANGE,...]",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.2,CSCv7|12.4,CSCv8|4.4,CSCv8|4.5,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeFirewallRules",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.items[] | .selfLink as $selfLink | select(.direction == \"INGRESS\") | select(.sourceRanges[] == \"0.0.0.0/0\") | .sourceRanges as $sourceRanges | .allowed[] | .IPProtocol as $ipProtocol | .ports[] as $ports | \"Rule: \\($selfLink), IP Protocol: \\($ipProtocol), Ports: \\($ports)\"",
        "regex": "IP Protocol: (tcp|null)",
        "not_expect": "Ports: (null|([0-9]|[1-2][0-9]{1,3}|3[0-2][0-9]{2,}|33[0-8][0-9])-(3389|339[0-9]|3[4-9][0-9]{2,}|[4-9][0-9]{3,}|[1-9][0-9]{4,})|3389$)"
    },
    "custom_item_24": {
        "description": "3.8 Ensure that VPC Flow Logs is Enabled for Every Subnet in a VPC Network",
        "info": "Flow Logs is a feature that enables users to capture information about the IP traffic going to and from network interfaces in the organization's VPC Subnets. Once a flow log is created, the user can view and retrieve its data in Stackdriver Logging. It is recommended that Flow Logs be enabled for every business-critical VPC subnet.\n\nRationale:\n\nVPC networks and subnetworks not reserved for internal HTTP(S) load balancing provide logically isolated and secure network partitions where GCP resources can be launched. When Flow Logs are enabled for a subnet, VMs within that subnet start reporting on all Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) flows. Each VM samples the TCP and UDP flows it sees, inbound and outbound, whether the flow is to or from another VM, a host in the on-premises datacenter, a Google service, or a host on the Internet. If two GCP VMs are communicating, and both are in subnets that have VPC Flow Logs enabled, both VMs report the flows.\n\nFlow Logs supports the following use cases:\n\nNetwork monitoring\n\nUnderstanding network usage and optimizing network traffic expenses\n\nNetwork forensics\n\nReal-time security analysis\n\nFlow Logs provide visibility into network traffic for each VM inside the subnet and can be used to detect anomalous traffic or provide insight during security workflows.\n\nThe Flow Logs must be configured such that all network traffic is logged, the interval of logging is granular to provide detailed information on the connections, no logs are filtered, and metadata to facilitate investigations are included.\n\nNote: Subnets reserved for use by internal HTTP(S) load balancers do not support VPC flow logs.\n\nImpact:\n\nStandard pricing for Stackdriver Logging, BigQuery, or Cloud Pub/Sub applies. VPC Flow Logs generation will be charged starting in GA as described in reference: https://cloud.google.com/vpc/",
        "solution": "From Google Cloud Console\n\nGo to the VPC network GCP Console visiting https://console.cloud.google.com/networking/networks/list\n\nClick the name of a subnet, The Subnet details page displays.\n\nClick the EDIT button.\n\nSet Flow Logs to On.\n\nExpand the Configure Logs section.\n\nSet Aggregation Interval to 5 SEC.\n\nCheck the box beside Include metadata.\n\nSet Sample rate to 100.\n\nClick Save.\n\nNote: It is not possible to configure a Log filter from the console.\nFrom Google Cloud CLI\nTo enable VPC Flow Logs for a network subnet, run the following command:\n\ngcloud compute networks subnets update [SUBNET_NAME] --region [REGION] --enable-flow-logs --logging-aggregation-interval=interval-5-sec --logging-flow-sampling=1 --logging-metadata=include-all\n\nDefault Value:\n\nBy default, Flow Logs is set to Off when a new VPC network subnet is created.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-171|3.14.6,800-171|3.14.7,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53|SI-4,800-53|SI-4(4),800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,800-53r5|SI-4,800-53r5|SI-4(4),CN-L3|7.1.2.2(c),CN-L3|7.1.2.3(c),CN-L3|7.1.3.5(a),CN-L3|8.1.4.3(a),CN-L3|8.1.10.5(b),CN-L3|8.1.10.6(f),CSCv7|6.2,CSCv7|12.8,CSCv8|8.2,CSCv8|13.6,CSF|DE.AE-1,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.AE-4,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-5,CSF|DE.CM-6,CSF|DE.CM-7,CSF|DE.DP-2,CSF|DE.DP-3,CSF|DE.DP-4,CSF|DE.DP-5,CSF|ID.RA-1,CSF|PR.DS-5,CSF|PR.IP-8,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.AN-3,CSF|RS.CO-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,ITSG-33|SI-4,ITSG-33|SI-4(4),LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|NS32,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4,SWIFT-CSCv1|6.5",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeSubnetworks",
        "json_transform": ".projects[].value.items[].subnetworks[] | \"Subnet: \\(.selfLink), Enable Flow Logs: \\(.enableFlowLogs), Aggregation Interval: \\(.logConfig.aggregationInterval), Include Metadata: \\(.logConfig.metadata), Sample Rate: \\(.logConfig.flowSampling)\"",
        "regex": "Enable Flow Logs:",
        "expect": "Enable Flow Logs: true, Aggregation Interval: INTERVAL_5_SEC, Include Metadata: INCLUDE_ALL_METADATA, Sample Rate: 1"
    },
    "custom_item_25": {
        "description": "4.7 Ensure VM Disks for Critical VMs Are Encrypted With Customer-Supplied Encryption Keys (CSEK)",
        "info": "Customer-Supplied Encryption Keys (CSEK) are a feature in Google Cloud Storage and Google Compute Engine. If you supply your own encryption keys, Google uses your key to protect the Google-generated keys used to encrypt and decrypt your data. By default, Google Compute Engine encrypts all data at rest. Compute Engine handles and manages this encryption for you without any additional actions on your part. However, if you wanted to control and manage this encryption yourself, you can provide your own encryption keys.\n\nRationale:\n\nBy default, Google Compute Engine encrypts all data at rest. Compute Engine handles and manages this encryption for you without any additional actions on your part. However, if you wanted to control and manage this encryption yourself, you can provide your own encryption keys.\n\nIf you provide your own encryption keys, Compute Engine uses your key to protect the Google-generated keys used to encrypt and decrypt your data. Only users who can provide the correct key can use resources protected by a customer-supplied encryption key.\n\nGoogle does not store your keys on its servers and cannot access your protected data unless you provide the key. This also means that if you forget or lose your key, there is no way for Google to recover the key or to recover any data encrypted with the lost key.\n\nAt least business critical VMs should have VM disks encrypted with CSEK.\n\nImpact:\n\nIf you lose your encryption key, you will not be able to recover the data.",
        "solution": "Currently there is no way to update the encryption of an existing disk. Therefore you should create a new disk with Encryption set to Customer supplied.\nFrom Google Cloud Console\n\nGo to Compute Engine Disks by visiting: https://console.cloud.google.com/compute/disks.\n\nClick CREATE DISK.\n\nSet Encryption type to Customer supplied,\n\nProvide the Key in the box.\n\nSelect Wrapped key.\n\nClick Create.\n\nFrom Google Cloud CLI\nIn the gcloud compute tool, encrypt a disk using the --csek-key-file flag during instance creation. If you are using an RSA-wrapped key, use the gcloud beta component:\n\ngcloud compute instances create--csek-key-fileTo encrypt a standalone persistent disk:\n\ngcloud compute disks create--csek-key-fileDefault Value:\n\nBy default, VM disks are encrypted with Google-managed keys. They are not encrypted with Customer-Supplied Encryption Keys.",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|2A,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeDisks",
        "json_transform": ".projects[] | select(.value.items | length > 0) | .value.items[] | select(.disks | length > 0) | .disks[] | \"Disk: \\(.selfLink), Disk Encryption Key: \\(.diskEncryptionKey)\"",
        "regex": "Disk Encryption Key:",
        "not_expect": "Disk Encryption Key: null"
    },
    "custom_item_26": {
        "description": "4.8 Ensure Compute Instances Are Launched With Shielded VM Enabled",
        "info": "To defend against advanced threats and ensure that the boot loader and firmware on your VMs are signed and untampered, it is recommended that Compute instances are launched with Shielded VM enabled.\n\nRationale:\n\nShielded VMs are virtual machines (VMs) on Google Cloud Platform hardened by a set of security controls that help defend against rootkits and bootkits.\n\nShielded VM offers verifiable integrity of your Compute Engine VM instances, so you can be confident your instances haven't been compromised by boot- or kernel-level malware or rootkits. Shielded VM's verifiable integrity is achieved through the use of Secure Boot, virtual trusted platform module (vTPM)-enabled Measured Boot, and integrity monitoring.\n\nShielded VM instances run firmware which is signed and verified using Google's Certificate Authority, ensuring that the instance's firmware is unmodified and establishing the root of trust for Secure Boot.\n\nIntegrity monitoring helps you understand and make decisions about the state of your VM instances and the Shielded VM vTPM enables Measured Boot by performing the measurements needed to create a known good boot baseline, called the integrity policy baseline. The integrity policy baseline is used for comparison with measurements from subsequent VM boots to determine if anything has changed.\n\nSecure Boot helps ensure that the system only runs authentic software by verifying the digital signature of all boot components, and halting the boot process if signature verification fails.",
        "solution": "To be able turn on Shielded VM on an instance, your instance must use an image with Shielded VM support.\nFrom Google Cloud Console\n\nGo to the VM instances page by visiting: https://console.cloud.google.com/compute/instances.\n\nClick on the instance name to see its VM instance details page.\n\nClick STOP to stop the instance.\n\nWhen the instance has stopped, click EDIT.\n\nIn the Shielded VM section, select Turn on vTPM and Turn on Integrity Monitoring.\n\nOptionally, if you do not use any custom or unsigned drivers on the instance, also select Turn on Secure Boot.\n\nClick the Save button to modify the instance and then click START to restart it.\n\nFrom Google Cloud CLI\nYou can only enable Shielded VM options on instances that have Shielded VM support. For a list of Shielded VM public images, run the gcloud compute images list command with the following flags:\n\ngcloud compute images list --project gce-uefi-images --no-standard-images\n\nStop the instance:\n\ngcloud compute instances stopUpdate the instance:\n\ngcloud compute instances update--shielded-vtpm --shielded-vm-integrity-monitoring\n\nOptionally, if you do not use any custom or unsigned drivers on the instance, also turn on secure boot.\n\ngcloud compute instances update--shielded-vm-secure-boot\n\nRestart the instance:\n\ngcloud compute instances startPrevention:\nYou can ensure that all new VMs will be created with Shielded VM enabled by setting up an Organization Policy to for Shielded VM at https://console.cloud.google.com/iam-admin/orgpolicies/compute-requireShieldedVm. Learn more at:\nhttps://cloud.google.com/security/shielded-cloud/shielded-vm#organization-policy-constraint.\n\nDefault Value:\n\nBy default, Compute Instances do not have Shielded VM enabled.",
        "reference": "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv7|5.2,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|2A,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeInstances",
        "json_transform": ".projects[] | .projectNumber as $projectNumber | .projectId as $projectId | .value.items[] | .name as $computeZone | select(.value.items | length > 0) | .value.items[] | \"Project Number: \\($projectNumber), Project ID: \\($projectId), Compute Zone: \\($computeZone), Instance: \\(.name), Enable Integrity Monitoring: \\(.shieldedInstanceConfig.enableIntegrityMonitoring), Enable vTPM: \\(.shieldedInstanceConfig.enableVtpm)\"",
        "regex": "Enable Integrity Monitoring:",
        "expect": "Enable Integrity Monitoring: true, Enable vTPM: true"
    },
    "custom_item_27": {
        "description": "4.9 Ensure That Compute Instances Do Not Have Public IP Addresses",
        "info": "Compute instances should not be configured to have external IP addresses.\n\nRationale:\n\nTo reduce your attack surface, Compute instances should not have public IP addresses. Instead, instances should be configured behind load balancers, to minimize the instance's exposure to the internet.\n\nImpact:\n\nRemoving the external IP address from your Compute instance may cause some applications to stop working.",
        "solution": "From Google Cloud Console\n\nGo to the VM instances page by visiting: https://console.cloud.google.com/compute/instances.\n\nClick on the instance name to go the the Instance detail page.\n\nClick Edit.\n\nFor each Network interface, ensure that External IP is set to None.\n\nClick Done and then click Save.\n\nFrom Google Cloud CLI\n\nDescribe the instance properties:\n\ngcloud compute instances describe--zone=Identify the access config name that contains the external IP address. This access config appears in the following format:\n\nnetworkInterfaces:\n- accessConfigs:\n - kind: compute#accessConfig\n   name: External NAT\n   natIP: 130.211.181.55\n   type: ONE_TO_ONE_NAT\n\nDelete the access config.\n\ngcloud compute instances delete-access-config--zone=--access-config-nameIn the above example, the ACCESS_CONFIG_NAME is External NAT. The name of your access config might be different.\nPrevention:\nYou can configure the Define allowed external IPs for VM instances Organization Policy to prevent VMs from being configured with public IP addresses. Learn more at: https://console.cloud.google.com/orgpolicies/compute-vmExternalIpAccess\n\nDefault Value:\n\nBy default, Compute instances have a public IP address.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeInstances",
        "json_transform": ".projects[].value.items[] | select(.value.items | length > 0) | .value.items[] | \"Instance: \\(.selfLink), Access Configs: \\(.networkInterfaces[].accessConfigs[])\"",
        "regex": "Access Configs:",
        "expect": "Access Configs: null"
    },
    "custom_item_28": {
        "description": "4.11 Ensure That Compute Instances Have Confidential Computing Enabled",
        "info": "Google Cloud encrypts data at-rest and in-transit, but customer data must be decrypted for processing. Confidential Computing is a breakthrough technology which encrypts data in-use-while it is being processed. Confidential Computing environments keep data encrypted in memory and elsewhere outside the central processing unit (CPU).\n\nConfidential VMs leverage the Secure Encrypted Virtualization (SEV) feature of AMD EPYC(TM) CPUs. Customer data will stay encrypted while it is used, indexed, queried, or trained on. Encryption keys are generated in hardware, per VM, and not exportable. Thanks to built-in hardware optimizations of both performance and security, there is no significant performance penalty to Confidential Computing workloads.\n\nRationale:\n\nConfidential Computing enables customers' sensitive code and other data encrypted in memory during processing. Google does not have access to the encryption keys. Confidential VM can help alleviate concerns about risk related to either dependency on Google infrastructure or Google insiders' access to customer data in the clear.\n\nImpact:\n\nConfidential Computing for Compute instances does not support live migration. Unlike regular Compute instances, Confidential VMs experience disruptions during maintenance events like a software or hardware update.\n\nAdditional charges may be incurred when enabling this security feature. See https://cloud.google.com/compute/confidential-vm/pricing for more info.",
        "solution": "Confidential Computing can only be enabled when an instance is created. You must delete the current instance and create a new one.\nFrom Google Cloud Console\n\nGo to the VM instances page by visiting: https://console.cloud.google.com/compute/instances.\n\nClick CREATE INSTANCE.\n\nFill out the desired configuration for your instance.\n\nUnder the Confidential VM service section, check the option Enable the Confidential Computing service on this VM instance.\n\nClick Create.\n\nFrom Google Cloud CLI\nCreate a new instance with Confidential Compute enabled.\n\ngcloud compute instances create--zone--confidential-compute  --maintenance-policy=TERMINATE\n\nDefault Value:\n\nBy default, Confidential Computing is disabled for Compute instances.",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|2A,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listComputeInstances",
        "json_transform": ".projects[].value.items[] | select(.value.items | length > 0) | .value.items[] | \"Machine Type: \\(.machineType), Instance: \\(.selfLink), Enable Confidential Compute: \\(.confidentialInstanceConfig.enableConfidentialCompute)\"",
        "regex": "machineTypes/n2d-",
        "expect": "Enable Confidential Compute: true"
    },
    "custom_item_29": {
        "description": "5.2 Ensure That Cloud Storage Buckets Have Uniform Bucket-Level Access Enabled",
        "info": "It is recommended that uniform bucket-level access is enabled on Cloud Storage buckets.\n\nRationale:\n\nIt is recommended to use uniform bucket-level access to unify and simplify how you grant access to your Cloud Storage resources.\n\nCloud Storage offers two systems for granting users permission to access your buckets and objects: Cloud Identity and Access Management (Cloud IAM) and Access Control Lists (ACLs). These systems act in parallel - in order for a user to access a Cloud Storage resource, only one of the systems needs to grant the user permission. Cloud IAM is used throughout Google Cloud and allows you to grant a variety of permissions at the bucket and project levels. ACLs are used only by Cloud Storage and have limited permission options, but they allow you to grant permissions on a per-object basis.\n\nIn order to support a uniform permissioning system, Cloud Storage has uniform bucket-level access. Using this feature disables ACLs for all Cloud Storage resources: access to Cloud Storage resources then is granted exclusively through Cloud IAM. Enabling uniform bucket-level access guarantees that if a Storage bucket is not publicly accessible, no object in the bucket is publicly accessible either.\n\nImpact:\n\nIf you enable uniform bucket-level access, you revoke access from users who gain their access solely through object ACLs.\n\nCertain Google Cloud services, such as Stackdriver, Cloud Audit Logs, and Datastore, cannot export to Cloud Storage buckets that have uniform bucket-level access enabled.",
        "solution": "From Google Cloud Console\n\nOpen the Cloud Storage browser in the Google Cloud Console by visiting: https://console.cloud.google.com/storage/browser\n\nIn the list of buckets, click on the name of the desired bucket.\n\nSelect the Permissions tab near the top of the page.\n\nIn the text box that starts with This bucket uses fine-grained access control..., click Edit.\n\nIn the pop-up menu that appears, select Uniform.\n\nClick Save.\n\nFrom Google Cloud CLI\nUse the on option in a uniformbucketlevelaccess set command:\n\ngsutil uniformbucketlevelaccess set on gs://BUCKET_NAME/\n\nPrevention\nYou can set up an Organization Policy to enforce that any new bucket has uniform bucket level access enabled. Learn more at:\nhttps://cloud.google.com/storage/docs/setting-org-policies#uniform-bucket\n\nDefault Value:\n\nBy default, Cloud Storage buckets do not have uniform bucket-level access enabled.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listBuckets",
        "json_transform": ".projects[].value.items[] | \"Bucket: \\(.selfLink), Uniform Bucket Level Access Enabled: \\(.iamConfiguration.uniformBucketLevelAccess.enabled)\"",
        "regex": "Uniform Bucket Level Access Enabled:",
        "expect": "Uniform Bucket Level Access Enabled: true"
    },
    "custom_item_30": {
        "description": "6.2.1 Ensure 'Log_error_verbosity' Database Flag for Cloud SQL PostgreSQL Instance Is Set to 'DEFAULT' or Stricter",
        "info": "The log_error_verbosity flag controls the verbosity/details of messages logged. Valid values are:\n\nTERSE\n\nDEFAULT\n\nVERBOSE\n\nTERSE excludes the logging of DETAIL, HINT, QUERY, and CONTEXT error information.\n\nVERBOSE output includes the SQLSTATE error code, source code file name, function name, and line number that generated the error.\n\nEnsure an appropriate value is set to 'DEFAULT' or stricter.\n\nRationale:\n\nAuditing helps in troubleshooting operational problems and also permits forensic analysis. If log_error_verbosity is not set to the correct value, too many details or too few details may be logged. This flag should be configured with a value of 'DEFAULT' or stricter. This recommendation is applicable to PostgreSQL database instances.\n\nImpact:\n\nTurning on logging will increase the required storage over time. Mismanaged logs may cause your storage costs to increase. Setting custom flags via command line on certain instances will cause all omitted flags to be reset to defaults. This may cause you to lose custom flags and could result in unforeseen complications or instance restarts. Because of this, it is recommended you apply these flags changes during a period of low usage.",
        "solution": "From Google Cloud Console\n\nGo to the Cloud SQL Instances page in the Google Cloud Console by visiting https://console.cloud.google.com/sql/instances.\n\nSelect the PostgreSQL instance for which you want to enable the database flag.\n\nClick Edit.\n\nScroll down to the Flags section.\n\nTo set a flag that has not been set on the instance before, click Add a Database Flag, choose the flag log_error_verbosity from the drop-down menu and set appropriate value.\n\nClick Save to save your changes.\n\nConfirm your changes under Flags on the Overview page.\n\nFrom Google Cloud CLI\n\nConfigure the log_error_verbosity database flag for every Cloud SQL PosgreSQL database instance using the below command.\n\ngcloud sql instances patch INSTANCE_NAME --database-flags log_error_verbosity=Note: This command will overwrite all database flags previously set. To keep those and add new ones, include the values for all flags you want set on the instance; any flag not specifically included is set to its default value. For flags that do not take a value, specify the flag name followed by an equals sign ('=').\n\nDefault Value:\n\nBy default log_error_verbosity is DEFAULT.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listSqlInstances",
        "json_transform": ".projects[].value.items[] | [.settings.databaseFlags[] | select(.name == \"log_error_verbosity\").value] as $value | \"Instance: \\(.selfLink), Database Version: \\(.databaseVersion), Log Error Verbosity: \\($value[0])\"",
        "regex": "Database Version: POSTGRES",
        "expect": "Log Error Verbosity: (TERSE|DEFAULT)"
    },
    "custom_item_31": {
        "description": "6.2.4 Ensure 'Log_statement' Database Flag for Cloud SQL PostgreSQL Instance Is Set Appropriately",
        "info": "The value of log_statement flag determined the SQL statements that are logged. Valid values are:\n\nnone\n\nddl\n\nmod\n\nall\n\nThe value ddl logs all data definition statements. The value mod logs all ddl statements, plus data-modifying statements.\n\nThe statements are logged after a basic parsing is done and statement type is determined, thus this does not logs statements with errors. When using extended query protocol, logging occurs after an Execute message is received and values of the Bind parameters are included.\n\nA value of 'ddl' is recommended unless otherwise directed by your organization's logging policy.\n\nRationale:\n\nAuditing helps in forensic analysis. If log_statement is not set to the correct value, too many statements may be logged leading to issues in finding the relevant information from the logs, or too few statements may be logged with relevant information missing from the logs. Setting log_statement to align with your organization's security and logging policies facilitates later auditing and review of database activities. This recommendation is applicable to PostgreSQL database instances.\n\nImpact:\n\nTurning on logging will increase the required storage over time. Mismanaged logs may cause your storage costs to increase. Setting custom flags via command line on certain instances will cause all omitted flags to be reset to defaults. This may cause you to lose custom flags and could result in unforeseen complications or instance restarts. Because of this, it is recommended you apply these flags changes during a period of low usage.",
        "solution": "From Google Cloud Console\n\nGo to the Cloud SQL Instances page in the Google Cloud Console by visiting https://console.cloud.google.com/sql/instances.\n\nSelect the PostgreSQL instance for which you want to enable the database flag.\n\nClick Edit.\n\nScroll down to the Flags section.\n\nTo set a flag that has not been set on the instance before, click Add a Database Flag, choose the flag log_statement from the drop-down menu and set appropriate value.\n\nClick Save to save your changes.\n\nConfirm your changes under Flags on the Overview page.\n\nFrom Google Cloud CLI\n\nConfigure the log_statement database flag for every Cloud SQL PosgreSQL database instance using the below command.\n\ngcloud sql instances patch--database-flags log_statement=Note: This command will overwrite all database flags previously set. To keep those and add new ones, include the values for all flags you want set on the instance; any flag not specifically included is set to its default value. For flags that do not take a value, specify the flag name followed by an equals sign ('=').",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listSqlInstances",
        "json_transform": ".projects[].value.items[] | [.settings.databaseFlags[] | select(.name == \"log_statement\").value] as $value | \"Instance: \\(.selfLink), Database Version: \\(.databaseVersion), Log Statement: \\($value[0])\"",
        "regex": "Database Version: POSTGRES",
        "expect": "Log Statement: @POSTGRESQL_LOG_STATEMENT@"
    },
    "custom_item_32": {
        "description": "6.6 Ensure That Cloud SQL Database Instances Do Not Have Public IPs",
        "info": "It is recommended to configure Second Generation Sql instance to use private IPs instead of public IPs.\n\nRationale:\n\nTo lower the organization's attack surface, Cloud SQL databases should not have public IPs. Private IPs provide improved network security and lower latency for your application.\n\nImpact:\n\nRemoving the public IP address on SQL instances may break some applications that relied on it for database connectivity.",
        "solution": "From Google Cloud Console\n\nGo to the Cloud SQL Instances page in the Google Cloud Console: https://console.cloud.google.com/sql/instances\n\nClick the instance name to open its Instance details page.\n\nSelect the Connections tab.\n\nDeselect the Public IP checkbox.\n\nClick Save to update the instance.\n\nFrom Google Cloud CLI\n\nFor every instance remove its public IP and assign a private IP instead:\n\ngcloud sql instances patch--network=--no-assign-ip\n\nConfirm the changes using the following command::\n\ngcloud sql instances describePrevention:\nTo prevent new SQL instances from getting configured with public IP addresses, set up a Restrict Public IP access on Cloud SQL instances Organization policy at: https://console.cloud.google.com/iam-admin/orgpolicies/sql-restrictPublicIp.\n\nDefault Value:\n\nBy default, Cloud Sql instances have a public IP.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "listSqlInstances",
        "json_transform": ".projects[].value.items[] | .selfLink as $selfLink | select(.backendType == \"SECOND_GEN\") | .ipAddresses[] | \"Instance: \\($selfLink), IP Address: \\(.ipAddress), Type: \\(.type)\"",
        "regex": "Type:",
        "not_expect": "Type: PRIMARY"
    },
    "custom_item_33": {
        "description": "7.3 Ensure That a Default Customer-Managed Encryption Key (CMEK) Is Specified for All BigQuery Data Sets",
        "info": "BigQuery by default encrypts the data as rest by employing Envelope Encryption using Google managed cryptographic keys. The data is encrypted using the data encryption keys and data encryption keys themselves are further encrypted using key encryption keys. This is seamless and do not require any additional input from the user. However, if you want to have greater control, Customer-managed encryption keys (CMEK) can be used as encryption key management solution for BigQuery Data Sets.\n\nRationale:\n\nBigQuery by default encrypts the data as rest by employing Envelope Encryption using Google managed cryptographic keys. This is seamless and does not require any additional input from the user.\n\nFor greater control over the encryption, customer-managed encryption keys (CMEK) can be used as encryption key management solution for BigQuery Data Sets. Setting a Default Customer-managed encryption key (CMEK) for a data set ensure any tables created in future will use the specified CMEK if none other is provided.\n\nNote: Google does not store your keys on its servers and cannot access your protected data unless you provide the key. This also means that if you forget or lose your key, there is no way for Google to recover the key or to recover any data encrypted with the lost key.\n\nImpact:\n\nUsing Customer-managed encryption keys (CMEK) will incur additional labor-hour investment to create, protect, and manage the keys.",
        "solution": "From Google Cloud CLI\nThe default CMEK for existing data sets can be updated by specifying the default key in the EncryptionConfiguration.kmsKeyName field when calling the datasets.insert or datasets.patch methods\n\nDefault Value:\n\nGoogle Managed keys are used as key encryption keys.",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|2A,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/11843",
        "request": "getBqDataset",
        "json_transform": ".projects[].value.datasets[].value | \"Instance: \\(.selfLink), KMS Key Name: \\(.defaultEncryptionConfiguration.kmsKeyName)\"",
        "regex": "KMS Key Name:",
        "not_expect": "KMS Key Name: null"
    }
}