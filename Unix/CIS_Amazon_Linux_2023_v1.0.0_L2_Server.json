{
    "custom_item_1": {
        "description": "Amazon Linux 2023 is installed",
        "file": "/etc/system-release",
        "regex": "^[\\\\s]*Amazon Linux release",
        "expect": "^[\\\\s]*Amazon Linux release @PLATFORM_VERSION@"
    },
    "custom_item_2": {
        "description": "1.1.1.1 Ensure mounting of squashfs filesystems is disabled",
        "info": "The squashfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A squashfs image can be used without having to first decompress the image.\n\nRemoving support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
        "solution": "Run the following script to disable the squashfs module:\n\nIf the module is available in the running kernel:\n\n - Create a file with install squashfs /bin/false in the /etc/modprobe.d/ directory\n - Create a file with blacklist squashfs in the /etc/modprobe.d/ directory\n - Unload squashfs from the kernel\n\nIf available in ANY installed kernel:\n\n - Create a file with blacklist squashfs in the /etc/modprobe.d/ directory\n\nIf the kernel module is not available on the system or pre-compiled into the kernel:\n\n - No remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   l_mname=\"squashfs\" # set module name\n   l_mtype=\"fs\" # set module type\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_fix()\n   {\n      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"\n      if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then\n         echo -e \"\\n - setting module: \\\\\"$l_mname\\\\\" to be not loadable\"\n         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   module_loaded_fix()\n   {\n      # If the module is currently loaded, unload the module\n      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         echo -e \"\\n - unloading module \\\\\"$l_mname\\\\\"\"\n         modprobe -r \"$l_mname\"\n      fi\n   }\n   module_deny_fix()\n   {\n      # If the module isn't deny listed, denylist the module\n      if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mpname\\b\"; then\n         echo -e \"\\n - deny listing \\\\\"$l_mname\\\\\"\"\n         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" exists in \\\\\"$l_mdir\\\\\"\\n - checking if disabled...\"\n         module_deny_fix\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_fix\n            module_loaded_fix\n         fi\n      else\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\\n\"\n      fi\n   done\n   echo -e \"\\n - remediation of module: \\\\\"$l_mname\\\\\" complete\\n\"\n}\n\nImpact:\n\nAs Snap packages utilizes squashfs as a compressed filesystem, disabling squashfs will cause Snap packages to fail.\n\nSnap application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store (\"App store\"), can be obtained from any source and can be therefore used for upstream software deployment.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables\n   l_mname=\"squashfs\" # set module name\n   l_mtype=\"fs\" # set module type\n   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_chk()\n   {\n      # Check if the module is currently loadable\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\\\h*install|\\\\b$l_mname)\\\\b\" <<< \"$l_loadable\")\"\n      if grep -Pq -- '^\\\\h*install \\\\/bin\\\\/(true|false)' <<< \"$l_loadable\"; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is not loadable: \\\\\"$l_loadable\\\\\"\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is loadable: \\\\\"$l_loadable\\\\\"\"\n      fi\n   }\n   module_loaded_chk()\n   {\n      # Check if the module is currently loaded\n      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is not loaded\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is loaded\"\n      fi\n   }\n   module_deny_chk()\n   {\n      # Check if the module is deny listed\n      l_dl=\"y\"\n      if modprobe --showconfig | grep -Pq -- '^\\\\h*blacklist\\\\h+'\"$l_mpname\"'\\\\b'; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is deny listed in: \\\\\"$(grep -Pls -- \"^\\\\h*blacklist\\\\h+$l_mname\\\\b\" $l_searchloc)\\\\\"\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is not deny listed\"\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         l_output3=\"$l_output3\\\\n  - \\\\\"$l_mdir\\\\\"\"\n         [ \"$l_dl\" != \"y\" ] && module_deny_chk\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_chk\n            module_loaded_chk\n         fi\n      else\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\"\n      fi\n   done\n   # Report results. If no failures output in l_output2, we pass\n   [ -n \"$l_output3\" ] && echo -e \"\\\\n\\\\n -- INFO --\\\\n - module: \\\\\"$l_mname\\\\\" exists in:$l_output3\"\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\\\\n- Audit Result:\\\\n  ** PASS **\\\\n$l_output\\\\n\"\n   else\n      echo -e \"\\\\n- Audit Result:\\\\n  ** FAIL **\\\\n - Reason(s) for audit failure:\\\\n$l_output2\\\\n\"\n      [ -n \"$l_output\" ] && echo -e \"\\\\n- Correctly set:\\\\n$l_output\\\\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_3": {
        "description": "1.1.1.2 Ensure mounting of udf filesystems is disabled",
        "info": "The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats.\n\nRemoving support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
        "solution": "Run the following script to disable the udf module:\n\nIf the module is available in the running kernel:\n\n - Create a file with install udf /bin/false in the /etc/modprobe.d/ directory\n - Create a file with blacklist udf in the /etc/modprobe.d/ directory\n - Unload udf from the kernel\n\nIf available in ANY installed kernel:\n\n - Create a file with blacklist udf in the /etc/modprobe.d/ directory\n\nIf the kernel module is not available on the system or pre-compiled into the kernel:\n\n - No remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   l_mname=\"udf\" # set module name\n   l_mtype=\"fs\" # set module type\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_fix()\n   {\n      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"\n      if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then\n         echo -e \"\\n - setting module: \\\\\"$l_mname\\\\\" to be not loadable\"\n         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   module_loaded_fix()\n   {\n      # If the module is currently loaded, unload the module\n      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         echo -e \"\\n - unloading module \\\\\"$l_mname\\\\\"\"\n         modprobe -r \"$l_mname\"\n      fi\n   }\n   module_deny_fix()\n   {\n      # If the module isn't deny listed, denylist the module\n      if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mpname\\b\"; then\n         echo -e \"\\n - deny listing \\\\\"$l_mname\\\\\"\"\n         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" exists in \\\\\"$l_mdir\\\\\"\\n - checking if disabled...\"\n         module_deny_fix\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_fix\n            module_loaded_fix\n         fi\n      else\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\\n\"\n      fi\n   done\n   echo -e \"\\n - remediation of module: \\\\\"$l_mname\\\\\" complete\\n\"\n}",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables\n   l_mname=\"udf\" # set module name\n   l_mtype=\"fs\" # set module type\n   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_chk()\n   {\n      # Check if the module is currently loadable\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\\\h*install|\\\\b$l_mname)\\\\b\" <<< \"$l_loadable\")\"\n      if grep -Pq -- '^\\\\h*install \\\\/bin\\\\/(true|false)' <<< \"$l_loadable\"; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is not loadable: \\\\\"$l_loadable\\\\\"\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is loadable: \\\\\"$l_loadable\\\\\"\"\n      fi\n   }\n   module_loaded_chk()\n   {\n      # Check if the module is currently loaded\n      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is not loaded\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is loaded\"\n      fi\n   }\n   module_deny_chk()\n   {\n      # Check if the module is deny listed\n      l_dl=\"y\"\n      if modprobe --showconfig | grep -Pq -- '^\\\\h*blacklist\\\\h+'\"$l_mpname\"'\\\\b'; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is deny listed in: \\\\\"$(grep -Pls -- \"^\\\\h*blacklist\\\\h+$l_mname\\\\b\" $l_searchloc)\\\\\"\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is not deny listed\"\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         l_output3=\"$l_output3\n  - \\\\\"$l_mdir\\\\\"\"\n         [ \"$l_dl\" != \"y\" ] && module_deny_chk\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_chk\n            module_loaded_chk\n         fi\n      else\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\"\n      fi\n   done\n   # Report results. If no failures output in l_output2, we pass\n   [ -n \"$l_output3\" ] && echo -e \"\n\n -- INFO --\n - module: \\\\\"$l_mname\\\\\" exists in:$l_output3\"\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\n- Audit Result:\n  ** PASS **\n$l_output\n\"\n   else\n      echo -e \"\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n\"\n      [ -n \"$l_output\" ] && echo -e \"\n- Correctly set:\n$l_output\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_4": {
        "description": "1.1.3.1 Ensure separate partition exists for /var",
        "info": "The /var directory is used by daemons and other system services to temporarily store dynamic data. Some directories created by these processes may be world-writable.\n\nThe reasoning for mounting /var on a separate partition is as follows.\n\nProtection from resource exhaustion\n\nThe default installation only creates a single / partition. Since the /var directory may contain world-writable files and directories, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var and cause unintended behavior across the system as the disk is full. See man auditd.conf for details.\n\nFine grained control over the mount\n\nConfiguring /var as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limits an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.\n\nProtection from exploitation\n\nAn example of exploiting /var may be an attacker establishing a hard-link to a system setuid program and wait for it to be updated. Once the program was updated, the hard-link would be broken and the attacker would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw.",
        "solution": "For new installations, during installation create a custom partition setup and specify a separate partition for /var\n\nFor systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.\n\nImpact:\n\nResizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/findmnt -kn /var",
        "expect": "^[\\\\s]*/var[\\\\s]+"
    },
    "custom_item_5": {
        "description": "1.1.4.1 Ensure separate partition exists for /var/tmp",
        "info": "The /var/tmp directory is a world-writable directory used for temporary storage by all users and some applications. Temporary files residing in /var/tmp are to be preserved between reboots.\n\nThe reasoning for mounting /var/tmp on a separate partition is as follows.\n\nProtection from resource exhaustion\n\nThe default installation only creates a single / partition. Since the /var/tmp directory may contain world-writable files and directories, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var/tmp and cause potential disruption to daemons as the disk is full.\n\nFine grained control over the mount\n\nConfiguring /var/tmp as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limits an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.\n\nProtection from exploitation\n\nAn example of exploiting /var/tmp may be an attacker establishing a hard-link to a system setuid program and wait for it to be updated. Once the program was updated, the hard-link would be broken and the attacker would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw.",
        "solution": "For new installations, during installation create a custom partition setup and specify a separate partition for /var/tmp\n\nFor systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.\n\nImpact:\n\nResizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/findmnt --kernel /var/tmp",
        "expect": "^[\\\\s]*/var/tmp[\\\\s]+.+[\\\\s]+.+"
    },
    "custom_item_6": {
        "description": "1.1.5.1 Ensure separate partition exists for /var/log",
        "info": "The /var/log directory is used by system services to store log data.\n\nThe reasoning for mounting /var/log on a separate partition is as follows.\n\nProtection from resource exhaustion\n\nThe default installation only creates a single / partition. Since the /var/log directory contains log files which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole.\n\nFine grained control over the mount\n\nConfiguring /var/log as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.\n\nProtection of log data\n\nAs /var/log contains log files, care should be taken to ensure the security and integrity of the data and mount point.",
        "solution": "For new installations, during installation create a custom partition setup and specify a separate partition for /var/log\n\nFor systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.\n\nImpact:\n\nResizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations.",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/findmnt --kernel /var/log",
        "expect": "^[\\\\s]*/var/log[\\\\s]+.+[\\\\s]+.+"
    },
    "custom_item_7": {
        "description": "1.1.6.1 Ensure separate partition exists for /var/log/audit",
        "info": "The auditing daemon, auditd stores log data in the /var/log/audit directory.\n\nThe reasoning for mounting /var/log/audit on a separate partition is as follows.\n\nProtection from resource exhaustion\n\nThe default installation only creates a single / partition. Since the /var/log/audit directory contains the audit.log file which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var/log/audit and cause auditd to trigger it's space_left_action as the disk is full. See man auditd.conf for details.\n\nFine grained control over the mount\n\nConfiguring /var/log/audit as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.\n\nProtection of audit data\n\nAs /var/log/audit contains audit logs, care should be taken to ensure the security and integrity of the data and mount point.",
        "solution": "For new installations, during installation create a custom partition setup and specify a separate partition for /var/log/audit\n\nFor systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.\n\nImpact:\n\nResizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations.",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/findmnt --kernel /var/log/audit",
        "expect": "^[\\\\s]*/var/log/audit[\\\\s]+.+[\\\\s]+.+"
    },
    "custom_item_8": {
        "description": "1.1.7.1 Ensure separate partition exists for /home",
        "info": "The /home directory is used to support disk storage needs of local users.\n\nThe reasoning for mounting /home on a separate partition is as follows.\n\nProtection from resource exhaustion\n\nThe default installation only creates a single / partition. Since the /home directory contains user generated data, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /home and impact all local users.\n\nFine grained control over the mount\n\nConfiguring /home as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. In the case of /home options such as usrquota/grpquota may be considered to limit the impact that users can have on each other with regards to disk resource exhaustion. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.\n\nProtection of user data\n\nAs /home contains user data, care should be taken to ensure the security and integrity of the data and mount point.",
        "solution": "For new installations, during installation create a custom partition setup and specify a separate partition for /home\n\nFor systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.\n\nImpact:\n\nResizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/findmnt --kernel /home",
        "expect": "^[\\\\s]*/home[\\\\s]+.+[\\\\s]+.+"
    },
    "custom_item_9": {
        "description": "Per repository configuration",
        "cmd": "/bin/grep -l \"repo_gpgcheck=0\" /etc/yum.repos.d/* | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"manual_review_required\"}\\'",
        "expect": "^pass$"
    },
    "custom_item_10": {
        "description": "Global configuration",
        "file": "/etc/dnf/dnf.conf",
        "regex": "^[\\\\s]*repo_gpgcheck[\\\\s]*=",
        "expect": "^[\\\\s]*repo_gpgcheck[\\\\s]*=[\\\\s]*1[\\\\s]*$"
    },
    "custom_item_11": {
        "description": "/etc/selinux/config",
        "file": "/etc/selinux/config",
        "regex": "(?i)^[\\\\s]*SELINUX[\\\\s]*=",
        "expect": "(?i)^[\\\\s]*SELINUX[\\\\s]*=[\\\\s]*enforcing[\\\\s]*$"
    },
    "custom_item_12": {
        "description": "getenforce",
        "cmd": "/sbin/getenforce",
        "expect": "(?i)^[\\\\s]*enforcing[\\\\s]*$"
    },
    "custom_item_13": {
        "description": "2.2.1 Ensure xorg-x11-server-common is not installed",
        "info": "The X Window System provides a Graphical User Interface (GUI) where users can have multiple windows in which to run programs and various add on. The X Windows system is typically used on workstations where users login, but not on servers where users typically do not login.\n\nUnless your organization specifically requires graphical login access via X Windows, remove it to reduce the potential attack surface.",
        "solution": "Run the following command to remove the X Windows Server packages:\n\n# dnf remove xorg-x11-server-common\n\nImpact:\n\nMany Linux systems run applications which require a Java runtime. Some Linux Java packages have a dependency on specific X Windows xorg-x11-fonts. One workaround to avoid this dependency is to use the \"headless\" Java packages for your specific Java runtime.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "rpm": "xorg-x11-server-common-0.0.0-0",
        "operator": "lte"
    },
    "custom_item_14": {
        "description": "3.1.2 Ensure DCCP is disabled",
        "info": "The Datagram Congestion Control Protocol (DCCP) is a transport layer protocol that supports streaming media and telephony. DCCP provides a way to gain access to congestion control, without having to do it at the application layer, but does not provide in-sequence delivery.\n\nIf the protocol is not required, it is recommended that the drivers not be installed to reduce the potential attack surface.",
        "solution": "Run the following script to disable the dccp module:\n\nIf the module is available in the running kernel:\n\n - Create a file with install dccp /bin/false in the /etc/modprobe.d/ directory\n - Create a file with blacklist dccp in the /etc/modprobe.d/ directory\n - Unload dccp from the kernel\n\nIf available in ANY installed kernel:\n\n - Create a file with blacklist dccp in the /etc/modprobe.d/ directory\n\nIf the kernel module is not available on the system or pre-compiled into the kernel:\n\n - No remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   l_mname=\"dccp\" # set module name\n   l_mtype=\"net\" # set module type\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_fix()\n   {\n      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"\n      if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then\n         echo -e \"\\n - setting module: \\\\\"$l_mname\\\\\" to be not loadable\"\n         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   module_loaded_fix()\n   {\n      # If the module is currently loaded, unload the module\n      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         echo -e \"\\n - unloading module \\\\\"$l_mname\\\\\"\"\n         modprobe -r \"$l_mname\"\n      fi\n   }\n   module_deny_fix()\n   {\n      # If the module isn't deny listed, denylist the module\n      if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mpname\\b\"; then\n         echo -e \"\\n - deny listing \\\\\"$l_mname\\\\\"\"\n         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" exists in \\\\\"$l_mdir\\\\\"\\n - checking if disabled...\"\n         module_deny_fix\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_fix\n            module_loaded_fix\n         fi\n      else\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\\n\"\n      fi\n   done\n   echo -e \"\\n - remediation of module: \\\\\"$l_mname\\\\\" complete\\n\"\n}",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables\n   l_mname=\"dccp\" # set module name\n   l_mtype=\"net\" # set module type\n   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_chk()\n   {\n      # Check if the module is currently loadable\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\\\h*install|\\\\b$l_mname)\\\\b\" <<< \"$l_loadable\")\"\n      if grep -Pq -- '^\\\\h*install \\\\/bin\\\\/(true|false)' <<< \"$l_loadable\"; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is not loadable: \\\\\"$l_loadable\\\\\"\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is loadable: \\\\\"$l_loadable\\\\\"\"\n      fi\n   }\n   module_loaded_chk()\n   {\n      # Check if the module is currently loaded\n      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is not loaded\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is loaded\"\n      fi\n   }\n   module_deny_chk()\n   {\n      # Check if the module is deny listed\n      l_dl=\"y\"\n      if modprobe --showconfig | grep -Pq -- '^\\\\h*blacklist\\\\h+'\"$l_mpname\"'\\\\b'; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is deny listed in: \\\\\"$(grep -Pls -- \"^\\\\h*blacklist\\\\h+$l_mname\\\\b\" $l_searchloc)\\\\\"\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is not deny listed\"\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         l_output3=\"$l_output3\n  - \\\\\"$l_mdir\\\\\"\"\n         [ \"$l_dl\" != \"y\" ] && module_deny_chk\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_chk\n            module_loaded_chk\n         fi\n      else\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\"\n      fi\n   done\n   # Report results. If no failures output in l_output2, we pass\n   [ -n \"$l_output3\" ] && echo -e \"\n\n -- INFO --\n - module: \\\\\"$l_mname\\\\\" exists in:$l_output3\"\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\n- Audit Result:\n  ** PASS **\n$l_output\n\"\n   else\n      echo -e \"\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n\"\n      [ -n \"$l_output\" ] && echo -e \"\n- Correctly set:\n$l_output\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_15": {
        "description": "3.1.3 Ensure SCTP is disabled",
        "info": "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol used to support message oriented communication, with several streams of messages in one connection. It serves a similar function as TCP and UDP, incorporating features of both. It is message-oriented like UDP, and ensures reliable in-sequence transport of messages with congestion control like TCP.\n\nIf the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface.",
        "solution": "Run the following script to disable the sctp module:\n\nIf the module is available in the running kernel:\n\n - Create a file with install sctp /bin/false in the /etc/modprobe.d/ directory\n - Create a file with blacklist sctp in the /etc/modprobe.d/ directory\n - Unload sctp from the kernel\n\nIf available in ANY installed kernel:\n\n - Create a file with blacklist sctp in the /etc/modprobe.d/ directory\n\nIf the kernel module is not available on the system or pre-compiled into the kernel:\n\n - No remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   l_mname=\"sctp\" # set module name\n   l_mtype=\"net\" # set module type\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_fix()\n   {\n      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"\n      if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then\n         echo -e \"\\n - setting module: \\\\\"$l_mname\\\\\" to be not loadable\"\n         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   module_loaded_fix()\n   {\n      # If the module is currently loaded, unload the module\n      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         echo -e \"\\n - unloading module \\\\\"$l_mname\\\\\"\"\n         modprobe -r \"$l_mname\"\n      fi\n   }\n   module_deny_fix()\n   {\n      # If the module isn't deny listed, denylist the module\n      if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mpname\\b\"; then\n         echo -e \"\\n - deny listing \\\\\"$l_mname\\\\\"\"\n         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" exists in \\\\\"$l_mdir\\\\\"\\n - checking if disabled...\"\n         module_deny_fix\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_fix\n            module_loaded_fix\n         fi\n      else\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\\n\"\n      fi\n   done\n   echo -e \"\\n - remediation of module: \\\\\"$l_mname\\\\\" complete\\n\"\n}",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables\n   l_mname=\"sctp\" # set module name\n   l_mtype=\"net\" # set module type\n   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_chk()\n   {\n      # Check if the module is currently loadable\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\\\h*install|\\\\b$l_mname)\\\\b\" <<< \"$l_loadable\")\"\n      if grep -Pq -- '^\\\\h*install \\\\/bin\\\\/(true|false)' <<< \"$l_loadable\"; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is not loadable: \\\\\"$l_loadable\\\\\"\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is loadable: \\\\\"$l_loadable\\\\\"\"\n      fi\n   }\n   module_loaded_chk()\n   {\n      # Check if the module is currently loaded\n      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is not loaded\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is loaded\"\n      fi\n   }\n   module_deny_chk()\n   {\n      # Check if the module is deny listed\n      l_dl=\"y\"\n      if modprobe --showconfig | grep -Pq -- '^\\\\h*blacklist\\\\h+'\"$l_mpname\"'\\\\b'; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is deny listed in: \\\\\"$(grep -Pls -- \"^\\\\h*blacklist\\\\h+$l_mname\\\\b\" $l_searchloc)\\\\\"\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is not deny listed\"\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         l_output3=\"$l_output3\\\\n  - \\\\\"$l_mdir\\\\\"\"\n         [ \"$l_dl\" != \"y\" ] && module_deny_chk\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_chk\n            module_loaded_chk\n         fi\n      else\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\"\n      fi\n   done\n   # Report results. If no failures output in l_output2, we pass\n   [ -n \"$l_output3\" ] && echo -e \"\\\\n\\\\n -- INFO --\\\\n - module: \\\\\"$l_mname\\\\\" exists in:$l_output3\"\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\\\\n- Audit Result:\\\\n  ** PASS **\\\\n$l_output\\\\n\"\n   else\n      echo -e \"\\\\n- Audit Result:\\\\n  ** FAIL **\\\\n - Reason(s) for audit failure:\\\\n$l_output2\\\\n\"\n      [ -n \"$l_output\" ] && echo -e \"\\\\n- Correctly set:\\\\n$l_output\\\\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_16": {
        "description": "3.1.4 Ensure RDS is disabled",
        "info": "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide low-latency, high-bandwidth communications between cluster nodes. It was developed by the Oracle Corporation.\n\nIf the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface.",
        "solution": "Run the following script to disable the rds module:\n\nIf the module is available in the running kernel:\n\n - Create a file with install rds /bin/false in the /etc/modprobe.d/ directory\n - Create a file with blacklist rds in the /etc/modprobe.d/ directory\n - Unload rds from the kernel\n\nIf available in ANY installed kernel:\n\n - Create a file with blacklist rds in the /etc/modprobe.d/ directory\n\nIf the kernel module is not available on the system or pre-compiled into the kernel:\n\n - No remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   l_mname=\"rds\" # set module name\n   l_mtype=\"net\" # set module type\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_fix()\n   {\n      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"\n      if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then\n         echo -e \"\\n - setting module: \\\\\"$l_mname\\\\\" to be not loadable\"\n         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   module_loaded_fix()\n   {\n      # If the module is currently loaded, unload the module\n      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         echo -e \"\\n - unloading module \\\\\"$l_mname\\\\\"\"\n         modprobe -r \"$l_mname\"\n      fi\n   }\n   module_deny_fix()\n   {\n      # If the module isn't deny listed, denylist the module\n      if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mpname\\b\"; then\n         echo -e \"\\n - deny listing \\\\\"$l_mname\\\\\"\"\n         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" exists in \\\\\"$l_mdir\\\\\"\\n - checking if disabled...\"\n         module_deny_fix\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_fix\n            module_loaded_fix\n         fi\n      else\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\\n\"\n      fi\n   done\n   echo -e \"\\n - remediation of module: \\\\\"$l_mname\\\\\" complete\\n\"\n}",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables\n   l_mname=\"rds\" # set module name\n   l_mtype=\"net\" # set module type\n   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_chk()\n   {\n      # Check if the module is currently loadable\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\\\h*install|\\\\b$l_mname)\\\\b\" <<< \"$l_loadable\")\"\n      if grep -Pq -- '^\\\\h*install \\\\/bin\\\\/(true|false)' <<< \"$l_loadable\"; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is not loadable: \\\\\"$l_loadable\\\\\"\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is loadable: \\\\\"$l_loadable\\\\\"\"\n      fi\n   }\n   module_loaded_chk()\n   {\n      # Check if the module is currently loaded\n      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is not loaded\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is loaded\"\n      fi\n   }\n   module_deny_chk()\n   {\n      # Check if the module is deny listed\n      l_dl=\"y\"\n      if modprobe --showconfig | grep -Pq -- '^\\\\h*blacklist\\\\h+'\"$l_mpname\"'\\\\b'; then\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" is deny listed in: \\\\\"$(grep -Pls -- \"^\\\\h*blacklist\\\\h+$l_mname\\\\b\" $l_searchloc)\\\\\"\"\n      else\n         l_output2=\"$l_output2\\\\n - module: \\\\\"$l_mname\\\\\" is not deny listed\"\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         l_output3=\"$l_output3\\\\n  - \\\\\"$l_mdir\\\\\"\"\n         [ \"$l_dl\" != \"y\" ] && module_deny_chk\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_chk\n            module_loaded_chk\n         fi\n      else\n         l_output=\"$l_output\\\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\"\n      fi\n   done\n   # Report results. If no failures output in l_output2, we pass\n   [ -n \"$l_output3\" ] && echo -e \"\\\\n\\\\n -- INFO --\\\\n - module: \\\\\"$l_mname\\\\\" exists in:$l_output3\"\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\\\\n- Audit Result:\\\\n  ** PASS **\\\\n$l_output\\\\n\"\n   else\n      echo -e \"\\\\n- Audit Result:\\\\n  ** FAIL **\\\\n - Reason(s) for audit failure:\\\\n$l_output2\\\\n\"\n      [ -n \"$l_output\" ] && echo -e \"\\\\n- Correctly set:\\\\n$l_output\\\\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_17": {
        "description": "3.1.5 Ensure TIPC is disabled",
        "info": "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communication between cluster nodes.\n\nIf the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface.",
        "solution": "Run the following script to disable the tipc module:\n\nIf the module is available in the running kernel:\n\n - Create a file with install tipc /bin/false in the /etc/modprobe.d/ directory\n - Create a file with blacklist tipc in the /etc/modprobe.d/ directory\n - Unload tipc from the kernel\n\nIf available in ANY installed kernel:\n\n - Create a file with blacklist tipc in the /etc/modprobe.d/ directory\n\nIf the kernel module is not available on the system or pre-compiled into the kernel:\n\n - No remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   l_mname=\"tipc\" # set module name\n   l_mtype=\"net\" # set module type\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_fix()\n   {\n      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"\n      if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then\n         echo -e \"\\n - setting module: \\\\\"$l_mname\\\\\" to be not loadable\"\n         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   module_loaded_fix()\n   {\n      # If the module is currently loaded, unload the module\n      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         echo -e \"\\n - unloading module \\\\\"$l_mname\\\\\"\"\n         modprobe -r \"$l_mname\"\n      fi\n   }\n   module_deny_fix()\n   {\n      # If the module isn't deny listed, denylist the module\n      if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mpname\\b\"; then\n         echo -e \"\\n - deny listing \\\\\"$l_mname\\\\\"\"\n         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" exists in \\\\\"$l_mdir\\\\\"\\n - checking if disabled...\"\n         module_deny_fix\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_fix\n            module_loaded_fix\n         fi\n      else\n         echo -e \"\\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\\n\"\n      fi\n   done\n   echo -e \"\\n - remediation of module: \\\\\"$l_mname\\\\\" complete\\n\"\n}",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables\n   l_mname=\"tipc\" # set module name\n   l_mtype=\"net\" # set module type\n   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"\n   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"\n   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"\n   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"\n\n   module_loadable_chk()\n   {\n      # Check if the module is currently loadable\n      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"\n      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\\\h*install|\\\\b$l_mname)\\\\b\" <<< \"$l_loadable\")\"\n      if grep -Pq -- '^\\\\h*install \\\\/bin\\\\/(true|false)' <<< \"$l_loadable\"; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is not loadable: \\\\\"$l_loadable\\\\\"\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is loadable: \\\\\"$l_loadable\\\\\"\"\n      fi\n   }\n   module_loaded_chk()\n   {\n      # Check if the module is currently loaded\n      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is not loaded\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is loaded\"\n      fi\n   }\n   module_deny_chk()\n   {\n      # Check if the module is deny listed\n      l_dl=\"y\"\n      if modprobe --showconfig | grep -Pq -- '^\\\\h*blacklist\\\\h+'\"$l_mpname\"'\\\\b'; then\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" is deny listed in: \\\\\"$(grep -Pls -- \"^\\\\h*blacklist\\\\h+$l_mname\\\\b\" $l_searchloc)\\\\\"\"\n      else\n         l_output2=\"$l_output2\n - module: \\\\\"$l_mname\\\\\" is not deny listed\"\n      fi\n   }\n   # Check if the module exists on the system\n   for l_mdir in $l_mpath; do\n      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then\n         l_output3=\"$l_output3\n  - \\\\\"$l_mdir\\\\\"\"\n         [ \"$l_dl\" != \"y\" ] && module_deny_chk\n         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then\n            module_loadable_chk\n            module_loaded_chk\n         fi\n      else\n         l_output=\"$l_output\n - module: \\\\\"$l_mname\\\\\" doesn't exist in \\\\\"$l_mdir\\\\\"\"\n      fi\n   done\n   # Report results. If no failures output in l_output2, we pass\n   [ -n \"$l_output3\" ] && echo -e \"\n\n -- INFO --\n - module: \\\\\"$l_mname\\\\\" exists in:$l_output3\"\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\n- Audit Result:\n  ** PASS **\n$l_output\n\"\n   else\n      echo -e \"\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n\"\n      [ -n \"$l_output\" ] && echo -e \"\n- Correctly set:\n$l_output\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_18": {
        "description": "3.4.1.1 Ensure nftables is installed",
        "info": "nftables provides a new in-kernel packet classification framework that is based on a network-specific Virtual Machine (VM) and a new nft userspace command line tool.\n\nnftables reuses the existing Netfilter subsystems such as the existing hook infrastructure, the connection tracking system, NAT, userspace queuing and logging subsystem.\n\nnftables is a subsystem of the Linux kernel that can protect against threats originating from within a corporate network to include malicious mobile code and poorly configured software on a host.",
        "solution": "Run the following command to install nftables\n\n# dnf install nftables\n\nImpact:\n\nChanging firewall settings while connected over the network can result in being locked out of the system.",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "rpm": "nftables-0.0.0-0",
        "operator": "gt"
    },
    "custom_item_19": {
        "description": "3.4.1.2 Ensure a single firewall configuration utility is in use",
        "info": "FirewallD - Is a firewall service daemon that provides a dynamic customizable host-based firewall with a D-Bus interface. Being dynamic, it enables creating, changing, and deleting the rules without the necessity to restart the firewall daemon each time the rules are changed\n\nNFTables - Includes the nft utility for configuration of the nftables subsystem of the Linux kernel\n\nNote: firewalld with nftables backend does not support passing custom nftables rules to firewalld, using the --direct option.\n\nIn order to configure firewall rules for nftables, a firewall utility needs to be installed and active of the system. The use of more than one firewall utility may produce unexpected results.",
        "solution": "Run the following script to ensure that a single firewall utility is in use on the system:\n\n#!/usr/bin/env bash\n\n{\n   l_output=\"\" l_output2=\"\" l_fwd_status=\"\" l_nft_status=\"\" l_fwutil_status=\"\"\n   # Determine FirewallD utility Status\n   rpm -q firewalld > /dev/null 2>&1 && l_fwd_status=\"$(systemctl is-enabled firewalld.service):$(systemctl is-active firewalld.service)\"\n   # Determine NFTables utility Status\n   rpm -q nftables > /dev/null 2>&1 && l_nft_status=\"$(systemctl is-enabled nftables.service):$(systemctl is-active nftables.service)\"\n   l_fwutil_status=\"$l_fwd_status:$l_nft_status\"\n   case $l_fwutil_status in\n      enabled:active:masked:inactive|enabled:active:disabled:inactive)\n         echo -e \"\\n - FirewallD utility is in use, enabled and active\\n - NFTables utility is correctly disabled or masked and inactive\\n - no remediation required\" ;;\n      masked:inactive:enabled:active|disabled:inactive:enabled:active)\n         echo -e \"\\n - NFTables utility is in use, enabled and active\\n - FirewallD utility is correctly disabled or masked and inactive\\n - no remediation required\" ;;\n      enabled:active:enabled:active)\n         echo -e \"\\n - Both FirewallD and NFTables utilities are enabled and active\\n - stopping and masking NFTables utility\"\n         systemctl stop nftables && systemctl --now mask nftables ;;\n      enabled:*:enabled:*)\n         echo -e \"\\n - Both FirewallD and NFTables utilities are enabled\\n - remediating\"\n         if [ \"$(awk -F: '{print $2}' <<< \"$l_fwutil_status\")\" = \"active\" ] && [ \"$(awk -F: '{print $4}' <<< \"$l_fwutil_status\")\" = \"inactive\" ]; then\n            echo \" - masking NFTables utility\"\n            systemctl stop nftables && systemctl --now mask nftables\n         elif [ \"$(awk -F: '{print $4}' <<< \"$l_fwutil_status\")\" = \"active\" ] && [ \"$(awk -F: '{print $2}' <<< \"$l_fwutil_status\")\" = \"inactive\" ]; then\n            echo \" - masking FirewallD utility\"\n            systemctl stop firewalld && systemctl --now mask firewalld\n         fi ;;\n      *:active:*:active)\n         echo -e \"\\n - Both FirewallD and NFTables utilities are active\\n - remediating\"\n         if [ \"$(awk -F: '{print $1}' <<< \"$l_fwutil_status\")\" = \"enabled\" ] && [ \"$(awk -F: '{print $3}' <<< \"$l_fwutil_status\")\" != \"enabled\" ]; then\n            echo \" - stopping and masking NFTables utility\"\n            systemctl stop nftables && systemctl --now mask nftables\n         elif [ \"$(awk -F: '{print $3}' <<< \"$l_fwutil_status\")\" = \"enabled\" ] && [ \"$(awk -F: '{print $1}' <<< \"$l_fwutil_status\")\" != \"enabled\" ]; then\n            echo \" - stopping and masking FirewallD utility\"\n            systemctl stop firewalld && systemctl --now mask firewalld\n         fi ;;\n      :enabled:active)\n         echo -e \"\\n - NFTables utility is in use, enabled, and active\\n - FirewallD package is not installed\\n - no remediation required\" ;;\n      :)\n         echo -e \"\\n - Neither FirewallD or NFTables is installed.\\n - remediating\\n - installing NFTables\"\n         dnf -q install nftables ;;\n      *:*:)\n         echo -e \"\\n - NFTables package is not installed on the system\\n - remediating\\n - installing NFTables\"\n         dnf -q install nftables ;;\n      *)\n         echo -e \"\\n - Unable to determine firewall state\" ;;\n   esac\n}",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSCv8|4.5,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\" l_fwd_status=\"\" l_nft_status=\"\" l_fwutil_status=\"\"\n   # Determine FirewallD utility Status\n   rpm -q firewalld > /dev/null 2>&1 && l_fwd_status=\"$(systemctl is-enabled firewalld.service):$(systemctl is-active firewalld.service)\"\n   # Determine NFTables utility Status\n   rpm -q nftables > /dev/null 2>&1 && l_nft_status=\"$(systemctl is-enabled nftables.service):$(systemctl is-active nftables.service)\"\n   l_fwutil_status=\"$l_fwd_status:$l_nft_status\"\n   case $l_fwutil_status in\n      enabled:active:masked:inactive|enabled:active:disabled:inactive)\n         l_output=\"\\\\n - FirewallD utility is in use, enabled and active\\\\n - NFTables utility is correctly disabled or masked and inactive\" ;;\n      masked:inactive:enabled:active|disabled:inactive:enabled:active)\n         l_output=\"\\\\n - NFTables utility is in use, enabled and active\\\\n - FirewallD utility is correctly disabled or masked and inactive\" ;;\n      enabled:active:enabled:active)\n         l_output2=\"\\\\n - Both FirewallD and NFTables utilities are enabled and active\" ;;\n      enabled:*:enabled:*)\n         l_output2=\"\\\\n - Both FirewallD and NFTables utilities are enabled\" ;;\n      *:active:*:active)\n         l_output2=\"\\\\n - Both FirewallD and NFTables utilities are enabled\" ;;\n      :enabled:active)\n         l_output=\"\\\\n - NFTables utility is in use, enabled, and active\\\\n - FirewallD package is not installed\" ;;\n      :)\n         l_output2=\"\\\\n - Neither FirewallD or NFTables is installed.\" ;;\n      *:*:)\n         l_output2=\"\\\\n - NFTables package is not installed on the system\" ;;\n      *)\n         l_output2=\"\\\\n - Unable to determine firewall state\" ;;\n   esac\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\\\\n- Audit Results:\\\\n ** Pass **\\\\n$l_output\\\\n\"\n   else\n      echo -e \"\\\\n- Audit Results:\\\\n ** Fail **\\\\n$l_output2\\\\n\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_20": {
        "description": "firewalld check - active",
        "cmd": "/bin/systemctl is-active firewalld",
        "expect": "^active$"
    },
    "custom_item_21": {
        "system": "Linux",
        "description": "3.4.2.1 Ensure firewalld default zone is set",
        "info": "A firewall zone defines the trust level for a connection, interface or source address binding. This is a one to many relation, which means that a connection, interface or source can only be part of one zone, but a zone can be used for many network connections, interfaces and sources.\n\n - The default zone is the zone that is used for everything that is not explicitly bound/assigned to another zone.\n - If no zone assigned to a connection, interface or source, only the default zone is used.\n - The default zone is not always listed as being used for an interface or source as it will be used for it either way. This depends on the manager of the interfaces.\n\nConnections handled by NetworkManager are listed as NetworkManager requests to add the zone binding for the interface used by the connection. Also interfaces under control of the network service are listed also because the service requests it.\n\nNote:\n\n - A firewalld zone configuration file contains the information for a zone.\n - These are the zone description, services, ports, protocols, icmp-blocks, masquerade, forward-ports and rich language rules in an XML file format.\n - The file name has to be zone_name.xml where length of zone_name is currently limited to 17 chars.\n\n - NetworkManager binds interfaces to zones automatically\n\nBecause the default zone is the zone that is used for everything that is not explicitly bound/assigned to another zone, if FirewallD is being used, it is important for the default zone to set",
        "solution": "Run the following script to set the default zone:\n\n!/usr/bin/env bash\n\n{\n   l_zname=\"public\" # <- Update to local site zone name if desired\n   l_zone=\"\"\n   if systemctl is-enabled firewalld.service | grep -q 'enabled'; then\n      l_zone=\"$(firewall-cmd --get-default-zone)\"\n      if [ \"$l_zone\" = \"$l_zname\" ]; then\n         echo -e \"\\n - The default zone is set to: \\\\\"$l_zone\\\\\"\\n - No remediation required\"\n      elif [ -n \"$l_zone\" ]; then\n         echo -e \"\\n - The default zone is set to: \\\\\"$l_zone\\\\\"\\n - Updating default zone to: \\\\\"l_zname\\\\\"\"\n         firewall-cmd --set-default-zone=\"$l_zname\"\n      else\n         echo -e \"\\n - The default zone is set to: \\\\\"$l_zone\\\\\"\\n - Updating default zone to: \\\\\"l_zname\\\\\"\"\n         firewall-cmd --set-default-zone=\"$l_zname\"\n      fi\n   else\n      echo -e \"\\n - FirewallD is not in use on the system\\n - No remediation required\"\n   fi\n}",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/firewall-cmd --get-default-zone",
        "expect": "^@FIREWALLD_DEFAULT_ZONE@$"
    },
    "custom_item_22": {
        "description": "3.4.2.2 Ensure at least one nftables table exists",
        "info": "Tables hold chains. Each table only has one address family and only applies to packets of this family. Tables can have one of five families.\n\nWithout a table, nftables will not filter network traffic.",
        "solution": "Run the following command to create a table in nftables\n\n# nft create table inetExample if FirewallD is not in use on the system:\n\n# nft create table inet filter\n\nNote: FirewallD uses the table inet firewalld NFTables table that is created when FirewallD is installed.\n\nImpact:\n\nAdding or modifying firewall rules can cause loss of connectivity to the system",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/sbin/nft list tables | /bin/awk '{print} END { if(NR!=0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_23": {
        "description": "hook output",
        "cmd": "/sbin/nft -n list ruleset | /bin/grep 'hook output'",
        "expect": "type[\\\\s]+filter[\\\\s]+hook[\\\\s]+output[\\\\s]*"
    },
    "custom_item_24": {
        "description": "hook input",
        "cmd": "/sbin/nft -n list ruleset | /bin/grep 'hook input'",
        "expect": "type[\\\\s]+filter[\\\\s]+hook[\\\\s]+input[\\\\s]*"
    },
    "custom_item_25": {
        "description": "hook forward",
        "cmd": "/sbin/nft -n list ruleset | /bin/grep 'hook forward'",
        "expect": "type[\\\\s]+filter[\\\\s]+hook[\\\\s]+forward[\\\\s]*"
    },
    "custom_item_26": {
        "description": "3.4.2.4 Ensure host based firewall loopback traffic is configured",
        "info": "Configure the loopback interface to accept traffic. Configure all other interfaces to deny traffic to the loopback network\n\nLoopback traffic is generated between processes on machine and is typically critical to operation of the system. The loopback interface is the only place that loopback network traffic should be seen, all other interfaces should ignore traffic on this network as an anti-spoofing measure.",
        "solution": "Run the following script to implement the loopback rules:\n\n#!/usr/bin/env bash\n\n{\n   l_hbfw=\"\"\n   if systemctl is-enabled firewalld.service | grep -q 'enabled' && systemctl is-enabled nftables.service | grep -q 'enabled'; then\n      echo -e \"\\n - Error - Both FirewallD and NFTables are enabled\\n - Please follow recommendation: \\\\\"Ensure a single firewall configuration utility is in use\\\\\"\"\n   elif ! systemctl is-enabled firewalld.service | grep -q 'enabled' && ! systemctl is-enabled nftables.service | grep -q 'enabled'; then\n      echo -e \"\\n - Error - Neither FirewallD or NFTables is enabled\\n - Please follow recommendation: \\\\\"Ensure a single firewall configuration utility is in use\\\\\"\"\n   else\n      if systemctl is-enabled firewalld.service | grep -q 'enabled' && ! systemctl is-enabled nftables.service | grep -q 'enabled'; then\n         echo -e \"\\n - FirewallD is in use on the system\" && l_hbfw=\"fwd\"\n      elif ! systemctl is-enabled firewalld.service | grep -q 'enabled' && systemctl is-enabled nftables.service | grep -q 'enabled'; then\n         echo -e \"\\n - NFTables is in use on the system\" && l_hbfw=\"nft\"\n      fi\n      l_ipsaddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook\\s+input\\s+/,/\\}\\s*(#.*)?$/' | grep -P -- 'ip\\h+saddr')\"\n      if ! nft list ruleset | awk '/hook\\s+input\\s+/,/\\}\\s*(#.*)?$/' | grep -Pq -- '\\H+\\h+\"lo\"\\h+accept'; then\n         echo -e \"\\n - Enabling input to accept for loopback address\"\n         if [ \"$l_hbfw\" = \"fwd\" ]; then\n            firewall-cmd --permanent --zone=trusted --add-interface=lo\n            firewall-cmd --reload\n         elif [ \"$l_hbfw\" = \"nft\" ]; then\n            nft add rule inet filter input iif lo accept\n         fi\n      fi\n      if ! grep -Pq -- 'ip\\h+saddr\\h+127\\.0\\.0\\.0\\/8\\h+(counter\\h+packets\\h+\\d+\\h+bytes\\h+\\d+\\h+)?drop' <<< \"$l_ipsaddr\" && ! grep -Pq -- 'ip\\h+daddr\\h+\\!\\=\\h+127\\.0\\.0\\.1\\h+ip\\h+saddr\\h+127\\.0\\.0\\.1\\h+drop' <<< \"$l_ipsaddr\"; then\n         echo -e \"\\n - Setting IPv4 network traffic from loopback address to drop\"\n         if [ \"$l_hbfw\" = \"fwd\" ]; then\n            firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=\"127.0.0.1\" destination not address=\"127.0.0.1\" drop'\n            firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv4 source address=\"127.0.0.1\" destination not address=\"127.0.0.1\" drop'\n            firewall-cmd --reload\n         elif [ \"$l_hbfw\" = \"nft\" ]; then\n            nft create rule inet filter input ip saddr 127.0.0.0/8 counter drop\n         fi\n      fi\n      if grep -Pq -- '^\\h*0\\h*$' /sys/module/ipv6/parameters/disable; then\n         l_ip6saddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep 'ip6 saddr')\"\n         if ! grep -Pq 'ip6\\h+saddr\\h+::1\\h+(counter\\h+packets\\h+\\d+\\h+bytes\\h+\\d+\\h+)?drop' <<< \"$l_ip6saddr\" && ! grep -Pq -- 'ip6\\h+daddr\\h+\\!=\\h+::1\\h+ip6\\h+saddr\\h+::1\\h+drop' <<< \"$l_ip6saddr\"; then\n            echo -e \"\\n - Setting IPv6 network traffic from loopback address to drop\"\n            if [ \"$l_hbfw\" = \"fwd\" ]; then\n               firewall-cmd --permanent --add-rich-rule='rule family=ipv6 source address=\"::1\" destination not address=\"::1\" drop'\n               firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv6 source address=\"::1\" destination not address=\"::1\" drop'\n               firewall-cmd --reload\n            elif [ \"$l_hbfw\" = \"nft\" ]; then\n               nft add rule inet filter input ip6 saddr ::1 counter drop\n            fi\n         fi\n      fi\n   fi\n}",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "#!/bin/bash\n\n{\n   l_output=\"\" l_output2=\"\"\n   if nft list ruleset | awk '/hook\\\\s+input\\\\s+/,/\\\\}\\\\s*(#.*)?$/' | grep -Pq -- '\\\\H+\\\\h+\"lo\"\\\\h+accept'; then\n      l_output=\"$l_output\n - Network traffic to the loopback address is correctly set to accept\"\n   else\n      l_output2=\"$l_output2\n - Network traffic to the loopback address is not set to accept\"\n   fi\n   l_ipsaddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook\\\\s+input\\\\s+/,/\\\\}\\\\s*(#.*)?$/' | grep -P -- 'ip\\\\h+saddr')\"\n   if grep -Pq -- 'ip\\\\h+saddr\\\\h+127\\\\.0\\\\.0\\\\.0\\\\/8\\\\h+(counter\\\\h+packets\\\\h+\\\\d+\\\\h+bytes\\\\h+\\\\d+\\\\h+)?drop' <<< \"$l_ipsaddr\" || grep -Pq -- 'ip\\\\h+daddr\\\\h+\\\\!\\\\=\\\\h+127\\\\.0\\\\.0\\\\.1\\\\h+ip\\\\h+saddr\\\\h+127\\\\.0\\\\.0\\\\.1\\\\h+drop' <<< \"$l_ipsaddr\"; then\n      l_output=\"$l_output\n - IPv4 network traffic from loopback address correctly set to drop\"\n   else\n      l_output2=\"$l_output2\n - IPv4 network traffic from loopback address not set to drop\"\n   fi\n   if grep -Pq -- '^\\\\h*0\\\\h*$' /sys/module/ipv6/parameters/disable; then\n      l_ip6saddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep 'ip6 saddr')\"\n      if grep -Pq 'ip6\\\\h+saddr\\\\h+::1\\\\h+(counter\\\\h+packets\\\\h+\\\\d+\\\\h+bytes\\\\h+\\\\d+\\\\h+)?drop' <<< \"$l_ip6saddr\" || grep -Pq -- 'ip6\\\\h+daddr\\\\h+\\\\!=\\\\h+::1\\\\h+ip6\\\\h+saddr\\\\h+::1\\\\h+drop' <<< \"$l_ip6saddr\"; then\n         l_output=\"$l_output\n - IPv6 network traffic from loopback address correctly set to drop\"\n      else\n         l_output2=\"$l_output2\n - IPv6 network traffic from loopback address not set to drop\"\n      fi\n   fi\n   if [ -z \"$l_output2\" ]; then\n      echo -e \"\n- Audit Result:\n  *** PASS ***\n$l_output\"\n   else\n      echo -e \"\n- Audit Result:\n  *** FAIL ***\n$l_output2\n\n  - Correctly set:\n$l_output\"\n   fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_27": {
        "description": "firewalld check - active",
        "cmd": "/bin/systemctl is-active firewalld",
        "expect": "^active$"
    },
    "custom_item_28": {
        "description": "3.4.2.5 Ensure firewalld drops unnecessary services and ports",
        "info": "Services and ports can be accepted or explicitly rejected or dropped by a zone.\n\nFor every zone, you can set a default behavior that handles incoming traffic that is not further specified. Such behavior is defined by setting the target of the zone. There are three options - default, ACCEPT, REJECT, and DROP.\n\n - ACCEPT - you accept all incoming packets except those disabled by a specific rule.\n - REJECT - you disable all incoming packets except those that you have allowed in specific rules and the source machine is informed about the rejection.\n - DROP - you disable all incoming packets except those that you have allowed in specific rules and no information sent to the source machine.\n\nTo reduce the attack surface of a system, all services and ports should be blocked unless required\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "If Firewalld is in use on the system:\n\nRun the following command to remove an unnecessary service:\n\n# firewall-cmd --remove-service=Example:\n\n# firewall-cmd --remove-service=cockpit\n\nRun the following command to remove an unnecessary port:\n\n# firewall-cmd --remove-port=/Example:\n\n# firewall-cmd --remove-port=25/tcp\n\nRun the following command to make new settings persistent:\n\n# firewall-cmd --runtime-to-permanent",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/firewall-cmd --list-all --zone=\"$(/bin/firewall-cmd --list-all | /bin/awk '/\\\\(active\\\\)/ { print $1 }')\" | /bin/grep -P -- '^\\\\h*(services:|ports:)'",
        "expect": "^Manual Review Required$"
    },
    "custom_item_29": {
        "description": "check if nftables.service is active",
        "cmd": "/bin/systemctl is-active nftables.service",
        "expect": "^active$"
    },
    "custom_item_30": {
        "description": "nft list ruleset hook input icmp ct state",
        "cmd": "/sbin/nft list ruleset | /bin/awk '/hook input/,/}/' | grep 'ct state'",
        "expect": "^[\\\\s]*ip[\\\\s]+protocol[\\\\s]+icmp[\\\\s]+ct[\\\\s]+state[\\\\s]+established[\\\\s]+accept[\\\\s]*$"
    },
    "custom_item_31": {
        "description": "nft list ruleset hook input tcp ct state",
        "cmd": "/sbin/nft list ruleset | /bin/awk '/hook input/,/}/' | grep 'ct state'",
        "expect": "^[\\\\s]*ip[\\\\s]+protocol[\\\\s]+tcp[\\\\s]+ct[\\\\s]+state[\\\\s]+established[\\\\s]+accept[\\\\s]*$"
    },
    "custom_item_32": {
        "description": "nft list ruleset hook input udp ct state",
        "cmd": "/sbin/nft list ruleset | /bin/awk '/hook input/,/}/' | grep 'ct state'",
        "expect": "^[\\\\s]*ip[\\\\s]+protocol[\\\\s]+udp[\\\\s]+ct[\\\\s]+state[\\\\s]+established[\\\\s]+accept[\\\\s]*$"
    },
    "custom_item_33": {
        "description": "check if nftables.service is active",
        "cmd": "/bin/systemctl is-active nftables.service",
        "expect": "^active$"
    },
    "custom_item_34": {
        "description": "nft list ruleset hook forward drop",
        "cmd": "/sbin/nft list ruleset | /bin/grep 'hook forward'",
        "expect": "policy[\\\\s]*drop"
    },
    "custom_item_35": {
        "description": "nft list ruleset hook input drop",
        "cmd": "/sbin/nft list ruleset | /bin/grep 'hook input'",
        "expect": "policy[\\\\s]*drop"
    },
    "custom_item_36": {
        "description": "openssh-server is installed",
        "rpm": "openssh-server-0.0.0-0",
        "operator": "gt"
    },
    "custom_item_37": {
        "description": "sshd -T - X11Forwarding",
        "file": "/etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf",
        "regex": "^[\\\\s]*(?i)X11Forwarding(?-i)[\\\\s]",
        "expect": "^[\\\\s]*(?i)X11Forwarding(?-i)[\\\\s]+\"?yes\"?[\\\\s]*$"
    },
    "custom_item_38": {
        "description": "sshd -T - x11forwarding",
        "cmd": "#!/bin/bash\n  {\n  ports=$(/bin/grep -s -P \"^(Port|Match)\" /etc/ssh/sshd_config /etc/sshd_config.d/*.conf | /bin/grep -P -o \"(Port|LocalPort)[\\\\s]+[\\\\d]+\" | /bin/awk '{print $2}; END {if (NR == 0) print \"22\"}' | /bin/uniq); for port in ${ports[@]}; do /sbin/sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(/bin/grep $(hostname) /etc/hosts | /bin/awk '{print $1}')\" -C lport=$port | echo \"port $port: $(/bin/grep -i ^x11forwarding)\"; done | /bin/awk 'BEGIN {f=0} /x11forwarding/i { if ($NF == \"yes\") f++; print $0} END {if (NR == 0) print \"Fail: no results returned\"; else if (f > 0) print \"Fail\"; else print \"Pass\" }'\n  }",
        "expect": "^Pass$"
    },
    "custom_item_39": {
        "description": "openssh-server is installed",
        "rpm": "openssh-server-0.0.0-0",
        "operator": "gt"
    },
    "custom_item_40": {
        "description": "ssh config files - AllowTcpForwarding",
        "file": "/etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf",
        "regex": "^[\\\\s]*(?i)AllowTcpForwarding(?-i)[\\\\s]",
        "expect": "^[\\\\s]*(?i)AllowTcpForwarding(?-i)[\\\\s]+\"?yes\"?[\\\\s]*$"
    },
    "custom_item_41": {
        "description": "sshd -T - AllowTcpForwarding",
        "cmd": "#!/bin/bash\n  {\n  ports=$(/bin/grep -s -P \"^(Port|Match)\" /etc/ssh/sshd_config /etc/sshd_config.d/*.conf | /bin/grep -P -o \"(Port|LocalPort)[\\\\s]+[\\\\d]+\" | /bin/awk '{print $2}; END {if (NR == 0) print \"22\"}' | /bin/uniq); for port in ${ports[@]}; do /sbin/sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(/bin/grep $(hostname) /etc/hosts | /bin/awk '{print $1}')\" -C lport=$port | echo \"port $port: $(/bin/grep -i ^allowtcpforwarding)\"; done | /bin/awk 'BEGIN {f=0} /allowtcpforwarding/i { if ($NF == \"yes\") f++; print $0} END {if (NR == 0) print \"Fail: no results returned\"; else if (f > 0) print \"Fail\"; else print \"Pass\" }'\n  }",
        "expect": "^Pass$"
    },
    "custom_item_42": {
        "description": "5.2.1.1 Ensure auditd is installed",
        "info": "auditd is the userspace component to the Linux Auditing System. It's responsible for writing audit records to the disk\n\nThe capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring.",
        "solution": "Run the following command to Install auditd\n\n# dnf install audit",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "rpm": "audit-0.0.0-0",
        "operator": "gt"
    },
    "custom_item_43": {
        "description": "5.2.1.2 Ensure auditing for processes that start prior to auditd is enabled",
        "info": "Configure grub2 so that processes that are capable of being audited can be audited even if they start up prior to auditd startup.\n\nAudit events need to be captured on processes that start up prior to auditd so that potential malicious activity cannot go undetected.",
        "solution": "Run the following command to update the grub2 configuration with audit=1 :\n\n# grubby --update-kernel ALL --args 'audit=1'",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/sbin/grubby --info=ALL | /bin/grep -Po '\\\\baudit=1\\\\b' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_44": {
        "description": "5.2.1.3 Ensure audit_backlog_limit is sufficient",
        "info": "The backlog limit has a default setting of 64\n\nDuring boot if audit=1 then the backlog will hold 64 records. If more that 64 records are created during boot, auditd records will be lost and potential malicious activity could go undetected.",
        "solution": "Run the following command to add audit_backlog_limit=to GRUB_CMDLINE_LINUX:\n\n# grubby --update-kernel ALL --args 'audit_backlog_limit='\n\nExample:\n\n# grubby --update-kernel ALL --args 'audit_backlog_limit=8192'",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/sbin/grubby --info=ALL | /bin/grep -Po '\\\\baudit_backlog_limit=@BACKLOG_SIZE@\\\\b' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_45": {
        "description": "5.2.1.4 Ensure auditd service is enabled",
        "info": "Turn on the auditd daemon to record system events.\n\nThe capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring.",
        "solution": "Run the following command to enable auditd :\n\n# systemctl --now enable auditd",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/systemctl is-enabled auditd | /bin/awk '{print} END {if(NR==0) print \"disabled\" }'",
        "expect": "^enabled$"
    },
    "custom_item_46": {
        "description": "5.2.2.1 Ensure audit log storage size is configured",
        "info": "Configure the maximum size of the audit log file. Once the log reaches the maximum size, it will be rotated and a new log file will be started.\n\nIt is important that an appropriate size is determined for log files so that they do not impact the system and audit data is not lost.",
        "solution": "Set the following parameter in /etc/audit/auditd.conf in accordance with site policy:\n\nmax_log_file =",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "file": "/etc/audit/auditd.conf",
        "regex": "^[\\\\s]*max_log_file[\\\\s]*=",
        "expect": "^[\\\\s]*max_log_file[\\\\s]*=[\\\\s]*@MAX_AUDIT_LOG_FILE_SIZE@[\\\\s]*$"
    },
    "custom_item_47": {
        "description": "5.2.2.2 Ensure audit logs are not automatically deleted",
        "info": "The max_log_file_action setting determines how to handle the audit log file reaching the max file size. A value of keep_logs will rotate the logs but never delete old logs.\n\nIn high security contexts, the benefits of maintaining a long audit history exceed the cost of storing the audit history.",
        "solution": "Set the following parameter in /etc/audit/auditd.conf:\n\nmax_log_file_action = keep_logs",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "file": "/etc/audit/auditd.conf",
        "regex": "^[\\\\s]*max_log_file_action[\\\\s]*=",
        "expect": "^[\\\\s]*max_log_file_action[\\\\s]*=[\\\\s]*(?i)keep_logs(?-i)[\\\\s]*$"
    },
    "custom_item_48": {
        "description": "auditd.conf - space_left_action",
        "file": "/etc/audit/auditd.conf",
        "regex": "^[\\\\s]*(?i)space_left_action(?-i)[\\\\s]*=[\\\\s]*",
        "expect": "^[\\\\s]*(?i)space_left_action(?-i)[\\\\s]*=[\\\\s]*(?i)email(?-i)[\\\\s]*$"
    },
    "custom_item_49": {
        "description": "auditd.conf - action_mail_acct",
        "file": "/etc/audit/auditd.conf",
        "regex": "^[\\\\s]*(?i)action_mail_acct(?-i)[\\\\s]*=",
        "expect": "^[\\\\s]*(?i)action_mail_acct(?-i)[\\\\s]*=[\\\\s]*(?i)root(?-i)[\\\\s]*$"
    },
    "custom_item_50": {
        "description": "auditd.conf - admin_space_left_action",
        "file": "/etc/audit/auditd.conf",
        "regex": "^[\\\\s]*admin_space_left_action[\\\\s]*=",
        "expect": "^[\\\\s]*admin_space_left_action[\\\\s]*=[\\\\s]*(?i)(halt|single)(?-i)[\\\\s]*$"
    },
    "custom_item_51": {
        "description": "auditctl /etc/sudoers",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sudoers/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_52": {
        "description": "/etc/sudoers.d",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sudoers\\\\.d/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_53": {
        "description": "/etc/sudoers",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sudoers/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_54": {
        "description": "auditctl /etc/sudoers.d",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sudoers\\\\.d/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_55": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_56": {
        "description": "auditctl b64",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_57": {
        "description": "b32",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_58": {
        "description": "b64",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_59": {
        "description": "auditctl b32",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_60": {
        "description": "b32",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_61": {
        "description": "auditctl b32",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_62": {
        "description": "auditctl utmp",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/  &&/\\\\/var\\\\/run\\\\/utmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "pass"
    },
    "custom_item_63": {
        "description": "utmp",
        "cmd": "/bin/awk '/^ *-w/  &&/\\\\/var\\\\/run\\\\/utmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "pass"
    },
    "custom_item_64": {
        "description": "auditctl wtmp",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/  &&/\\\\/var\\\\/log\\\\/wtmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "pass"
    },
    "custom_item_65": {
        "description": "btmp",
        "cmd": "/bin/awk '/^ *-w/  &&/\\\\/var\\\\/log\\\\/btmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "pass"
    },
    "custom_item_66": {
        "description": "auditctl btmp",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/  &&/\\\\/var\\\\/log\\\\/btmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "pass"
    },
    "custom_item_67": {
        "description": "wtmp",
        "cmd": "/bin/awk '/^ *-w/  &&/\\\\/var\\\\/log\\\\/wtmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "pass"
    },
    "custom_item_68": {
        "description": "auditctl faillock",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ && /\\\\/var\\\\/run\\\\/faillock/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_69": {
        "description": "faillock",
        "cmd": "/bin/awk '/^ *-w/ && /\\\\/var\\\\/run\\\\/faillock/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_70": {
        "description": "lastlog",
        "cmd": "/bin/awk '/^ *-w/ && /\\\\/var\\\\/log\\\\/lastlog/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_71": {
        "description": "auditctl lastlog",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ && /\\\\/var\\\\/log\\\\/lastlog/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' ",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_72": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_73": {
        "description": "b32 unlink",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_74": {
        "description": "auditctl b64 unlink",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b64/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_75": {
        "description": "auditctl b32 unlink",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_76": {
        "description": "b64 unlink",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b64/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_77": {
        "description": "b32 unlink",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_78": {
        "description": "auditctl b32 unlink",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_79": {
        "description": "*.rules /etc/selinux",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_80": {
        "description": "*.rules /usr/share/selinux",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/usr\\\\/share\\\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_81": {
        "description": "auditctl /etc/selinux",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_82": {
        "description": "auditctl /usr/share/selinux",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/usr\\\\/share\\\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_83": {
        "description": "/etc/audit/rules.d/*.rules",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/bin\\\\/chcon/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_84": {
        "description": "auditctl",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/bin\\\\/chcon/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_85": {
        "description": "/etc/audit/rules.d/*.rules",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/bin\\\\/setfacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_86": {
        "description": "auditctl",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/bin\\\\/setfacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_87": {
        "description": "/etc/audit/rules.d/*.rules",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/bin\\\\/chacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_88": {
        "description": "auditctl",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/bin\\\\/chacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_89": {
        "description": "/etc/audit/rules.d/*.rules",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/sbin\\\\/usermod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_90": {
        "description": "auditctl",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\\\/usr\\\\/sbin\\\\/usermod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\\\n \"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_91": {
        "description": "auditctl create_module",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/create_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "pass"
    },
    "custom_item_92": {
        "description": "/usr/bin/kmod",
        "cmd": "{\n UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) \\\\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\\\n &&/ -F *auid>=${UID_MIN}/ \\\\\n &&/ -F *perm=x/ \\\\\n &&/ -F *path=\\\\/usr\\\\/bin\\\\/kmod/ \\\\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"\n} | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_93": {
        "description": "auditctl delete_module",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/delete_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_94": {
        "description": "on disk init_module",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/init_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_95": {
        "description": "auditctl query_module",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/query_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_96": {
        "description": "on disk finit_module",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/finit_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_97": {
        "description": "on disk query_module",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/query_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_98": {
        "description": "on disk create_module",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/create_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_99": {
        "description": "kmod symlinks",
        "cmd": "#!/bin/bash\n      {\n        S_LINKS=$(ls -l /usr/sbin/lsmod /usr/sbin/rmmod /usr/sbin/insmod /usr/sbin/modinfo /usr/sbin/modprobe /usr/sbin/depmod | grep -vE \" -> (\\\\.\\\\.)?/bin/kmod\" || true) && if [[ \"${S_LINKS}\" != \"\" ]]; then printf \"Issue with symlinks: ${S_LINKS}\\\\n\"; else printf \"OK\\\\n\"; fi\n      }",
        "expect": "^OK$"
    },
    "custom_item_100": {
        "description": "auditctl /usr/bin/kmod",
        "cmd": "{\nUID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) \\\\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\\\n &&/ -F *auid>=${UID_MIN}/ \\\\\n &&/ -F *perm=x/ \\\\\n &&/ -F *path=\\\\/usr\\\\/bin\\\\/kmod/ \\\\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"\n} | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_101": {
        "description": "auditctl init_module",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/init_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_102": {
        "description": "on disk delete_module",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/delete_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_103": {
        "description": "auditctl finit_module",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/finit_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_104": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_105": {
        "description": "/etc/audit/rules.d/*.rules b32",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_106": {
        "description": "auditctl b64",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_107": {
        "description": "/etc/audit/rules.d/*.rules b64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_108": {
        "description": "auditctl b32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_109": {
        "description": "/etc/audit/rules.d/*.rules b32",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_110": {
        "description": "auditctl b32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_111": {
        "description": "5.2.3.20 Ensure the audit configuration is immutable",
        "info": "Set system audit so that audit rules cannot be modified with auditctl Setting the flag \"-e 2\" forces audit to be put in immutable mode. Audit changes can only be made on system reboot.\n\nNote: This setting will require the system to be rebooted to update the active auditd configuration settings.\n\nIn immutable mode, unauthorized users cannot execute changes to the audit system to potentially hide malicious activity and then put the audit rules back. Users would most likely notice a system reboot and that could alert administrators of an attempt to make unauthorized audit changes.",
        "solution": "Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line -e 2 at the end of the file:\n\nExample:\n\n# printf -- \"-e 2\" >> /etc/audit/rules.d/99-finalize.rules\n\nLoad audit rules\n\nMerge and load the rules into active configuration:\n\n# augenrules --load\n\nCheck if reboot is required.\n\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,800-53r5|MP-2,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(b),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|6.2,CSCv7|6.3,CSCv8|3.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-2,CSF|PR.PT-3,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T3.6.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,SWIFT-CSCv1|6.4,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/grep -Ph -- '^\\\\h*-e\\\\h+2\\\\b' /etc/audit/rules.d/*.rules | tail -1",
        "expect": "^[\\\\s]*-e[\\\\s]+2[\\\\s]*$"
    },
    "custom_item_112": {
        "description": "5.2.3.21 Ensure the running and on disk configuration is the same",
        "info": "The Audit system have both on disk and running configuration. It is possible for these configuration settings to differ.\n\nNote: Due to the limitations of augenrules and auditctl it is not absolutely guaranteed that loading the rule sets via augenrules --load will result in all rules being loaded or even that the user will be informed if there was a problem loading the rules.\n\nConfiguration differences between what is currently running and what is on disk could cause unexpected problems or may give a false impression of compliance requirements.",
        "solution": "If the rules are not aligned across all three () areas, run the following command to merge and load all rules:\n\n# augenrules --load\n\nCheck if reboot is required.\n\nif [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then echo \"Reboot required to load rules\"; fi",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/sbin/augenrules --check",
        "expect": "^[\\\\s]*/sbin/augenrules:[\\\\s]*No change[\\\\s]*$"
    },
    "custom_item_113": {
        "description": "sudo log",
        "cmd": "SUDO_LOG_FILE_ESCAPED=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\\\\\/|g'); [ -n \"${SUDO_LOG_FILE_ESCAPED}\" ] && awk \"/^ *-w/ &&/\"${SUDO_LOG_FILE_ESCAPED}\"/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_114": {
        "description": "auditctl sudo log",
        "cmd": "SUDO_LOG_FILE_ESCAPED=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\\\\\/|g'); [ -n \"${SUDO_LOG_FILE_ESCAPED}\" ] && auditctl -l | /bin/awk \"/^ *-w/ &&/\"${SUDO_LOG_FILE_ESCAPED}\"/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_115": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_116": {
        "description": "auditctl clock_settime x32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_117": {
        "description": "auditctl clock_settime x32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_118": {
        "description": "adjtimex x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_119": {
        "description": "adjtimex x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_120": {
        "description": "settimeofday x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_121": {
        "description": "settimeofday x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_122": {
        "description": "auditctl settimeofday x32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_123": {
        "description": "auditctl settimeofday x32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_124": {
        "description": "/etc/localtime",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_125": {
        "description": "clock_settime x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_126": {
        "description": "clock_settime x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_127": {
        "description": "auditctl /etc/localtime",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_128": {
        "description": "auditctl adjtimex x64",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_129": {
        "description": "auditctl adjtimex x64",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_130": {
        "description": "auditctl clock_settime x32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_131": {
        "description": "adjtimex x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_132": {
        "description": "settimeofday x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_133": {
        "description": "auditctl settimeofday x32",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_134": {
        "description": "/etc/localtime",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_135": {
        "description": "clock_settime x64",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_136": {
        "description": "auditctl /etc/localtime",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_137": {
        "description": "auditctl adjtimex x64",
        "cmd": "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_138": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_139": {
        "description": "auditctl /etc/issue",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_140": {
        "description": "/etc/issue.net",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_141": {
        "description": "auditctl b64 sethostname",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_142": {
        "description": "/etc/issue",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_143": {
        "description": "auditctl b32 sethostname",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_144": {
        "description": "/etc/sysconfig/network-scripts",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_145": {
        "description": "auditctl /etc/issue.net",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_146": {
        "description": "auditctl /etc/sysconfig/network-scripts",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_147": {
        "description": "/etc/sysconfig/network",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_148": {
        "description": "b32 sethostname",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_149": {
        "description": "auditctl /etc/hosts",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_150": {
        "description": "b64 sethostname",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_151": {
        "description": "auditctl /etc/sysconfig/network",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_152": {
        "description": "/etc/hosts",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_153": {
        "description": "auditctl /etc/issue",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_154": {
        "description": "/etc/issue.net",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_155": {
        "description": "/etc/issue",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_156": {
        "description": "auditctl b32 sethostname",
        "cmd": "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_157": {
        "description": "/etc/sysconfig/network-scripts",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_158": {
        "description": "auditctl /etc/issue.net",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_159": {
        "description": "auditctl /etc/sysconfig/network-scripts",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_160": {
        "description": "/etc/sysconfig/network",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_161": {
        "description": "b32 sethostname",
        "cmd": "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_162": {
        "description": "auditctl /etc/hosts",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_163": {
        "description": "auditctl /etc/sysconfig/network",
        "cmd": "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/sysconfig\\\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_164": {
        "description": "/etc/hosts",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_165": {
        "description": "auditctl",
        "cmd": "RUNNING=$(/sbin/auditctl -l); [ -n \"${RUNNING}\" ] && for PARTITION in $(/bin/findmnt -n -l -k -it $(/bin/awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | /bin/grep -Pv \"noexec|nosuid\" | /bin/awk '{print $1}'); do for PRIVILEGED in $(/bin/find \"${PARTITION}\" -xdev -perm /6000 -type f); do printf -- \"${RUNNING}\" | /bin/grep -q \"${PRIVILEGED}\" && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\\\n\" || printf \"Warning: '${PRIVILEGED}' not found in running configuration.\\\\n\"; done; done | /bin/awk '{print} END { if ($1 ~ \"Warning\") print \"Fail - Warnings found\"; else print \"Pass - No warning entries found\" }'",
        "expect": "^Pass - No warning entries found$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_166": {
        "description": "/etc/audit/rules.d",
        "cmd": "for PARTITION in $(/bin/findmnt -n -l -k -it $(/bin/awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | /bin/grep -Pv \"noexec|nosuid\" | /bin/awk '{print $1}'); do for PRIVILEGED in $(/bin/find \"${PARTITION}\" -xdev -perm /6000 -type f); do /bin/grep -qr \"${PRIVILEGED}\" /etc/audit/rules.d && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\\\n\" || printf \"Warning: '${PRIVILEGED}' not found in on disk configuration.\\\\n\"; done; done | /bin/awk '{print} END { if ($1 ~ \"Warning\") print \"Fail - Warnings found\"; else print \"Pass - No warning entries found\" }'",
        "expect": "^Pass - No warning entries found$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_167": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_168": {
        "description": "auditctl b32 EPERM",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_169": {
        "description": "auditctl b64 EACCES",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_170": {
        "description": "auditctl b64 EPERM",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_171": {
        "description": "auditctl b32 EACCES",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_172": {
        "description": "b64 EPERM",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_173": {
        "description": "b32 EACCES",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_174": {
        "description": "b32 EPERM",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_175": {
        "description": "b64 EACCES",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_176": {
        "description": "auditctl b32 EPERM",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_177": {
        "description": "auditctl b32 EACCES",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_178": {
        "description": "b32 EACCES",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_179": {
        "description": "b32 EPERM",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_180": {
        "description": "/etc/shadow",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/shadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_181": {
        "description": "/etc/gshadow",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/gshadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_182": {
        "description": "/etc/group",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/group/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_183": {
        "description": "/etc/passwd",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/passwd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_184": {
        "description": "auditctl /etc/security/opasswd",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/security\\\\/opasswd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_185": {
        "description": "auditctl /etc/group",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/group/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_186": {
        "description": "auditctl /etc/shadow",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/shadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_187": {
        "description": "auditctl /etc/passwd",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/passwd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_188": {
        "description": "/etc/security/opasswd",
        "cmd": "/bin/awk '/^ *-w/ &&/\\\\/etc\\\\/security\\\\/opasswd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_189": {
        "description": "auditctl /etc/gshadow",
        "cmd": "auditctl -l | /bin/awk '/^ *-w/ &&/\\\\/etc\\\\/gshadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_190": {
        "description": "OS 64bit check",
        "cmd": "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'",
        "expect": "^found$"
    },
    "custom_item_191": {
        "description": "auditctl b32 setxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_192": {
        "description": "b64 fchownat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_193": {
        "description": "auditctl b32 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_194": {
        "description": "auditctl b64 chmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_195": {
        "description": "auditctl b32 chmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_196": {
        "description": "b32 lremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_197": {
        "description": "auditctl b32 fremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_198": {
        "description": "b64 fsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_199": {
        "description": "auditctl b32 fchmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_200": {
        "description": "auditctl b64 fremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_201": {
        "description": "auditctl b64 chown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_202": {
        "description": "b64 fchmodat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_203": {
        "description": "b32 fchmodat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_204": {
        "description": "auditctl b64 fsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_205": {
        "description": "b32 fsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_206": {
        "description": "auditctl b64 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_207": {
        "description": "b32 fchmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_208": {
        "description": "b64 lremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_209": {
        "description": "auditctl b32 fchmodat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_210": {
        "description": "b64 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_211": {
        "description": "b64 setxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_212": {
        "description": "b64 fremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_213": {
        "description": "b64 removexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_214": {
        "description": "b32 lchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_215": {
        "description": "auditctl b64 lsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_216": {
        "description": "auditctl b32 removexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_217": {
        "description": "auditctl b64 fchmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_218": {
        "description": "b32 setxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_219": {
        "description": "auditctl b32 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_220": {
        "description": "auditctl b32 chown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_221": {
        "description": "b32 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_222": {
        "description": "b64 fchmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_223": {
        "description": "b32 chown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_224": {
        "description": "b32 fremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_225": {
        "description": "auditctl b32 lsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_226": {
        "description": "auditctl b32 removexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_227": {
        "description": "b32 chmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_228": {
        "description": "auditctl b64 removexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_229": {
        "description": "auditctl b64 fchmodat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_230": {
        "description": "auditctl b64 lchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_231": {
        "description": "auditctl b32 lchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_232": {
        "description": "auditctl b64 lremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_233": {
        "description": "b32 fchownat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_234": {
        "description": "auditctl b64 fchownat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_235": {
        "description": "auditctl b32 lremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_236": {
        "description": "b64 chown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_237": {
        "description": "auditctl b32 fsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_238": {
        "description": "b64 lchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_239": {
        "description": "auditctl b64 setxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_240": {
        "description": "auditctl b64 lsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_241": {
        "description": "b64 chmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_242": {
        "description": "auditctl b32 lsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_243": {
        "description": "auditctl b32 setxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_244": {
        "description": "auditctl b32 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_245": {
        "description": "auditctl b32 chmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_246": {
        "description": "b32 lremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_247": {
        "description": "auditctl b32 fremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_248": {
        "description": "auditctl b32 fchmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_249": {
        "description": "b32 fchmodat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_250": {
        "description": "b32 fsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_251": {
        "description": "b32 fchmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_252": {
        "description": "auditctl b32 fchmodat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_253": {
        "description": "b32 lchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_254": {
        "description": "auditctl b32 removexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_255": {
        "description": "b32 setxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_256": {
        "description": "auditctl b32 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_257": {
        "description": "auditctl b32 chown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_258": {
        "description": "b32 fchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_259": {
        "description": "b32 chown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_260": {
        "description": "b32 fremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_261": {
        "description": "auditctl b32 lsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_262": {
        "description": "auditctl b32 removexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_263": {
        "description": "b32 chmod",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_264": {
        "description": "auditctl b32 lchown",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_265": {
        "description": "b32 fchownat",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_266": {
        "description": "auditctl b32 lremovexattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_267": {
        "description": "auditctl b32 fsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_268": {
        "description": "auditctl b32 lsetxattr",
        "cmd": "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_269": {
        "description": "5.2.4.1 Ensure audit log files are mode 0640 or less permissive",
        "info": "Audit log files contain information about the system and system activity.\n\nAccess to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality.",
        "solution": "Run the following command to remove more permissive mode than 0640 from audit log files:\n\n# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f \\( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \\) -exec chmod u-x,g-wx,o-rwx {} +",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "[ -f /etc/audit/auditd.conf ] && /bin/find \"$(dirname $(awk -F \"=\" '/^\\\\s*log_file/ {print $2}' /etc/audit/auditd.conf | /bin/xargs))\" -type f \\\\( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \\\\) -exec /bin/stat -Lc \"%n %#a\" {} + | /bin/awk '{print} END { if(NR==0) print \"pass\"; else print \"fail\"}'",
        "expect": "^pass$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_270": {
        "description": "5.2.4.10 Ensure audit tools belong to group root",
        "info": "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.\n\nProtecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information.",
        "solution": "Run the following command to remove more permissive mode from the audit tools:\n\n# chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules\n\nRun the following command to change owner and group of the audit tools to root user and group:\n\n# chown root:root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "file": "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules",
        "owner": "root",
        "mask": "022",
        "group": "root"
    },
    "custom_item_271": {
        "description": "5.2.4.2 Ensure only authorized users own audit log files",
        "info": "Audit log files contain information about the system and system activity.\n\nAccess to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality.",
        "solution": "Run the following command to configure the audit log files to be owned by the root user:\n\n# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f ! -user root -exec chown root {} +",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "[ -f /etc/audit/auditd.conf ] && /bin/find \"$(dirname $(/bin/awk -F \"=\" '/^\\\\s*log_file/ {print $2}' /etc/audit/auditd.conf | /bin/xargs))\" -type f ! -user root -exec stat -Lc \"%n %U\" {} + | /bin/awk '{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}'",
        "expect": "^pass$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_272": {
        "description": "Verify if the audit log files are owned by the root or adm group",
        "cmd": "/bin/stat -c \"%n %G\" \"$(dirname $(/bin/awk -F\"=\" '/^[\\\\s]*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\"/* | /bin/grep -Pv '^\\\\h*\\\\H+\\\\h+(adm|root)\\\\b' | /bin/awk \\'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\\'",
        "expect": "^pass$"
    },
    "custom_item_273": {
        "description": "auditd.conf matches log_group = adm or log_group = root",
        "file": "/etc/audit/auditd.conf",
        "regex": "(?i)^[\\\\s]*log_group[\\\\s]*=",
        "expect": "(?i)^[\\\\s]*log_group[\\\\s]*=[\\\\s]*(adm|root)[\\\\s]*$"
    },
    "custom_item_274": {
        "description": "5.2.4.4 Ensure the audit log directory is 0750 or more restrictive",
        "info": "The audit log directory contains audit log files.\n\nAudit information includes all information including: audit records, audit settings and audit reports. This information is needed to successfully audit system activity. This information must be protected from unauthorized modification or deletion. If this information were to be compromised, forensic analysis and discovery of the true source of potentially malicious system activity is impossible to achieve.",
        "solution": "Run the following command to configure the audit log directory to have a mode of \"0750\" or less permissive:\n\n# chmod g-w,o-rwx \"$(dirname $( awk -F\"=\" '/^\\s*log_file\\s*=\\s*/ {print $2}' /etc/audit/auditd.conf))\"",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/stat -Lc \"%n %a\" \"$(dirname $( /bin/awk -F\"=\" '/^\\\\s*log_file\\\\s*=\\\\s*/ {print $2}' /etc/audit/auditd.conf))\" | /bin/grep -Pv -- '^\\\\h*\\\\H+\\\\h+([0-7][0,1,4,5]0)' | /bin/awk \\'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\\'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
    },
    "custom_item_275": {
        "description": "5.2.4.5 Ensure audit configuration files are 640 or more restrictive",
        "info": "Audit configuration files control auditd and what events are audited.\n\nAccess to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.\n\nMisconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident.",
        "solution": "Run the following command to remove more permissive mode than 0640 from the audit configuration files:\n\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) -exec chmod u-x,g-wx,o-rwx {} +",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/find /etc/audit/ -type f \\\\( -name '*.conf' -o -name '*.rules' \\\\) -exec /bin/stat -Lc \"%n %a\" {} + | /bin/grep -Pv -- '^\\\\h*\\\\H+\\\\h*([0,2,4,6][0,4]0)\\\\h*$' | /bin/awk \\'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\\'",
        "expect": "^pass$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_276": {
        "description": "5.2.4.6 Ensure audit configuration files are owned by root",
        "info": "Audit configuration files control auditd and what events are audited.\n\nAccess to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.\n\nMisconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident.",
        "solution": "Run the following command to change ownership to root user:\n\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -user root -exec chown root {} +",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/find /etc/audit/ -type f \\\\( -name '*.conf' -o -name '*.rules' \\\\) ! -user root | /bin/awk \\'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\\'",
        "expect": "^pass$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_277": {
        "description": "5.2.4.7 Ensure audit configuration files belong to group root",
        "info": "Audit configuration files control auditd and what events are audited.\n\nAccess to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.\n\nMisconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident.",
        "solution": "Run the following command to change group to root :\n\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -group root -exec chgrp root {} +",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/find /etc/audit/ -type f \\\\( -name '*.conf' -o -name '*.rules' \\\\) ! -group root | /bin/awk \\'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\\'",
        "expect": "^pass$",
        "timeout": "@FIND_TIMEOUT@"
    },
    "custom_item_278": {
        "description": "5.2.4.8 Ensure audit tools are 755 or more restrictive",
        "info": "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.\n\nProtecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information.",
        "solution": "Run the following command to remove more permissive mode from the audit tools:\n\n# chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "file": "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules",
        "owner": "root",
        "mask": "022",
        "group": "root"
    },
    "custom_item_279": {
        "description": "5.2.4.9 Ensure audit tools are owned by root",
        "info": "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.\n\nProtecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information.",
        "solution": "Run the following command to change the owner of the audit tools to the root user:\n\n# chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "file": "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules",
        "owner": "root",
        "mask": "022",
        "group": "root"
    },
    "custom_item_280": {
        "description": "6.1.10 Audit system file permissions",
        "info": "The RPM package manager has a number of useful options. One of these, the -V for RPM option, can be used to verify that system packages are correctly installed. The -V option can be used to verify a particular package or to verify all system packages. If no output is returned, the package is installed correctly. The following table describes the meaning of output from the verify option:\n\nCode Meaning\nS File size differs.\nM File mode differs (includes permissions and file type).\n5 The MD5 checksum differs.\nD The major and minor version numbers differ on a device file.\nL A mismatch occurs in a link.\nU The file ownership differs.\nG The file group owner differs.\nT The file time (mtime) differs.\n\nThe rpm -qf command can be used to determine which package a particular file belongs to. For example, the following commands determines which package the /bin/bash file belongs to:\n\n# rpm -qf /bin/bash\nbash-4.1.2-29.el6.x86_64\n# rpm -S /bin/bash\nbash: /bin/bash\n\nTo verify the settings for the package that controls the /bin/bash file, run the following:\n\n# rpm -V bash-4.1.2-29.el6.x86_64\n.M....... /bin/bash\n# rpm --verify bash\n??5?????? c /etc/bash.bashrc\n\nNote that you can feed the output of the rpm -qf command to the rpm -V command:\n\n# rpm -V `rpm -qf /etc/passwd`\n.M...... c /etc/passwd\nS.5....T c /etc/printcap\n\nIt is important to confirm that packaged system files and directories are maintained with the permissions they were intended to have from the OS vendor.",
        "solution": "Correct any discrepancies found and rerun the audit until output is clean or risk is mitigated or accepted.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/12705",
        "cmd": "/bin/rpm -Va --nomtime --nosize --nomd5 --nolinkto | /bin/awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    }
}