{
    "custom_item_1": {
        "description": "Check if this is a Docker Vessel/Host",
        "cmd": "/usr/bin/docker info",
        "expect": "Containers"
    },
    "custom_item_2": {
        "description": "1.1.1 Ensure a separate partition for containers has been created",
        "info": "All Docker containers and their data and metadata is stored under /var/lib/docker directory. By default, /var/lib/docker should be mounted under either the / or /var partitions dependent on how the Linux operating system in use is configured.\n\nRationale:\n\nDocker depends on /var/lib/docker as the default directory where all Docker related files, including the images, are stored. This directory could fill up quickly causing both Docker and the host to become unusable. For this reason, you should create a separate partition (logical volume) for storing Docker files.\n\nImpact:\n\nNone.",
        "solution": "For new installations, you should create a separate partition for the /var/lib/docker mount point. For systems which have already been installed, you should use the Logical Volume Manager (LVM) within Linux to create a new partition.\n\nDefault Value:\n\nBy default, /var/lib/docker is mounted under the / or /var partitions dependent on how the OS is configured.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|14,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/proc/mounts",
        "regex": "^[\\\\s]*.*[\\\\s]+/var/lib/docker[\\\\s]",
        "expect": "^[\\\\s]*.*[\\\\s]+/var/lib/docker[\\\\s]"
    },
    "custom_item_3": {
        "description": "1.1.2 Ensure only trusted users are allowed to control Docker daemon",
        "info": "The Docker daemon currently requires access to the Docker socket which is, by default, owned by the user root and the group docker.\n\nRationale:\n\nDocker allows you to share a directory between the Docker host and a guest container without limiting the access rights of the container. This means that you can start a container and map the / directory on your host to the container. The container would then be able to modify your host file system without any restrictions. This means that you could gain elevated privileges simply by being a member of the docker group and subsequently start a container which maps the root / directory on the host.\n\nImpact:\n\nProvided the proceeding instructions are implemented, rights to build and execute containers as normal user would be restricted.",
        "solution": "You should remove any untrusted users from the docker group. Additionally, you should not create a mapping of sensitive directories from the host to container volumes.\n\nDefault Value:\n\nNot Applicable",
        "reference": "800-171|3.1.1,800-171|3.5.2,800-171|3.5.5,800-171|3.5.6,800-53|AC-1,800-53|AC-2,800-53|IA-4,800-53|IA-5,800-53r5|AC-1,800-53r5|AC-2,800-53r5|IA-4,800-53r5|IA-5,CN-L3|7.1.2.7(b),CN-L3|7.1.3.2(d),CN-L3|8.1.4.2(e),CN-L3|8.1.10.6(c),CSCv7|4,CSCv8|6.1,CSF|DE.CM-1,CSF|DE.CM-3,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),ISO/IEC-27001|A.9.1.1,ISO/IEC-27001|A.9.2.1,ITSG-33|AC-1,ITSG-33|AC-2,ITSG-33|IA-4,ITSG-33|IA-5,LEVEL|1M,NESA|M1.2.2,NESA|T5.2.3,NIAv2|AM28,NIAv2|AM29,NIAv2|AM30,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2,SWIFT-CSCv1|5",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "getent group docker",
        "expect": "docker:.*?:.*?:@DOCKER_GROUP_USERS@"
    },
    "custom_item_4": {
        "description": "1.1.3 Ensure auditing is configured for the Docker daemon",
        "info": "Audit all Docker daemon activities.\n\nRationale:\n\nAs well as auditing the normal Linux file system and system calls, you should also audit the Docker daemon. Because this daemon runs with root privileges. It is very important to audit its activities and usage.\n\nImpact:\n\nAuditing can generate large log files. You should ensure that these are rotated and archived periodically. A separate partition should also be created for audit logs to avoid filling up any other critical partition.",
        "solution": "You should add rules for the Docker daemon.\nFor example:\nAdd the line below to the /etc/audit/rules.d/audit.rules file:\n\n-w /usr/bin/dockerd -k docker\n\nThen, restart the audit daemon using the following command\n\nsystemctl restart auditd\n\nDefault Value:\n\nBy default, the Docker daemon is not audited.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "auditctl -l | grep /usr/bin/dockerd",
        "expect": "-w /usr/bin/dockerd[\\\\s]+"
    },
    "custom_item_5": {
        "description": "1.1.4 Ensure auditing is configured for Docker files and directories - /run/containerd",
        "info": "Audit /run/containerd.\n\nRationale:\n\nAs well as auditing the normal Linux file system and system calls, you should also audit all Docker related files and directories. The Docker daemon runs with root privileges and its behaviour depends on some key files and directories. /run/containerd is one such directory. As it holds all the information about containers it should be audited.\n\nImpact:\n\nAuditing can generate large log files. You should ensure that these are rotated and archived periodically. A separate partition should also be created for audit logs to avoid filling up any other critical partition.",
        "solution": "You should add a rule for the /run/containerd directory.\nFor example,\nAdd the line as below to the /etc/audit/rules.d/audit.rules file:\n\n-a exit,always -F path=/run/containerd -F perm=war -k docker\n\nThen, restart the audit daemon using the following command\n\nsystemctl restart auditd\n\nDefault Value:\n\nBy default, Docker related files and directories are not audited.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,LEVEL|2M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "auditctl -l | grep /run/containerd",
        "expect": "-w /run/containerd[\\\\s]+"
    },
    "custom_item_6": {
        "description": "1.1.5 Ensure auditing is configured for Docker files and directories - /var/lib/docker",
        "info": "Audit /var/lib/docker.\n\nRationale:\n\nAs well as auditing the normal Linux file system and system calls, you should also audit all Docker related files and directories. The Docker daemon runs with root privileges and its behaviour depends on some key files and directories. /var/lib/docker is one such directory. As it holds all the information about containers it should be audited.\n\nImpact:\n\nAuditing can generate large log files. You should ensure that these are rotated and archived periodically. A separate partition should also be created for audit logs to avoid filling up any other critical partition.",
        "solution": "You should add a rule for the /var/lib/docker directory.\nFor example,\nAdd the line as below to the /etc/audit/rules.d/audit.rules file:\n\n-a exit,always -F path=/var/lib/docker -F perm=war -k docker\n\nThen, restart the audit daemon using the following command\n\nsystemctl restart auditd\n\nDefault Value:\n\nBy default, Docker related files and directories are not audited.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,LEVEL|2M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "auditctl -l | grep /var/lib/docker",
        "expect": "-w /var/lib/docker[\\\\s]+"
    },
    "custom_item_7": {
        "description": "1.1.6 Ensure auditing is configured for Docker files and directories - /etc/docker",
        "info": "Audit /etc/docker.\n\nRationale:\n\nAs well as auditing the normal Linux file system and system calls, you should also audit all Docker related files and directories. The Docker daemon runs with root privilege and its behavior depends on some key files and directories, one of these being /etc/docker. This holds various certificates and keys used for TLS communication between Docker daemon and Docker client and as such it should be audited.\n\nImpact:\n\nAuditing can generate large log files. You should ensure that these are rotated and archived periodically. A separate partition should also be created for audit logs to avoid filling up any other critical partition.",
        "solution": "You should add a rule for the /etc/docker directory.\nFor example:\nAdd the line below to the /etc/audit/rules.d/audit.rules file:\n\n-w /etc/docker -k docker\n\nThen restart the audit daemon. For example:\n\nsystemctl restart auditd\n\nDefault Value:\n\nBy default, Docker related files and directories are not audited.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "auditctl -l | grep /etc/docker",
        "expect": "-w /etc/docker[\\\\s]+"
    },
    "custom_item_8": {
        "description": "1.2.2 Ensure that the version of Docker is up to date",
        "info": "Frequent releases for Docker are issued which address security vulnerabilities, resolve product bugs and bring in new functionality. You should keep a tab on these product updates and upgrade as frequently as possible in line with the general IT security policy of your organization.\n\nRationale:\n\nBy staying up to date on Docker updates, vulnerabilities in the software can be mitigated. An experienced attacker may be able to exploit known vulnerabilities resulting in them being able to attain inappropriate access or to elevate their privileges. If you do not ensure that Docker is running at the most current release consistent with the requirements of of your application, you may introduce unwanted behaviour and it is therefore important to ensure that you monitor software versions and upgrade in a timely fashion.\n\nImpact:\n\nYou should perform a risk assessment regarding Docker version updates and review how they may impact your operations. You should be aware that third-party products that use Docker may require older major versions of Docker to be supported, and this should be reviewed in line with the general IT security policy of your organization, particularly where security vulnerabilities in older versions have been publicly disclosed.",
        "solution": "You should monitor versions of Docker releases and make sure your software is updated as required.\n\nDefault Value:\n\nNot Applicable",
        "reference": "800-171|3.14.1,800-53|SI-2c.,800-53r5|SI-2c.,CN-L3|8.1.4.4(e),CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3,CSCv8|16.5,CSF|ID.RA-1,CSF|PR.IP-12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SI-2,LEVEL|1M,LEVEL|2M,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|SS14b,PCI-DSSv3.2.1|6.2,PCI-DSSv4.0|6.3,PCI-DSSv4.0|6.3.3,QCSC-v1|11.2,SWIFT-CSCv1|2.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker version --format '{{ .Server.Version }}'",
        "expect": "@DOCKER_VERSION@"
    },
    "custom_item_9": {
        "description": "2.1 Run the Docker daemon as a non-root user, if possible",
        "info": "Rootless mode executes the Docker daemon and containers inside a user namespace, with both the daemon and the container are running without root privileges.\n\nRationale:\n\nRootless mode allows running the Docker daemon and containers as a non-root user to mitigate potential vulnerabilities in the daemon and the container runtime.\n\nImpact:\n\nThere are multiple prerequisites depending on which distribution that is in use, and also known limitations regarding networking and resource limitation.\n\nRunning in rootless mode also changes the location of any configuration files in use, including all containers using the daemon.",
        "solution": "Follow the current Docker documentation on how to install the Docker daemon as a non-root user.\n\nDefault Value:\n\nThe Docker daemon is running as the root user by default.",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|4,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "ps -fe | grep 'dockerd' | grep 'root' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_10": {
        "description": "2.2 Ensure network traffic is restricted between containers on the default bridge",
        "info": "By default, all network traffic is allowed between containers on the same host on the default network bridge. If not desired, restrict all inter-container communication. Link specific containers together that require communication. Alternatively, you can create custom network and only join containers that need to communicate to that custom network.\n\nRationale:\n\nBy default, unrestricted network traffic is enabled between all containers on the same host on the default network bridge. Thus, each container has the potential of reading all packets across the container network on the same host. This might lead to an unintended and unwanted disclosure of information to other containers. Hence, restrict inter-container communication on the default network bridge.\n\nImpact:\n\nInter-container communication would be disabled on the default network bridge. If any communication between containers on the same host is desired, then it needs to be explicitly defined using container linking or alternatively custom networks have to be defined.",
        "solution": "Edit the Docker daemon configuration file to ensure that icc is disabled. It should include the following setting\n\n'icc': false\n\nAlernatively, run the docker daemon directly and pass --icc=false as an argument.\nFor Example,\n\ndockerd --icc=false\n\nAlternatively, you can follow the Docker documentation and create a custom network and only join containers that need to communicate to that custom network. The --icc parameter only applies to the default docker bridge, if custom networks are used then the approach of segmenting networks should be adopted instead.\nIn order for this control to be fully effective, all containers connected to the docker0 bridge should drop the NET_RAW capability, otherwise a compromised container could use raw ethernet packets to communicate with other containers despite this restriction.\n\nDefault Value:\n\nBy default, all inter-container communication is allowed on the default network bridge.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.15,800-53|CM-6,800-53|CM-7,800-53|SC-23,800-53r5|CM-6,800-53r5|CM-7,800-53r5|SC-23,CSCv7|9,CSCv8|12.3,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|SC-23,ITSG-33|SC-23a.,LEVEL|1M,NESA|T4.5.1,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|5.2.1,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker network ls --quiet | xargs docker network inspect --format '{{ .Name }}: {{ .Options }}'",
        "expect": "com\\.docker\\.network\\.bridge\\.enable_icc:false"
    },
    "custom_item_11": {
        "description": "2.3 Ensure the logging level is set to 'info' - dockerd",
        "info": "Set Docker daemon log level to info.\n\nRationale:\n\nSetting up an appropriate log level, configures the Docker daemon to log events that you would want to review later. A base log level of info and above would capture all logs except debug logs. Until and unless required, you should not run Docker daemon at debug log level.\n\nImpact:\n\nNone.",
        "solution": "Ensure that the Docker daemon configuration file has the following configuration included\n\n'log-level': 'info'\n\nAlternatively, run the Docker daemon as below:\n\ndockerd --log-level='info'\n\nDefault Value:\n\nBy default, Docker daemon is set to log level of info.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "^((?!--log-level=['\"]*debug['\"]*).)*$"
    },
    "custom_item_12": {
        "description": "2.3 Ensure the logging level is set to 'info' - daemon.json",
        "info": "Set Docker daemon log level to info.\n\nRationale:\n\nSetting up an appropriate log level, configures the Docker daemon to log events that you would want to review later. A base log level of info and above would capture all logs except debug logs. Until and unless required, you should not run Docker daemon at debug log level.\n\nImpact:\n\nNone.",
        "solution": "Ensure that the Docker daemon configuration file has the following configuration included\n\n'log-level': 'info'\n\nAlternatively, run the Docker daemon as below:\n\ndockerd --log-level='info'\n\nDefault Value:\n\nBy default, Docker daemon is set to log level of info.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/daemon.json",
        "regex": "['\"]*log-level['\"]*[\\\\s]*:",
        "expect": "['\"]*log-level['\"]*[\\\\s]*:[\\\\s]*['\"]*debug['\"]*"
    },
    "custom_item_13": {
        "description": "2.4 Ensure Docker is allowed to make changes to iptables - dockerd",
        "info": "The iptables firewall is used to set up, maintain, and inspect the tables of IP packet filter rules within the Linux kernel. The Docker daemon should be allowed to make changes to the iptables ruleset.\n\nRationale:\n\nDocker will never make changes to your system iptables rules unless you allow it to do so. If you do allow this, Docker server will automatically make any required changes. We recommended letting Docker make changes to iptables automatically in order to avoid networking misconfigurations that could affect the communication between containers and with the outside world. Additionally, this reduces the administrative overhead of updating iptables every time you add containers or modify networking options.\n\nImpact:\n\nThe Docker daemon service requires iptables rules to be enabled before it starts. Any restarts of iptables during Docker daemon operation may result in losing Docker created rules. Adding iptables-persistent to your iptables install can assist with mitigation of this impact.",
        "solution": "Do not run the Docker daemon with --iptables=false parameter. For example, do not start the Docker daemon as below:\n\ndockerd --iptables=false\n\nDefault Value:\n\nBy default, iptables is set to true.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-171|3.13.5,800-53|CM-7,800-53|CP-6,800-53|CP-7,800-53|PL-8,800-53|PM-7,800-53|SA-8,800-53|SC-7,800-53r5|CM-7,800-53r5|CP-6,800-53r5|CP-7,800-53r5|PL-8,800-53r5|PM-7,800-53r5|SA-8,800-53r5|SC-7,CN-L3|8.1.10.6(j),CSCv7|4,CSCv8|12.2,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-4,CSF|PR.PT-3,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.c,GDPR|32.1.d,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|CM-7,ITSG-33|CP-6,ITSG-33|CP-7,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SC-7,LEVEL|1M,NESA|T2.2.4,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|SS3,NIAv2|SS15a,NIAv2|VL2,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv3.2.1|2.2.2,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,SWIFT-CSCv1|2.3,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "^((?!--iptables=['\"]*false['\"]*).)*$"
    },
    "custom_item_14": {
        "description": "2.4 Ensure Docker is allowed to make changes to iptables - daemon.json",
        "info": "The iptables firewall is used to set up, maintain, and inspect the tables of IP packet filter rules within the Linux kernel. The Docker daemon should be allowed to make changes to the iptables ruleset.\n\nRationale:\n\nDocker will never make changes to your system iptables rules unless you allow it to do so. If you do allow this, Docker server will automatically make any required changes. We recommended letting Docker make changes to iptables automatically in order to avoid networking misconfigurations that could affect the communication between containers and with the outside world. Additionally, this reduces the administrative overhead of updating iptables every time you add containers or modify networking options.\n\nImpact:\n\nThe Docker daemon service requires iptables rules to be enabled before it starts. Any restarts of iptables during Docker daemon operation may result in losing Docker created rules. Adding iptables-persistent to your iptables install can assist with mitigation of this impact.",
        "solution": "Do not run the Docker daemon with --iptables=false parameter. For example, do not start the Docker daemon as below:\n\ndockerd --iptables=false\n\nDefault Value:\n\nBy default, iptables is set to true.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-171|3.13.5,800-53|CM-7,800-53|CP-6,800-53|CP-7,800-53|PL-8,800-53|PM-7,800-53|SA-8,800-53|SC-7,800-53r5|CM-7,800-53r5|CP-6,800-53r5|CP-7,800-53r5|PL-8,800-53r5|PM-7,800-53r5|SA-8,800-53r5|SC-7,CN-L3|8.1.10.6(j),CSCv7|4,CSCv8|12.2,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-4,CSF|PR.PT-3,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.c,GDPR|32.1.d,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|CM-7,ITSG-33|CP-6,ITSG-33|CP-7,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SC-7,LEVEL|1M,NESA|T2.2.4,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|SS3,NIAv2|SS15a,NIAv2|VL2,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv3.2.1|2.2.2,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,SWIFT-CSCv1|2.3,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/daemon.json",
        "regex": "['\"]*iptables['\"]*[\\\\s]*:",
        "expect": "['\"]*iptables['\"]*[\\\\s]*:[\\\\s]*['\"]*false['\"]*"
    },
    "custom_item_15": {
        "description": "2.5 Ensure insecure registries are not used",
        "info": "Docker considers a private registry either secure or insecure. By default, registries are considered secure.\n\nRationale:\n\nA secure registry uses TLS. A copy of registry's CA certificate is placed on the Docker host at /etc/docker/certs.d// directory. An insecure registry is one which does not have a valid registry certificate, or one not using TLS. Insecure registries should not be used as they present a risk of traffic interception and modification.\n\nAdditionally, once a registry has been marked as insecure commands such as docker pull, docker push, and docker search will not result in an error message and users may indefinitely be working with this type of insecure registry without ever being notified of the risk of potential compromise.\n\nImpact:\n\nNone.",
        "solution": "You should ensure that no insecure registries are in use.\n\nDefault Value:\n\nBy default, Docker assumes all, but local, registries are secure.",
        "reference": "800-171|3.4.8,800-53|CM-7(5),800-53|CM-10,800-53r5|CM-7(5),800-53r5|CM-10,CSCv7|14.4,CSCv8|2.5,CSF|DE.CM-3,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO/IEC-27001|A.12.5.1,ISO/IEC-27001|A.12.6.2,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.3,TBA-FIISB|44.2.2,TBA-FIISB|49.2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker info --format 'Insecure Registries: {{ .RegistryConfig.InsecureRegistryCIDRs }}'",
        "expect": "^Insecure[\\\\s]+Registries:[\\\\s]+\\\\[127.0.0.0/8\\\\]$"
    },
    "custom_item_16": {
        "description": "2.6 Ensure aufs storage driver is not used",
        "info": "Do not use aufs as the storage driver for your Docker instance.\n\nRationale:\n\nThe aufs storage driver is the oldest storage driver used on Linux systems. It is based on a Linux kernel patch-set that is unlikely in future to be merged into the main OS kernel. The aufs driver is also known to cause some serious kernel crashes. aufs only has legacy support within systems using Docker.\n\nMost importantly, aufs is not a supported driver in many Linux distributions using latest Linux kernels and has also been deprecated with Docker Engine release 20.10.\n\nImpact:\n\naufs is the only storage driver that allows containers to share executable and shared library memory. It might be useful if you are running thousands of containers with the same program or libraries, however its use should be reviewed in line with your organization's security policy.",
        "solution": "Do not explicitly use aufs as storage driver.\nFor example, do not start Docker daemon as below:\n\ndockerd --storage-driver aufs\n\nDefault Value:\n\nBy default, Docker uses overlay2 as the storage driver on most of the platforms. The default storage driver can vary based on your OS vendor. You should use the storage driver that is recommended by your preferred vendor and which is in line with policy around the applications which are being deployed.",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|SA-8,800-53r5|SA-8,CSCv7|18,CSCv8|16,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|1M,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker info --format 'Storage Driver: {{ .Driver }}'",
        "expect": "Storage Driver: ((?!aufs).)*$"
    },
    "custom_item_17": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - dockerd",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "--tlsverify"
    },
    "custom_item_18": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - daemon.json",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"tlsverify\"]",
        "regex": ".*",
        "expect": ".+"
    },
    "custom_item_19": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - dockerd",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "--tlscacert"
    },
    "custom_item_20": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - daemon.json",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"tlscacert\"]",
        "regex": ".*",
        "expect": ".+"
    },
    "custom_item_21": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - dockerd",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "--tlscert"
    },
    "custom_item_22": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - daemon.json",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"tlscert\"]",
        "regex": ".*",
        "expect": ".+"
    },
    "custom_item_23": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - dockerd",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "--tlskey"
    },
    "custom_item_24": {
        "description": "2.7 Ensure TLS authentication for Docker daemon is configured - daemon.json",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"tlskey\"]",
        "regex": ".*",
        "expect": ".+"
    },
    "custom_item_25": {
        "description": "2.8 Ensure the default ulimit is configured appropriately - ps",
        "cmd": "ps -ef | grep [d]ockerd | grep -e '--default-ulimit nofile=@DEFAULT_ULIMIT_NOFILE_SOFT@:@DEFAULT_ULIMIT_NOFILE_HARD@.*--default-ulimit nproc=@DEFAULT_ULIMIT_NPROC_SOFT@:@DEFAULT_ULIMIT_NPROC_HARD@' -e '--default-ulimit nproc=@DEFAULT_ULIMIT_NPROC_SOFT@:@DEFAULT_ULIMIT_NPROC_HARD@.*--default-ulimit nofile=@DEFAULT_ULIMIT_NOFILE_SOFT@:@DEFAULT_ULIMIT_NOFILE_HARD@' | awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "^pass$"
    },
    "custom_item_26": {
        "description": "2.8 Ensure the default ulimit is configured appropriately - ps",
        "info": "Set the default ulimit options as appropriate in your environment.\n\nRationale:\n\nulimit provides control over the resources available to the shell and to processes which it starts. Setting system resource limits judiciously can save you from disasters such as a fork bomb. On occasion, even friendly users and legitimate processes can overuse system resources and can make the system unusable.\n\nSetting the default ulimit for the Docker daemon enforces the ulimit for all container instances. In this case you would not need to setup ulimit for each container instance. However, the default ulimit can be overridden during container runtime, if needed. Therefore, in order to have proper control over system resources, define a default ulimit as is needed in your environment.\n\nImpact:\n\nIf ulimits are set incorrectly this could cause issues with system resources, possibly causing a denial of service condition.",
        "solution": "Run Docker in daemon mode and pass --default-ulimit as argument with respective ulimits as appropriate in your environment and in line with your security policy.\nFor Example,\n\ndockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200\n\nDefault Value:\n\nBy default, no ulimit is set.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "ps -ef | grep [d]ockerd | grep -e '--default-ulimit nofile=@DEFAULT_ULIMIT_NOFILE_SOFT@:@DEFAULT_ULIMIT_NOFILE_HARD@.*--default-ulimit nproc=@DEFAULT_ULIMIT_NPROC_SOFT@:@DEFAULT_ULIMIT_NPROC_HARD@' -e '--default-ulimit nproc=@DEFAULT_ULIMIT_NPROC_SOFT@:@DEFAULT_ULIMIT_NPROC_HARD@.*--default-ulimit nofile=@DEFAULT_ULIMIT_NOFILE_SOFT@:@DEFAULT_ULIMIT_NOFILE_HARD@' | awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'",
        "expect": "^pass$"
    },
    "custom_item_27": {
        "description": "2.8 Ensure the default ulimit is configured appropriately - daemon.json nofile hard",
        "info": "Set the default ulimit options as appropriate in your environment.\n\nRationale:\n\nulimit provides control over the resources available to the shell and to processes which it starts. Setting system resource limits judiciously can save you from disasters such as a fork bomb. On occasion, even friendly users and legitimate processes can overuse system resources and can make the system unusable.\n\nSetting the default ulimit for the Docker daemon enforces the ulimit for all container instances. In this case you would not need to setup ulimit for each container instance. However, the default ulimit can be overridden during container runtime, if needed. Therefore, in order to have proper control over system resources, define a default ulimit as is needed in your environment.\n\nImpact:\n\nIf ulimits are set incorrectly this could cause issues with system resources, possibly causing a denial of service condition.",
        "solution": "Run Docker in daemon mode and pass --default-ulimit as argument with respective ulimits as appropriate in your environment and in line with your security policy.\nFor Example,\n\ndockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200\n\nDefault Value:\n\nBy default, no ulimit is set.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"default-ulimits\"].[\"nofile\"].[\"Hard\"]",
        "regex": ".*",
        "expect": "@DEFAULT_ULIMIT_NOFILE_HARD@"
    },
    "custom_item_28": {
        "description": "2.8 Ensure the default ulimit is configured appropriately - daemon.json nofile soft",
        "info": "Set the default ulimit options as appropriate in your environment.\n\nRationale:\n\nulimit provides control over the resources available to the shell and to processes which it starts. Setting system resource limits judiciously can save you from disasters such as a fork bomb. On occasion, even friendly users and legitimate processes can overuse system resources and can make the system unusable.\n\nSetting the default ulimit for the Docker daemon enforces the ulimit for all container instances. In this case you would not need to setup ulimit for each container instance. However, the default ulimit can be overridden during container runtime, if needed. Therefore, in order to have proper control over system resources, define a default ulimit as is needed in your environment.\n\nImpact:\n\nIf ulimits are set incorrectly this could cause issues with system resources, possibly causing a denial of service condition.",
        "solution": "Run Docker in daemon mode and pass --default-ulimit as argument with respective ulimits as appropriate in your environment and in line with your security policy.\nFor Example,\n\ndockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200\n\nDefault Value:\n\nBy default, no ulimit is set.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"default-ulimits\"].[\"nofile\"].[\"Soft\"]",
        "regex": ".*",
        "expect": "@DEFAULT_ULIMIT_NOFILE_SOFT@"
    },
    "custom_item_29": {
        "description": "2.8 Ensure the default ulimit is configured appropriately - daemon.json nproc hard",
        "info": "Set the default ulimit options as appropriate in your environment.\n\nRationale:\n\nulimit provides control over the resources available to the shell and to processes which it starts. Setting system resource limits judiciously can save you from disasters such as a fork bomb. On occasion, even friendly users and legitimate processes can overuse system resources and can make the system unusable.\n\nSetting the default ulimit for the Docker daemon enforces the ulimit for all container instances. In this case you would not need to setup ulimit for each container instance. However, the default ulimit can be overridden during container runtime, if needed. Therefore, in order to have proper control over system resources, define a default ulimit as is needed in your environment.\n\nImpact:\n\nIf ulimits are set incorrectly this could cause issues with system resources, possibly causing a denial of service condition.",
        "solution": "Run Docker in daemon mode and pass --default-ulimit as argument with respective ulimits as appropriate in your environment and in line with your security policy.\nFor Example,\n\ndockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200\n\nDefault Value:\n\nBy default, no ulimit is set.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"default-ulimits\"].[\"nproc\"].[\"Hard\"]",
        "regex": ".*",
        "expect": "@DEFAULT_ULIMIT_NPROC_HARD@"
    },
    "custom_item_30": {
        "description": "2.8 Ensure the default ulimit is configured appropriately - daemon.json nproc soft",
        "info": "Set the default ulimit options as appropriate in your environment.\n\nRationale:\n\nulimit provides control over the resources available to the shell and to processes which it starts. Setting system resource limits judiciously can save you from disasters such as a fork bomb. On occasion, even friendly users and legitimate processes can overuse system resources and can make the system unusable.\n\nSetting the default ulimit for the Docker daemon enforces the ulimit for all container instances. In this case you would not need to setup ulimit for each container instance. However, the default ulimit can be overridden during container runtime, if needed. Therefore, in order to have proper control over system resources, define a default ulimit as is needed in your environment.\n\nImpact:\n\nIf ulimits are set incorrectly this could cause issues with system resources, possibly causing a denial of service condition.",
        "solution": "Run Docker in daemon mode and pass --default-ulimit as argument with respective ulimits as appropriate in your environment and in line with your security policy.\nFor Example,\n\ndockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200\n\nDefault Value:\n\nBy default, no ulimit is set.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"default-ulimits\"].[\"nproc\"].[\"Soft\"]",
        "regex": ".*",
        "expect": "@DEFAULT_ULIMIT_NPROC_SOFT@"
    },
    "custom_item_31": {
        "description": "2.14 Ensure containers are restricted from acquiring new privileges - dockerd",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "--no-new-privileges=['\"]true['\"]"
    },
    "custom_item_32": {
        "description": "2.14 Ensure containers are restricted from acquiring new privileges - daemon.json",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"no-new-privileges\"]",
        "regex": ".*",
        "expect": "true"
    },
    "custom_item_33": {
        "description": "2.15 Ensure live restore is enabled",
        "info": "The --live-restore option enables full support of daemon-less containers within Docker. It ensures that Docker does not stop containers on shutdown or restore and that it properly reconnects to the container when restarted.\n\nRationale:\n\nOne of the important security triads is availability. Setting the --live-restore flag within the Docker daemon ensures that container execution is not interrupted when it is not available. This also makes it easier to update and patch the Docker daemon without application downtime.\n\nImpact:\n\nNone.",
        "solution": "Run Docker in daemon mode and pass --live-restore to it as an argument.\nFor Example,\n\ndockerd --live-restore\n\nDefault Value:\n\nBy default, --live-restore is not enabled.",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|PL-8,800-53|SA-8,800-53r5|PL-8,800-53r5|SA-8,CSCv7|18,CSCv8|16.10,CSF|ID.AM-3,CSF|PR.IP-2,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|1M,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2,QCSC-v1|4.2,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker info --format '{{ .LiveRestoreEnabled }}'",
        "expect": "true"
    },
    "custom_item_34": {
        "description": "2.16 Ensure Userland Proxy is Disabled - dockerd",
        "cmd": "ps -ef | grep dockerd | grep -v grep",
        "expect": "--userland-proxy=false"
    },
    "custom_item_35": {
        "description": "2.16 Ensure Userland Proxy is Disabled - daemon.json",
        "file": "/etc/docker/daemon.json",
        "json_transform": ".[\"userland-proxy\"]",
        "regex": ".*",
        "expect": "false"
    },
    "custom_item_36": {
        "description": "2.18 Ensure that experimental features are not implemented in production",
        "info": "Experimental features should not be enabled in production.\n\nRationale:\n\n'Experimental' is currently a runtime Docker daemon flag rather than being a feature of a separate build. Passing --experimental as a runtime flag to the docker daemon activates experimental features. Whilst 'Experimental' is considered a stable release, it has a number of features which may not have been fully tested and do not guarantee API stability.\n\nImpact:\n\nNone",
        "solution": "You should not pass --experimental as a runtime parameter to the Docker daemon on production systems.\n\nDefault Value:\n\nBy default, experimental features are not activated in the Docker daemon.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker version --format '{{ .Server.Experimental }}'",
        "expect": "false"
    },
    "custom_item_37": {
        "description": "3.1 Ensure that the docker.service file ownership is set to root:root",
        "info": "You should verify that the docker.service file ownership and group ownership are correctly set to root.\n\nRationale:\n\nThe docker.service file contains sensitive parameters that may alter the behavior of the Docker daemon. It should therefore be individually and group owned by the root user in order to ensure that it is not modified or corrupted by a less privileged user.\n\nImpact:\n\nNone.",
        "solution": "Step 1: Find out the file location:\n\nsystemctl show -p FragmentPath docker.service\n\nStep 2: If the file does not exist, this recommendation is not applicable. If the file does exist, you should execute the command below, including the correct file path, in order to set the ownership and group ownership for the file to root.\nFor example,\n\nchown root:root /usr/lib/systemd/system/docker.service\n\nDefault Value:\n\nThis file may not be present on the system and if it is not, this recommendation is not applicable. By default, if the file is present, the correct permissions are for the ownership and group ownership to be set to 'root'.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,LEVEL|2A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/usr/lib/systemd/system/docker.service",
        "owner": "root",
        "group": "root"
    },
    "custom_item_38": {
        "description": "3.2 Ensure that docker.service file permissions are appropriately set",
        "info": "You should verify that the docker.service file permissions are either set to 644 or to a more restrictive value.\n\nRationale:\n\nThe docker.service file contains sensitive parameters that may alter the behavior of the Docker daemon. It should therefore not be writable by any other user other than root in order to ensure that it can not be modified by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "Step 1: Find out the file location:\n\nsystemctl show -p FragmentPath docker.service\n\nStep 2: If the file does not exist, this recommendation is not applicable. If the file exists, execute the command below including the correct file path to set the file permissions to 644.\nFor example,\n\nchmod 644 /usr/lib/systemd/system/docker.service\n\nDefault Value:\n\nThis file may not be present on the system. In that case, this recommendation is not applicable. By default, if the file is present, the file permissions are correctly set to 644.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/usr/lib/systemd/system/docker.service",
        "mask": "133"
    },
    "custom_item_39": {
        "description": "3.3 Ensure that docker.socket file ownership is set to root:root",
        "info": "You should verify that the docker.socket file ownership and group ownership are correctly set to root.\n\nRationale:\n\nThe docker.socket file contains sensitive parameters that may alter the behavior of the Docker remote API. For this reason, it should be owned and group owned by root in order to ensure that it is not modified by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "Step 1: Find out the file location:\n\nsystemctl show -p FragmentPath docker.socket\n\nStep 2: If the file does not exist, this recommendation is not applicable. If the file exists, execute the command below, including the correct file path to set the ownership and group ownership for the file to root.\nFor example,\n\nchown root:root /usr/lib/systemd/system/docker.socket\n\nDefault Value:\n\nThis file may not be present on the system. In that case, this recommendation is not applicable. By default, if the file is present, the ownership and group ownership for it should be set to root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,LEVEL|2A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/usr/lib/systemd/system/docker.socket",
        "owner": "root",
        "group": "root"
    },
    "custom_item_40": {
        "description": "3.4 Ensure that docker.socket file permissions are set to 644 or more restrictive",
        "info": "You should verify that the file permissions on the docker.socket file are correctly set to 644 or more restrictively.\n\nRationale:\n\nThe docker.socket file contains sensitive parameters that may alter the behavior of the Docker remote API. It should therefore be writeable only by root in order to ensure that it is not modified by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "Step 1: Find out the file location:\n\nsystemctl show -p FragmentPath docker.socket\n\nStep 2: If the file does not exist, this recommendation is not applicable. If the file does exist, you should execute the command below, including the correct file path to set the file permissions to 644.\nFor example,\n\nchmod 644 /usr/lib/systemd/system/docker.socket\n\nDefault Value:\n\nThis file may not be present on the system and in that case, this recommendation is not applicable. By default, if the file is present, the permissions should be set to 644 or more restrictively.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/usr/lib/systemd/system/docker.socket",
        "mask": "133"
    },
    "custom_item_41": {
        "description": "3.5 Ensure that the /etc/docker directory ownership is set to root:root",
        "info": "You should verify that the /etc/docker directory ownership and group ownership is correctly set to root.\n\nRationale:\n\nThe /etc/docker directory contains certificates and keys in addition to various other sensitive files. It should therefore be individual owned and group owned by root in order to ensure that it can not be modified by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "To resolve this issue you should run the following command:\n\nchown root:root /etc/docker\n\nThis sets the ownership and group ownership for the directory to root.\n\nDefault Value:\n\nBy default, the ownership and group ownership for this directory is correctly set to root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,LEVEL|2A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker",
        "owner": "root",
        "group": "root"
    },
    "custom_item_42": {
        "description": "3.6 Ensure that /etc/docker directory permissions are set to 755 or more restrictively",
        "info": "You should verify that the /etc/docker directory permissions are correctly set to 755 or more restrictively.\n\nRationale:\n\nThe /etc/docker directory contains certificates and keys in addition to various sensitive files. It should therefore only be writeable by root to ensure that it can not be modified by a less privileged user.\n\nImpact:\n\nNone.",
        "solution": "You should run the following command:\n\nchmod 755 /etc/docker\n\nThis sets the permissions for the directory to 755.\n\nDefault Value:\n\nBy default, the permissions for this directory are set to 755.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker",
        "mask": "022"
    },
    "custom_item_43": {
        "description": "3.7 Ensure that registry certificate file ownership is set to root:root",
        "info": "You should verify that all the registry certificate files (usually found under /etc/docker/certs.d/directory) are individually owned and group owned by root.\n\nRationale:\n\nThe /etc/docker/certs.d/directory contains Docker registry certificates. These certificate files must be individually owned and group owned by root to ensure that less privileged users are unable to modify the contents of the directory.\n\nImpact:\n\nNone.",
        "solution": "The following command could be executed:\n\nchown root:root /etc/docker/certs.d//*\n\nThis would set the individual ownership and group ownership for the registry certificate files to root.\n\nDefault Value:\n\nBy default, the individual ownership and group ownership for registry certificate files is correctly set to root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,LEVEL|2M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/certs.d/*",
        "owner": "root",
        "group": "root"
    },
    "custom_item_44": {
        "description": "3.8 Ensure that registry certificate file permissions are set to 444 or more restrictively",
        "info": "You should verify that all the registry certificate files (usually found under /etc/docker/certs.d/directory) have permissions of 444 or are set more restrictively.\n\nNote that, by default, this directory might not exist if no registry certificate files are in place.\n\nRationale:\n\nThe /etc/docker/certs.d/directory contains Docker registry certificates. These certificate files must have permissions of 444or more restrictive permissions in order to ensure that unprivileged users do not have full access to them..\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nfind /etc/docker/certs.d/ -type f -exec chmod 0444 {} \\;\n\nThis would set the permissions for the registry certificate files to 444.\n\nDefault Value:\n\nBy default, the permissions for registry certificate files might not be 444. The default file permissions are governed by the system or user specific umask values which are defined within the operating system itself.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,LEVEL|2M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/etc/docker/certs.d/*",
        "mask": "333"
    },
    "custom_item_45": {
        "description": "3.9 Ensure that TLS CA certificate file ownership is set to root:root",
        "info": "You should verify that the TLS CA certificate file (the file that is passed along with the --tlscacert parameter) is individually owned and group owned by root.\n\nRationale:\n\nThe TLS CA certificate file should be protected from any tampering. It is used to authenticate the Docker server based on a given CA certificate. It must be therefore be individually owned and group owned by root to ensure that it cannot be modified by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nchown root:rootThis sets the individual ownership and group ownership for the TLS CA certificate file to root.\n\nDefault Value:\n\nBy default, the ownership and group-ownership for TLS CA certificate file is correctly set to root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,LEVEL|2M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "@PATH_TO_TLS_CA_FILE@",
        "owner": "root",
        "group": "root"
    },
    "custom_item_46": {
        "description": "3.10 Ensure that TLS CA certificate file permissions are set to 444 or more restrictively",
        "info": "You should verify that the TLS CA certificate file (the file that is passed along with the --tlscacert parameter) has permissions of 444 or is set more restrictively.\n\nRationale:\n\nThe TLS CA certificate file should be protected from any tampering. It is used to authenticate the Docker server based on a given CA certificate. It must therefore have permissions of 444, or more restrictive permissions to ensure that the file cannot be modified by a less privileged user.\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nchmod 444This sets the file permissions on the TLS CA file to 444.\n\nDefault Value:\n\nBy default, the permissions for the TLS CA certificate file might not be 444. The default file permissions are governed by the operating system or user specific umask values.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,LEVEL|2M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "@PATH_TO_TLS_CA_FILE@",
        "mask": "333"
    },
    "custom_item_47": {
        "description": "3.11 Ensure that Docker server certificate file ownership is set to root:root",
        "info": "You should verify that the Docker server certificate file (the file that is passed along with the --tlscert parameter) is individual owned and group owned by root.\n\nRationale:\n\nThe Docker server certificate file should be protected from any tampering. It is used to authenticate the Docker server based on the given server certificate. It must therefore be individually owned and group owned by root to prevent modification by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "You should run the following command:\n\nchown root:rootThis sets the individual ownership and the group ownership for the Docker server certificate file to root.\n\nDefault Value:\n\nBy default, the ownership and group-ownership for Docker server certificate file is correctly set to root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,LEVEL|2M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "@PATH_TO_SERVER_CERT_FILE@",
        "owner": "root",
        "group": "root"
    },
    "custom_item_48": {
        "description": "3.12 Ensure that the Docker server certificate file permissions are set to 444 or more restrictively",
        "info": "You should verify that the Docker server certificate file (the file that is passed along with the --tlscert parameter) has permissions of 444 or more restrictive permissions.\n\nRationale:\n\nThe Docker server certificate file should be protected from any tampering. It is used to authenticate the Docker server based on the given server certificate. It should therefore have permissions of 444 to prevent its modification.\n\nImpact:\n\nNone.",
        "solution": "You should execute the command below:\n\nchmod 444This sets the file permissions of the Docker server certificate file to 444.\n\nDefault Value:\n\nBy default, the permissions for the Docker server certificate file might not be 444. The default file permissions are governed by the operating system or user specific umask values.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,LEVEL|2M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "@PATH_TO_SERVER_CERT_FILE@",
        "mask": "333"
    },
    "custom_item_49": {
        "description": "3.13 Ensure that the Docker server certificate key file ownership is set to root:root",
        "info": "You should verify that the Docker server certificate key file (the file that is passed along with the --tlskey parameter) is individually owned and group owned by root.\n\nRationale:\n\nThe Docker server certificate key file should be protected from any tampering or unneeded reads/writes. As it holds the private key for the Docker server certificate, it must be individually owned and group owned by root to ensure that it cannot be accessed by less privileged users.\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nchown root:rootThis sets the individual ownership and group ownership for the Docker server certificate key file to root.\n\nDefault Value:\n\nBy default, the individual ownership and group ownership for the Docker server certificate key file is correctly set to root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "@PATH_TO_SERVER_CERT_KEY_FILE@",
        "owner": "root",
        "group": "root"
    },
    "custom_item_50": {
        "description": "3.14 Ensure that the Docker server certificate key file permissions are set to 400",
        "info": "You should verify that the Docker server certificate key file (the file that is passed along with the --tlskey parameter) has permissions of 400.\n\nRationale:\n\nThe Docker server certificate key file should be protected from any tampering or unneeded reads. It holds the private key for the Docker server certificate. It must therefore have permissions of 400 to ensure that the certificate key file is not modified.\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nchmod 400This sets the Docker server certificate key file permissions to 400.\n\nDefault Value:\n\nBy default, the permissions for the Docker server certificate key file might not be 400. The default file permissions are governed by the operating system or user specific umask values.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "@PATH_TO_SERVER_CERT_KEY_FILE@",
        "mask": "377"
    },
    "custom_item_51": {
        "description": "3.15 Ensure that the Docker socket file ownership is set to root:docker",
        "info": "You should verify that the Docker socket file is owned by root and group owned by docker.\n\nRationale:\n\nThe Docker daemon runs as root. The default Unix socket therefore must be owned by root. If any other user or process owns this socket, it might be possible for that non-privileged user or process to interact with the Docker daemon. Additionally, in this case a non-privileged user or process might be able to interact with containers which is neither a secure nor desired behavior.\n\nAdditionally, the Docker installer creates a Unix group called docker. You can add users to this group, and in this case, those users would be able to read and write to the default Docker Unix socket. The membership of the docker group is tightly controlled by the system administrator. However, ff any other group owns this socket, then it might be possible for members of that group to interact with the Docker daemon. Such a group might not be as tightly controlled as the docker group. Again, this is not in line with good security practice.\n\nFor these reason, the default Docker Unix socket file should be owned by root and group owned by docker to maintain the integrity of the socket file.\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nchown root:docker /var/run/docker.sock\n\nThis sets the ownership to root and group ownership to docker for the default Docker socket file.\n\nDefault Value:\n\nBy default, the ownership and group ownership for the Docker socket file is correctly set to root:docker.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|4,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/var/run/docker.sock",
        "owner": "root",
        "group": "docker"
    },
    "custom_item_52": {
        "description": "3.16 Ensure that the Docker socket file permissions are set to 660 or more restrictively",
        "info": "You should verify that the Docker socket file has permissions of 660 or are configured more restrictively.\n\nRationale:\n\nOnly root and the members of the docker group should be allowed to read and write to the default Docker Unix socket. The Docker socket file should therefore have permissions of 660 or more restrictive permissions.\n\nImpact:\n\nNone.",
        "solution": "You should execute the command below.\n\nchmod 660 /var/run/docker.sock\n\nThis sets the file permissions of the Docker socket file to 660.\n\nDefault Value:\n\nBy default, the permissions for the Docker socket file is correctly set to 660.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/var/run/docker.sock",
        "mask": "117"
    },
    "custom_item_53": {
        "description": "3.23 Ensure that the Containerd socket file ownership is set to root:root",
        "info": "You should verify that the Containerd socket file is owned by root and group owned by root.\n\nRationale:\n\nContainerd is an underlying component used by Docker to create and manage containers. It provides a socket file similar to the Docker socket, which must be protected from unauthorized access. If any other user or process owns this socket, it might be possible for that non-privileged user or process to interact with the Containerd daemon. Additionally, in this case a non-privileged user or process might be able to interact with containers which is neither a secure nor desired behavior.\n\nUnlike the Docker socket, there is usually no requirement for non-privileged users to connect to the socket, so the ownership should be root:root.\n\nImpact:\n\nNone.",
        "solution": "You should execute the following command:\n\nchown root:root /run/containerd/containerd.sock\n\nThis sets the ownership to root and group ownership to root for the default Containerd socket file.\n\nDefault Value:\n\nBy default, the ownership and group ownership for the Containerd socket file is correctly set to root:root.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,LEVEL|2A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/run/containerd/containerd.sock",
        "owner": "root",
        "group": "root"
    },
    "custom_item_54": {
        "description": "3.24 Ensure that the Containerd socket file permissions are set to 660 or more restrictively",
        "info": "You should verify that the Containerd socket file has permissions of 660 or are configured more restrictively.\n\nRationale:\n\nOnly root and the members of the root group should be allowed to read and write to the default Containerd Unix socket. The Containerd socket file should therefore have permissions of 660 or more restrictive permissions.\n\nImpact:\n\nNone.",
        "solution": "You should execute the command below.\n\nchmod 660 /run/containerd/containerd.sock\n\nThis sets the file permissions of the Containerd socket file to 660.\n\nDefault Value:\n\nBy default, the permissions for the Containerd socket file is correctly set to 660.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "file": "/run/containerd/containerd.sock",
        "mask": "117"
    },
    "custom_item_55": {
        "description": "4.1 Ensure that a user for the container has been created",
        "info": "Containers should run as a non-root user.\n\nRationale:\n\nIt is good practice to run the container as a non-root user, where possible. This can be done either via the USER directive in the Dockerfile or through gosu or similar where used as part of the CMD or ENTRYPOINT directives.\n\nImpact:\n\nRunning as a non-root user can present challenges where you wish to bind mount volumes from the underlying host. In this case, care should be taken to ensure that the user running the contained process can read and write to the bound directory, according to their requirements.",
        "solution": "You should ensure that the Dockerfile for each container image contains the information below:\n\nUSERIn this case, the user name or ID refers to the user that was found in the container base image. If there is no specific user created in the container base image, then make use of the useradd command to add a specific user before the USER instruction in the Dockerfile.\nFor example, add the below lines in the Dockerfile to create a user in the container:\n\nRUN useradd -d /home/username -m -s /bin/bash username\nUSER username\n\nNote: If there are users in the image that are not needed, you should consider deleting them. After deleting those users, commit the image and then generate new instances of the containers.\nAlternatively, if it is not possible to set the USER directive in the Dockerfile, a script running as part of the CMD or ENTRYPOINT sections of the Dockerfile should be used to ensure that the container process switches to a non-root user.\n\nDefault Value:\n\nBy default, containers are run with root privileges and also run as the root user inside the container.",
        "reference": "800-171|3.1.1,800-53|AC-2,800-53r5|AC-2,CN-L3|7.1.3.2(d),CSCv7|4,CSCv8|5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1M,NIAv2|AM28,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet | xargs --max-args=1 -I{} docker exec {} cat /proc/1/status | grep '^Uid:' | awk '{print $3}'",
        "expect": "^[^0]$"
    },
    "custom_item_56": {
        "description": "4.6 Ensure that HEALTHCHECK instructions have been added to container images",
        "info": "You should add the HEALTHCHECK instruction to your Docker container images in order to ensure that health checks are executed against running containers.\n\nRationale:\n\nAn important security control is that of availability. Adding the HEALTHCHECK instruction to your container image ensures that the Docker engine periodically checks the running container instances against that instruction to ensure that containers are still operational.\n\nBased on the results of the health check, the Docker engine could terminate containers which are not responding correctly, and instantiate new ones.\n\nImpact:\n\nNone.",
        "solution": "You should follow the Docker documentation and rebuild your container images to include the HEALTHCHECK instruction.\n\nDefault Value:\n\nBy default, HEALTHCHECK is not set.",
        "reference": "800-53|SA-11,800-53|SA-15,800-53r5|SA-11,800-53r5|SA-15,CSCv7|5.2,CSCv8|16.12,CSF|ID.RA-1,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SA-11,LEVEL|1M,NESA|T7.6.5,NIAv2|SS5,NIAv2|SS6a,QCSC-v1|4.2,QCSC-v1|11.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker images --quiet | docker inspect --format='{{ .Config.Healthcheck }}'",
        "expect": "^((?!*).)*$"
    },
    "custom_item_57": {
        "description": "5.1 Ensure swarm mode is not Enabled, if not needed",
        "info": "Do not enable swarm mode on a Docker engine instance unless this is needed.\n\nRationale:\n\nBy default, a Docker engine instance will not listen on any network ports, with all communications with the client coming over the Unix socket. When Docker swarm mode is enabled on a Docker engine instance, multiple network ports are opened on the system and made available to other systems on the network for the purposes of cluster management and node communications.\n\nOpening network ports on a system increases its attack surface and this should be avoided unless required.\n\nIt should be noted that swarm mode is required for the operation of Docker Enterprise components.\n\nImpact:\n\nDisabling swarm mode will impact the operation of Docker Enterprise components if these are in use.",
        "solution": "If swarm mode has been enabled on a system in error, you should run the command below:\n\ndocker swarm leave\n\nDefault Value:\n\nBy default, Docker swarm mode is not enabled.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,LEVEL|2M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker info | egrep 'Swarm: active' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_58": {
        "description": "5.2 Ensure that, if applicable, an AppArmor Profile is enabled",
        "info": "AppArmor is an effective and easy-to-use Linux application security system. It is available on some Linux distributions by default, for example, on Debian and Ubuntu.\n\nRationale:\n\nAppArmor protects the Linux OS and applications from various threats by enforcing a security policy which is also known as an AppArmor profile. You can create your own AppArmor profile for containers or use Docker's default profile. Enabling this feature enforces security policies on containers as defined in the profile.\n\nImpact:\n\nThe container will have the security controls defined in the AppArmor profile. It should be noted that if the AppArmor profile is misconfigured, this may cause issues with the operation of the container.",
        "solution": "If AppArmor is applicable for your Linux OS, you should enable it.\n\nVerify AppArmor is installed.\n\nCreate or import a AppArmor profile for Docker containers.\n\nEnable enforcement of the policy.\n\nStart your Docker container using the customized AppArmor profile. For example:\n\ndocker run --interactive --tty --security-opt='apparmor:PROFILENAME' ubuntu /bin/bash\n\nAlternatively, Docker's default AppArmor policy can be used.\n\nDefault Value:\n\nBy default, the docker-default AppArmor profile is applied to running containers. The Docker binary generates this profile and then loads it into the kernel.",
        "reference": "800-53|SI-16,800-53r5|SI-16,CSCv7|5.2,CSCv8|10.5,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SI-16,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: AppArmorProfile={{ .AppArmorProfile }}' | egrep 'AppArmorProfile=$' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_59": {
        "description": "5.4 Ensure that Linux kernel capabilities are restricted within containers",
        "info": "By default, Docker starts containers with a restricted set of Linux kernel capabilities. This means that any process can be granted the required capabilities instead of giving it root access. Using Linux kernel capabilities, processes in general do not need to run as the root user.\n\nRationale:\n\nDocker supports the addition and removal of capabilities. You should remove all capabilities not required for the correct function of the container.\n\nSpecifically, in the default capability set provided by Docker, the NET_RAW capability should be removed if not explicitly required, as it can give an attacker with access to a container the ability to create spoofed network traffic.\n\nImpact:\n\nRestrictions on processes within a container are based on which Linux capabilities are in force.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "You should execute the command below to add required capabilities:\n\ndocker run --cap-add={'Capability 1','Capability 2'}You should execute the command below to remove unneeded capabilities:\n\ndocker run --cap-drop={'Capability 1','Capability 2'}Alternatively, you could remove all the currently configured capabilities and then restore only the ones you specifically use:\n\ndocker run --cap-drop=all --cap-add={'Capability 1','Capability 2'}Note that some settings also can be configured using the --sysctl option, reducing the need for container capabilities even further. This includes unprivileged ICMP echo sockets without NET_RAW and allow opening any port less than 1024 without NET_BIND_SERVICE.\nAdding and removing capabilities are also possible when the docker service command is used:\n\ndocker service create --cap-drop=all --cap-add={'Capability 1','Capability 2'}Default Value:\n\nBy default, the capabilities below are applied to containers:\n\nAUDIT_WRITE\n\nCHOWN\n\nDAC_OVERRIDE\n\nFOWNER\n\nFSETID\n\nKILL\n\nMKNOD\n\nNET_BIND_SERVICE\n\nNET_RAW\n\nSETFCAP\n\nSETGID\n\nSETPCAP\n\nSETUID\n\nSYS_CHROOT",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|5.2,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CapAdd={{ .HostConfig.CapAdd }} CapDrop={{ .HostConfig.CapDrop }}'",
        "expect": "MANUAL_REVIEW"
    },
    "custom_item_60": {
        "description": "5.5 Ensure that privileged containers are not used",
        "info": "Using the --privileged flag provides all Linux kernel capabilities to the container to which it is applied and therefore overwrites the --cap-add and --cap-drop flags. For this reason you should ensure that it is not used.\n\nRationale:\n\nThe --privileged flag provides all capabilities to the container to which it is applied, and also lifts all the limitations enforced by the device cgroup controller. As a consequence this the container has most of the rights of the underlying host. This flag only exists to allow for specific use cases (for example running Docker within Docker) and should not generally be used.\n\nImpact:\n\nIf you start a container without the --privileged flag, it will not have excessive default capabilities.",
        "solution": "You should not run containers with the --privileged flag.\nFor example, do not start a container using the command below:\n\ndocker run --interactive --tty --privileged centos /bin/bash\n\nDefault Value:\n\nFalse.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Privileged={{ .HostConfig.Privileged }}' | grep 'Privileged=true' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_61": {
        "description": "5.6 Ensure sensitive host system directories are not mounted on containers",
        "info": "You should not allow sensitive host system directories such as those listed below to be mounted as container volumes, especially in read-write mode.\n\n/\n\n/boot\n\n/dev\n\n/etc\n\n/lib\n\n/proc\n\n/sys\n\n/usr\n\nRationale:\n\nIf sensitive directories are mounted in read-write mode, it could be possible to make changes to files within them. This has obvious security implications and should be avoided.\n\nImpact:\n\nNone.",
        "solution": "You should not mount directories which are security sensitive on the host within containers, especially in read-write mode.\n\nDefault Value:\n\nDocker defaults to using a read-write volume but you can also mount a directory read-only. By default, no sensitive host directories are mounted within containers.",
        "reference": "800-171|3.13.1,800-53|SC-7(10),800-53r5|SC-7(10),CN-L3|8.1.10.6(j),CSCv7|13,CSCv8|3,CSF|DE.CM-1,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7(10),LEVEL|1M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,TBA-FIISB|33.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Volumes={{ .Mounts }}' | egrep 'Source:(/|/boot|/dev|/etc|/lib|/proc|/sys|/usr) ' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_62": {
        "description": "5.7 Ensure sshd is not run within containers",
        "info": "The SSH daemon should not be running within the container. You should SSH into the Docker host, and use docker exec to enter a container.\n\nRationale:\n\nRunning SSH within the container increases the complexity of security management by making it\n\nDifficult to manage access policies and security compliance for SSH server\n\nDifficult to manage keys and passwords across various containers\n\nDifficult to manage security upgrades for SSH server\n\nIt is possible to have shell access to a container without using SSH, the needlessly increasing the complexity of security management should be avoided.\n\nImpact:\n\nNone.",
        "solution": "Uninstall the SSH daemon from the container and use and use docker exec to enter a container on the remote host.\n\ndocker exec --interactive --ttysh\n\nOR\n\ndocker attachDefault Value:\n\nBy default, SSH server is not running inside the container. Only one process per container is allowed.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "for i in $(/usr/bin/docker ps -q); do docker exec $i ps -el; done | grep sshd | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_63": {
        "description": "5.8 Ensure privileged ports are not mapped within containers",
        "info": "The TCP/IP port numbers below 1024 are considered privileged ports. Normal users and processes are not allowed to use them for various security reasons. Docker does, however allow a container port to be mapped to a privileged port.\n\nRationale:\n\nBy default, if the user does not specifically declare a container port to host port mapping, Docker automatically and correctly maps the container port to one available in the 49153-65535 range on the host. Docker does, however, allow a container port to be mapped to a privileged port on the host if the user explicitly declares it. This is because containers are executed with NET_BIND_SERVICE Linux kernel capability which does not restrict privileged port mapping. The privileged ports receive and transmit various pieces of data which are security sensitive and allowing containers to use them is not in line with good security practice.\n\nImpact:\n\nNone.",
        "solution": "You should not map container ports to privileged host ports when starting a container. You should also, ensure that there is no such container to host privileged port mapping declarations in the Dockerfile.\n\nDefault Value:\n\nBy default, mapping a container port to a privileged port on the host is allowed.\n\nNote: There might be certain cases where you want to map privileged ports, because if you forbid it, then the corresponding application has to run outside of a container.\n\nFor example: HTTP and HTTPS load balancers have to bind 80/tcp and 443/tcp respectively. Forbidding to map privileged ports effectively forbids from running those in a container, and mandates using an external load balancer. In such cases, those containers instances should be marked as exceptions for this recommendation.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|13.9,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}' | egrep 'HostPort:([1-9][0-9]{0,2}|10[0-1][0-9]|102[0-3])[^0-9]' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_64": {
        "description": "5.9 Ensure that only needed ports are open on the container",
        "info": "The dockerfile for a container image defines the ports which are opened by default on a container instance. The list of ports are relevant to the application you are running within the container and should only be open if they are needed.\n\nRationale:\n\nA container can be run with only the ports defined in the Dockerfile for its image or can alternatively be arbitrarily passed run time parameters to open a list of ports. Additionally, in the course of time, the Dockerfile may undergo various changes and the list of exposed ports may or may not still be relevant to the application you are running within the container. Opening unneeded ports increases the attack surface of the container and the associated containerized application. Good security practice is to only open ports that are needed for the correct operation of the application.\n\nImpact:\n\nNone.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "You should ensure that the Dockerfile for each container image only exposes needed ports. You can also completely ignore the list of ports defined in the Dockerfile by NOT using -P (UPPERCASE) or the --publish-all flag when starting the container. Instead, use the -p (lowercase) or --publish flag to explicitly define the ports that you need for a particular container instance.\nFor example:\n\ndocker run --interactive --tty --publish 5000 --publish 5001 --publish 5002 centos /bin/bash\n\nDefault Value:\n\nBy default, all the ports that are listed in the Dockerfile under the EXPOSE instruction for an image are opened when a container is run with the -P or --publish-all flags.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|13.9,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'",
        "expect": "^((?!Ports=*).)*$"
    },
    "custom_item_65": {
        "description": "5.10 Ensure that the host's network namespace is not shared",
        "info": "When the networking mode on a container is set to --net=host, the container is not placed inside a separate network stack. Effectively, applying this option instructs Docker to not containerize the container's networking. The consequence of this is that the container lives 'outside' in the main Docker host and has full access to its network interfaces.\n\nRationale:\n\nSelecting this option is potentially dangerous. It allows the container process to open reserved low numbered ports in the way that any other root process can. It also allows the container to access network services such as D-bus on the Docker host. A container process could potentially carry out undesired actions, such as shutting down the Docker host. This option should not be used unless there is a very specific reason for enabling it.\n\nImpact:\n\nNone.",
        "solution": "You should not pass the --net=host option when starting any container.\n\nDefault Value:\n\nBy default, containers connect to the Docker bridge when starting and do not run in the context of the host's network stack.",
        "reference": "800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-171|3.13.5,800-53|CM-7,800-53|CP-6,800-53|CP-7,800-53|PL-8,800-53|PM-7,800-53|SA-8,800-53|SC-7,800-53r5|CM-7,800-53r5|CP-6,800-53r5|CP-7,800-53r5|PL-8,800-53r5|PM-7,800-53r5|SA-8,800-53r5|SC-7,CN-L3|8.1.10.6(j),CSCv7|12,CSCv8|12.2,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-4,CSF|PR.PT-3,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.c,GDPR|32.1.d,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|CM-7,ITSG-33|CP-6,ITSG-33|CP-7,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SC-7,LEVEL|1M,NESA|T2.2.4,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|SS3,NIAv2|SS15a,NIAv2|VL2,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv3.2.1|2.2.2,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,SWIFT-CSCv1|2.3,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: NetworkMode={{ .HostConfig.NetworkMode }}'",
        "expect": "^((?!NetworkMode=host*).)*$"
    },
    "custom_item_66": {
        "description": "5.11 Ensure that the memory usage for containers is limited",
        "info": "By default, all containers on a Docker host share resources equally. By using the resource management capabilities of the Docker host, you can control the amount of memory that a container is able to use.\n\nRationale:\n\nBy default a container can use all of the memory on the host. You can use memory limit mechanisms to prevent a denial of service occurring where one container consumes all of the host's resources and other containers on the same host are therefore not able to function. Having no limit on memory usage can lead to issues where one container can easily make the whole system unstable and as a result unusable.\n\nImpact:\n\nIf correct memory limits are not set on each container, one process can expand its usage and cause other containers to run out of resources.",
        "solution": "You should run the container with only as much memory as it requires by using the --memory argument.\nFor example, you could run a container using the command below:\n\ndocker run -d --memory 256m centos sleep 1000\n\nIn the example above, the container is started with a memory limit of 256 MB.\nVerify the memory settings by using the command below:\n\ndocker inspect --format='{{ .Id }}: Memory={{.HostConfig.Memory}} KernelMemory={{.HostConfig.KernelMemory}} Swap={{.HostConfig.MemorySwap}}'Default Value:\n\nBy default, all containers on a Docker host share their resources equally and no memory limits are enforced.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|18,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Memory={{ .HostConfig.Memory }}'",
        "expect": "^((?!Memory=0).)*$"
    },
    "custom_item_67": {
        "description": "5.12 Ensure that CPU priority is set appropriately on containers",
        "info": "By default, all containers on a Docker host share resources equally. By using the resource management capabilities of the Docker host you can control the host CPU resources that a container may consume.\n\nRationale:\n\nBy default, CPU time is divided between containers equally. If you wish to control available CPU resources amongst container instances, you can use the CPU sharing feature. CPU sharing allows you to prioritize one container over others and prevents lower priority containers from absorbing CPU resources which may be required by other processes. This ensures that high priority containers are able to claim the CPU runtime they require.\n\nImpact:\n\nIf you do not correctly assign CPU thresholds, the container process may run out of resources and become unresponsive. If CPU resources on the host are not constrainted, CPU shares do not place any restrictions on individual resources.",
        "solution": "You should manage the CPU runtime between your containers dependent on their priority within your organization. To do so start the container using the --cpu-shares argument.\nFor example, you could run a container as below:\n\ndocker run -d --cpu-shares 512 centos sleep 1000\n\nIn the example above, the container is started with CPU shares of 50% of what other containers use. So if the other container has CPU shares of 80%, this container will have CPU shares of 40%.\nEvery new container will have 1024 shares of CPU by default. However, this value is shown as 0 if you run the command mentioned in the audit section.\nIf you set one container's CPU shares to 512 it will receive half of the CPU time compared to the other containers. So if you take 1024 as 100% you can then derive the number that you should set for respective CPU shares. For example, use 512 if you want to set it to 50% and 256 if you want to set it 25%.\nYou can also view the current CPU shares in the file /sys/fs/cgroup/cpu/docker//cpu.shares.\n\nDefault Value:\n\nBy default, all containers on a Docker host share their resources equally. No CPU shares are enforced.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|18,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CpuShares={{ .HostConfig.CpuShares }}'",
        "expect": "^((?!CpuShares=(0|1024)).)*$"
    },
    "custom_item_68": {
        "description": "5.13 Ensure that the container's root filesystem is mounted as read only",
        "info": "The container's root filesystem should be treated as a 'golden image' by using Docker run's --read-only option. This prevents any writes to the container's root filesystem at container runtime and enforces the principle of immutable infrastructure.\n\nRationale:\n\nEnabling this option forces containers at runtime to explicitly define their data writing strategy to persist or not persist their data.\n\nThis also reduces security attack vectors since the container instance's filesystem cannot be tampered with or written to unless it has explicit read-write permissions on its filesystem folder and directories.\n\nImpact:\n\nEnabling --read-only at container runtime may break some container OS packages if a data writing strategy is not defined.\n\nYou should define what the container's data should and should not persist at runtime in order to decide which strategy to use.\n\nExample:\n\nEnable use --tmpfs for temporary file writes to /tmp\n\nUse Docker shared data volumes for persistent data writes",
        "solution": "You should add a --read-only flag at a container's runtime to enforce the container's root filesystem being mounted as read only.\n\ndocker run--read-onlyEnabling the --read-only option at a container's runtime should be used by administrators to force a container's executable processes to only write container data to explicit storage locations during its lifetime.\nExamples of explicit storage locations during a container's runtime include, but are not limited to:\n\nUsing the --tmpfs option to mount a temporary file system for non-persistent data writes.\n\ndocker run --interactive --tty --read-only --tmpfs '/run' --tmpfs '/tmp' centos /bin/bash\n\nEnabling Docker rw mounts at a container's runtime to persist container data directly on the Docker host filesystem.\n\ndocker run --interactive --tty --read-only -v /opt/app/data:/run/app/data:rw centos /bin/bash\n\nUtilizing the Docker shared-storage volume plugin for Docker data volume to persist container data.\n\ndocker volume create -d convoy --opt o=size=20GB my-named-volume\n\ndocker run --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash\n\nTransmitting container data outside of the Docker controlled area during the container's runtime for container data in order to ensure that it is persistent. Examples include hosted databases, network file shares and APIs.\n\nDefault Value:\n\nBy default, a container has its root filesystem writeable, allowing all container processes to write files owned by the container's actual runtime user.",
        "reference": "800-171|3.1.1,800-171|3.1.5,800-171|3.3.8,800-171|3.3.9,800-53|AC-2,800-53|AC-3,800-53|AC-6,800-53|AC-6(1),800-53|AC-6(7),800-53|AU-9(4),800-53r5|AC-2,800-53r5|AC-3,800-53r5|AC-6,800-53r5|AC-6(1),800-53r5|AC-6(7),800-53r5|AU-9(4),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(d),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(d),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|6.8,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.9.2.1,ISO/IEC-27001|A.9.2.5,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.4,ISO/IEC-27001|A.9.4.5,ISO/IEC-27001|A.12.4.2,ITSG-33|AC-2,ITSG-33|AC-3,ITSG-33|AC-6,ITSG-33|AC-6(1),ITSG-33|AU-9(4),ITSG-33|AU-9(4)(a),ITSG-33|AU-9(4)(b),LEVEL|1M,NESA|M1.1.3,NESA|M1.2.2,NESA|M5.2.3,NESA|M5.5.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM28,NIAv2|AM31,NIAv2|GS3,NIAv2|GS4,NIAv2|GS8c,NIAv2|NS5j,NIAv2|SM5,NIAv2|SM6,NIAv2|SS13c,NIAv2|SS14e,NIAv2|SS15c,NIAv2|SS29,NIAv2|VL3b,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.5,PCI-DSSv3.2.1|10.5.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.3.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: ReadonlyRootfs={{ .HostConfig.ReadonlyRootfs }}'",
        "expect": "^((?!ReadonlyRootfs=false).)*$"
    },
    "custom_item_69": {
        "description": "5.14 Ensure that incoming container traffic is bound to a specific host interface",
        "info": "By default, Docker containers can make connections to the outside world, but the outside world cannot connect to containers and each outgoing connection will appear to originate from one of the host machine's own IP addresses. You should only allow container services to be contacted through a specific external interface on the host machine.\n\nRationale:\n\nIf you have multiple network interfaces on your host machine, the container can accept connections on exposed ports on any network interface. This might not be desirable and may not be secured. In many cases a specific, desired interface is exposed externally and services such as intrusion detection, intrusion prevention, firewall, load balancing, etc. are all run by intention there to screen incoming public traffic. You should therefore not accept incoming connections on any random interface, but only the one designated for this type of traffic.\n\nImpact:\n\nNone.",
        "solution": "You should bind the container port to a specific host interface on the desired host port.\nFor example,\n\ndocker run --detach --publish 10.2.3.4:49153:80 nginx\n\nIn the example above, the container port 80 is bound to the host port on 49153 and would accept incoming connection only from the 10.2.3.4 external interface.\n\nDefault Value:\n\nBy default, Docker exposes the container ports on 0.0.0.0, the wildcard IP address that will match any possible incoming network interface on the host machine.",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|11,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|1M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}' | egrep 'HostIp:0.0.0.0' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_70": {
        "description": "5.15 Ensure that the 'on-failure' container restart policy is set to '5'",
        "info": "By using the --restart flag in the docker run command you can specify a restart policy for how a container should or should not be restarted on exit. You should choose the on-failure restart policy and limit the restart attempts to 5.\n\nRationale:\n\nIf you indefinitely keep trying to start the container, it could possibly lead to a denial of service on the host. It could be an easy way to do a distributed denial of service attack especially if you have many containers on the same host. Additionally, ignoring the exit status of the container and always attempting to restart the container, leads to non-investigation of the root cause behind containers getting terminated. If a container gets terminated, you should investigate on the reason behind it instead of just attempting to restart it indefinitely. You should use the on-failure restart policy to limit the number of container restarts to a maximum of 5 attempts.\n\nImpact:\n\nIf this option is set, a container will only attempt to restart itself 5 times.",
        "solution": "If you wish a container to be automatically restarted, a sample command is as below:\n\ndocker run --detach --restart=on-failure:5 nginx\n\nDefault Value:\n\nBy default, containers are not configured with restart policies.",
        "reference": "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv7|5.2,CSCv8|4,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|1M,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: RestartPolicyName={{ .HostConfig.RestartPolicy.Name }} MaximumRetryCount={{ .HostConfig.RestartPolicy.MaximumRetryCount }}' | egrep -v 'RestartPolicyName=on-failure.*MaximumRetryCount=[0-5]$' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_71": {
        "description": "5.16 Ensure that the host's process namespace is not shared",
        "info": "The Process ID (PID) namespace isolates the process ID space, meaning that processes in different PID namespaces can have the same PID. This creates process level isolation between the containers and the host.\n\nRationale:\n\nPID namespace provides separation between processes. It prevents system processes from being visible, and allows process ids to be reused including PID 1. If the host's PID namespace is shared with containers, it would basically allow these to see all of the processes on the host system. This reduces the benefit of process level isolation between the host and the containers. Under these circumstances a malicious user who has access to a container could get access to processes on the host itself, manipulate them, and even be able to kill them. This could allow for the host itself being shut down, which could be extremely serious, particularly in a multi-tenanted environment. You should not share the host's process namespace with the containers running on it.\n\nImpact:\n\nContainer processes cannot see processes on the host system. In certain circumstances, you may want your container to share the host's process namespace. For example, you could build a container containing debugging tools such as strace or gdb, and want to use these tools when debugging processes on the host. If this is desired, then share specific host processes using the -p switch.\n\nFor example:\n\ndocker run --pid=host rhel7 strace -p 1234",
        "solution": "You should not start a container with the --pid=host argument.\nFor example, do not start a container with the command below:\n\ndocker run --interactive --tty --pid=host centos /bin/bash\n\nDefault Value:\n\nBy default, all containers have the PID namespace enabled and the therefore the host's process namespace is not shared with its containers.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|14.1,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: PidMode={{ .HostConfig.PidMode }}'",
        "expect": "^((?!PidMode=host).)*$"
    },
    "custom_item_72": {
        "description": "5.17 Ensure that the host's IPC namespace is not shared",
        "info": "IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores and message queues. The IPC namespace on the host should therefore not be shared with containers and should remain isolated.\n\nRationale:\n\nThe IPC namespace provides separation of IPC between the host and containers. If the host's IPC namespace is shared with the container, it would allow processes within the container to see all of IPC communications on the host system. This would remove the benefit of IPC level isolation between host and containers. An attacker with access to a container could get access to the host at this level with major consequences. The IPC namespace should therefore not be shared between the host and its containers.\n\nImpact:\n\nShared memory segments are used in order to accelerate interprocess communications, commonly in high-performance applications. If this type of application is containerized into multiple containers, you might need to share the IPC namespace of the containers in order to achieve high performance. Under these circumstances, you should still only share container specific IPC namespaces and not the host IPC namespace.\n\nA container's IPC namespace can be shared with another container as shown below:\n\ndocker run --interactive --tty --ipc=container:e3a7a1a97c58 centos /bin/bash",
        "solution": "You should not start a container with the --ipc=host argument. For example, do not start a container as below:\n\ndocker run --interactive --tty --ipc=host centos /bin/bash\n\nDefault Value:\n\nBy default, all containers have their IPC namespace enabled and host IPC namespace is not shared with any container.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|14.1,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: IpcMode={{ .HostConfig.IpcMode }}'",
        "expect": "^((?!IpcMode=host).)*$"
    },
    "custom_item_73": {
        "description": "5.18 Ensure that host devices are not directly exposed to containers",
        "info": "Host devices can be directly exposed to containers at runtime. Do not directly expose host devices to containers, especially to containers that are not trusted.\n\nRationale:\n\nThe --device option exposes host devices to containers and as a result of this, containers can directly access these devices. The the container would not need to run in privileged mode to access and manipulate them, as by default, the container is granted this type of access. Additionally, it would possible for containers to remove block devices from the host. You therefore should not expose host devices to containers directly.\n\nIf for some reason you wish to expose the host device to a container you should consider which sharing permissions you wish to use on a case by case base as appropriate to your organization:\n\nr - read only\n\nw - writable\n\nm - mknod allowed\n\nImpact:\n\nYou would not be able to use host devices directly within containers.",
        "solution": "You should not directly expose host devices to containers. If you do need to expose host devices to containers, you should use granular permissions as appropriate to your organization:\nFor example, do not start a container using the command below:\n\ndocker run --interactive --tty --device=/dev/tty0:/dev/tty0:rwm --device=/dev/temp_sda:/dev/temp_sda:rwm centos bash\n\nYou should only share the host device using appropriate permissions:\n\ndocker run --interactive --tty --device=/dev/tty0:/dev/tty0:rw --device=/dev/temp_sda:/dev/temp_sda:r centos bash\n\nDefault Value:\n\nBy default, host devices are not exposed to containers. If you do not provide sharing permissions and choose to expose a host device to a container, the host device is be exposed with read, write and mknod permissions.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|14,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Devices={{ .HostConfig.Devices }}'",
        "expect": "^((?!Devices=\\\\[.+\\\\]).)*$"
    },
    "custom_item_74": {
        "description": "5.19 Ensure that the default ulimit is overwritten at runtime if needed",
        "info": "The default ulimit is set at the Docker daemon level. However, if you need to, you may override the default ulimit setting during container runtime.\n\nRationale:\n\nulimit provides control over the resources available to the shell and to processes started by it. Setting system resource limits in a prudent fashion, protects against denial of service conditions. On occasion, legitimate users and processes can accidentally overuse system resources and cause systems be degraded or even unresponsive.\n\nThe default ulimit set at the Docker daemon level should be honored. If the default ulimit settings are not appropriate for a particular container instance, you may override them as an exception, but this should not be done routinely. If many of your container instances are exceeding your ulimit settings, you should consider changing the default settings to something that is more appropriate for your needs.\n\nImpact:\n\nIf ulimits are not set correctly, overutilization by individual containers could make the host system unusable.",
        "solution": "You should only override the default ulimit settings if needed in a specific case.\nFor example, to override default ulimit settings start a container as below:\n\ndocker run -ti -d --ulimit nofile=1024:1024 centos sleep 1000\n\nDefault Value:\n\nContainer instances inherit the default ulimit settings set at the Docker daemon level.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|5.2,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Ulimits={{ .HostConfig.Ulimits }}'",
        "expect": "^((?!Ulimits=).)*$"
    },
    "custom_item_75": {
        "description": "5.20 Ensure mount propagation mode is not set to shared",
        "info": "Mount propagation mode allows mounting volumes in shared, slave or private mode on a container. Do not use shared mount propagation mode unless explicitly needed.\n\nRationale:\n\nA shared mount is replicated at all mounts and changes made at any mount point are propagated to all other mount points.\n\nMounting a volume in shared mode does not restrict any other container from mounting and making changes to that volume.\n\nAs this is likely not a desirable option from a security standpoint, this feature should not be used unless explicitly required.\n\nImpact:\n\nNone.",
        "solution": "Do not mount volumes in shared mode propagation.\nFor example, do not start a container as below:\n\ndocker run--volume=/hostPath:/containerPath:sharedDefault Value:\n\nBy default, the container mounts are private.",
        "reference": "800-171|3.13.1,800-53|SC-7(10),800-53r5|SC-7(10),CN-L3|8.1.10.6(j),CSCv7|13,CSCv8|3,CSF|DE.CM-1,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7(10),LEVEL|1M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,TBA-FIISB|33.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Propagation={{range $mnt := .Mounts}} {{json $mnt.Propagation}} {{end}}' | grep shared | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_76": {
        "description": "5.21 Ensure that the host's UTS namespace is not shared",
        "info": "UTS namespaces provide isolation between two system identifiers: the hostname and the NIS domain name. It is used to set the hostname and the domain which are visible to running processes in that namespace. Processes running within containers do not typically require to know either the hostname or the domain name. The UTS namespace should therefore not be shared with the host.\n\nRationale:\n\nSharing the UTS namespace with the host provides full permission for each container to change the hostname of the host. This is not in line with good security practice and should not be permitted.\n\nImpact:\n\nNone.",
        "solution": "You should not start a container with the --uts=host argument.\nFor example, do not start a container using the command below:\n\ndocker run --rm --interactive --tty --uts=host rhel7.2\n\nDefault Value:\n\nBy default, all containers have the UTS namespace enabled and the host UTS namespace is not shared with any containers.",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-53|CA-9,800-53|SC-7,800-53r5|CA-9,800-53r5|SC-7,CN-L3|8.1.10.6(j),CSCv7|14.1,CSCv8|13.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,LEVEL|1M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: UTSMode={{ .HostConfig.UTSMode }}'",
        "expect": "^((?!UTSMode=host).)*$"
    },
    "custom_item_77": {
        "description": "5.22 Ensure the default seccomp profile is not Disabled",
        "info": "Seccomp filtering provides a means for a process to specify a filter for incoming system calls. The default Docker seccomp profile works on a whitelist basis and allows for a large number of common system calls, whilst blocking all others. This filtering should not be disabled unless it causes a problem with your container application usage.\n\nRationale:\n\nA large number of system calls are exposed to every userland process with many of them going unused for the entire lifetime of the process. Most of applications do not need all these system calls and would therefore benefit from having a reduced set of available system calls. Having a reduced set of system calls reduces the total kernel surface exposed to the application and thus improvises application security.\n\nImpact:\n\nWith Docker 1.10 and greater, the default seccomp profile blocks syscalls, regardless of --cap-add passed to the container. You should create your own custom seccomp profile in such cases. You may also disable the default seccomp profile by passing --security-opt=seccomp:unconfined on docker run.",
        "solution": "By default, seccomp profiles are enabled. You do not need to do anything unless you want to modify and use a modified seccomp profile.\n\nDefault Value:\n\nWhen you run a container, it uses the default profile unless you override it with the --security-opt option.",
        "reference": "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.5,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|1M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' | grep 'seccomp:unconfined' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_78": {
        "description": "5.25 Ensure that cgroup usage is confirmed",
        "info": "It is possible to attach to a particular cgroup when a container is instantiated. Confirming cgroup usage would ensure that containers are running in defined cgroups.\n\nRationale:\n\nSystem administrators typically define cgroups in which containers are supposed to run. If cgroups are not explicitly defined by the system administrator, containers run in the docker cgroup by default.\n\nAt run time, it is possible to attach a container to a different cgroup other than the one originally defined. This usage should be monitored and confirmed, as by attaching to a different cgroup, excess permissions and resources might be granted to the container and this can therefore prove to be a security risk.\n\nImpact:\n\nNone.",
        "solution": "You should not use the --cgroup-parent option within the docker run command unless strictly required.\n\nDefault Value:\n\nBy default, containers run under docker cgroup.",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CgroupParent={{ .HostConfig.CgroupParent }}' | egrep -v 'CgroupParent=$' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_79": {
        "description": "5.26 Ensure that the container is restricted from acquiring additional privileges",
        "info": "You should restrict the container from acquiring additional privileges via suid or sgid bits.\n\nRationale:\n\nA process can set the no_new_priv bit in the kernel and this persists across forks, clones and execve. The no_new_priv bit ensures that the process and its child processes do not gain any additional privileges via suid or sgid bits. This reduces the danger associated with many operations because the possibility of subverting privileged binaries is lessened.\n\nImpact:\n\nThe no_new_priv option prevents LSMs like SELinux from allowing processes to acquire new privileges",
        "solution": "You should start your container with the options below:\n\ndocker run --rm -it --security-opt=no-new-privileges ubuntu bash\n\nDefault Value:\n\nBy default, new privileges are not restricted.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}' | grep -v no-new-privileges | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_80": {
        "description": "5.27 Ensure that container health is checked at runtime",
        "info": "If the container image does not have an HEALTHCHECK instruction defined, you should use the --health-cmd parameter at container runtime to check container health.\n\nRationale:\n\nIf the container image you are using does not have a pre-defined HEALTHCHECK instruction, use the --health-cmd parameter to check container health at runtime.\n\nBased on the reported health status, remedial actions can be taken if necessary.\n\nImpact:\n\nNone.",
        "solution": "You should run the container using the --health-cmd parameter.\nFor example:\n\ndocker run -d --health-cmd='stat /etc/passwd || exit 1' nginx\n\nDefault Value:\n\nBy default, health checks are not carried out at container runtime.",
        "reference": "800-53|SI-16,800-53r5|SI-16,CSCv7|3.1,CSCv8|10.5,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SI-16,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Health={{ .State.Health.Status }}' 2>&1 | grep -v 'Health=' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_81": {
        "description": "5.29 Ensure that the PIDs cgroup limit is used",
        "info": "You should use the --pids-limit flag at container runtime.\n\nRationale:\n\nAttackers could launch a fork bomb with a single command inside the container. This fork bomb could crash the entire system and would require a restart of the host to make the system functional again. Using the PIDs cgroup parameter --pids-limit would prevent this kind of attack by restricting the number of forks that can happen inside a container within a specified time frame.\n\nImpact:\n\nSet the PIDs limit value as appropriate. Incorrect values might leave containers unusable.",
        "solution": "Use --pids-limit flag with an appropriate value when launching the container.\nFor example:\n\ndocker run -it --pids-limit 100In the above example, the number of processes allowed to run at any given time is set to 100. After a limit of 100 concurrently running processes is reached, Docker would restrict any new process creation.\n\nDefault Value:\n\nThe Default value for --pids-limit is 0 which means there is no restriction on the number of forks. Note that the PIDs cgroup limit works only for kernel versions 4.3 and higher.",
        "reference": "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv7|5.2,CSCv8|4,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|1M,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: PidsLimit={{ .HostConfig.PidsLimit }}'",
        "expect": "^((?!PidsLimit=(0|-1)).)*$"
    },
    "custom_item_82": {
        "description": "5.31 Ensure that the host's user namespaces are not shared",
        "info": "You should not share the host's user namespaces with containers running on it.\n\nRationale:\n\nUser namespaces ensure that a root process inside the container will be mapped to a non-root process outside the container. Sharing the user namespaces of the host with the container does not therefore isolate users on the host from users in the containers.\n\nImpact:\n\nNone",
        "solution": "You should not share user namespaces between host and containers.\nFor example, you should not run the command below:\n\ndocker run --rm -it --userns=host ubuntu bash\n\nDefault Value:\n\nBy default, the host user namespace is shared with containers unless user namespace support is enabled.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|12,CSCv7|14.1,CSCv8|3.12,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: UsernsMode={{ .HostConfig.UsernsMode }}' | egrep -v 'UsernsMode=$' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_83": {
        "description": "5.32 Ensure that the Docker socket is not mounted inside any containers",
        "info": "The Docker socket docker.sock should not be mounted inside a container.\n\nRationale:\n\nIf the Docker socket is mounted inside a container it could allow processes running within the container to execute Docker commands which would effectively allow for full control of the host.\n\nImpact:\n\nNone",
        "solution": "You should ensure that no containers mount docker.sock as a volume.\n\nDefault Value:\n\nBy default, docker.sock is not mounted inside containers.",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Volumes={{ .Mounts }}' | grep 'docker.sock' | awk '{ print } END { if (NR==0) print \"none\" }'",
        "expect": "^none$"
    },
    "custom_item_84": {
        "description": "6.1 Ensure that image sprawl is avoided",
        "info": "You should not keep a large number of container images on the same host. Use only tagged images as appropriate.\n\nRationale:\n\nTagged images are useful if you need to fall back from the 'latest' version to a specific version of an image in production. Images with unused or old tags may contain vulnerabilities that might be exploited if instantiated.\n\nImpact:\n\ndocker system prune -a removes all exited containers as well as all images and volumes that are not referenced by running containers. If any images are removed, this would result in needing to reload the images to the host.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "You should keep only the images that you actually need and establish a workflow to remove old or stale images from the host. Additionally, you should use features such as pull-by-digest to get specific images from the registry.\nYou can follow the steps below to find unused images on the system so they can be deleted.\nStep 1 Make a list of all image IDs that are currently instantiated by executing the command below:\n\ndocker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'\n\nStep 2: List all the images present on the system by executing the command below:\n\ndocker images\n\nStep 3: Compare the list of image IDs created from Step 1 and Step 2 to find out images which are currently not being instantiated.\nStep 4: Decide if you want to keep the images that are not currently in use. If they are not needed, delete them by executing the following command:\n\ndocker rmiAlternatively, the docker system prune command can be used to remove dangling images which are not tagged or, if necessary, all images that are not currently used by a running container when used with the -a option.\n\nDefault Value:\n\nImages and layered filesystems remain accessible on the host until the administrator removes all tags that refer to those images or layers.",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|PL-8,800-53|SA-8,800-53r5|PL-8,800-53r5|SA-8,CSCv7|5.3,CSCv8|16.10,CSF|ID.AM-3,CSF|PR.IP-2,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|1M,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2,QCSC-v1|4.2,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}' ; docker images",
        "expect": "MANUAL_REVIEW"
    },
    "custom_item_85": {
        "description": "6.2 Ensure that container sprawl is avoided",
        "info": "You should not keep a large number of containers on the same host.\n\nRationale:\n\nThe flexibility of containers makes it easy to run multiple instances of applications and therefore indirectly leads to Docker images that can exist at varying security patch levels. It also means that you are consuming host resources that otherwise could have been used for running 'useful' containers. Having more than just an essential number of containers on a particular host makes the system vulnerable to mishandling, misconfiguration and fragmentation. You should therefore keep the number of containers on a given host to the minimum number commensurate with serving production applications.\n\nImpact:\n\nYou should retain containers that are actively in use, and delete ones which are no longer needed.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "You should periodically check your container inventory on each host and clean up containers which are not in active use with the command below:\n\ndocker container prune\n\nDefault Value:\n\nBy default, Docker does not restrict the number of containers you may have on a host.",
        "reference": "800-171|3.13.4,800-53|SC-4,800-53r5|SC-4,CSCv7|5.1,CSCv8|3.12,CSCv8|4,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SC-4,ITSG-33|SC-4a.,LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/files/4532",
        "cmd": "echo Containers: $(docker info --format '{{ .Containers }}'); echo Stopped: $(docker info --format '{{ .ContainersStopped }}'); echo Running: $(docker info --format '{{ .ContainersRunning }}')",
        "expect": "MANUAL_REVIEW"
    }
}