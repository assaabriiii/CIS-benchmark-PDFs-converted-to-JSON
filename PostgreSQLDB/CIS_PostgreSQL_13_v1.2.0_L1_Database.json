{
    "custom_item_1": {
        "description": "PostgreSQL version is 13",
        "sql_request": "select version()",
        "sql_expect": "^[\\\\s]*PostgreSQL 13\\..*"
    },
    "custom_item_2": {
        "description": "3.1.2 Ensure the log destinations are set correctly",
        "info": "PostgreSQL supports several methods for logging server messages, including stderr, csvlog, syslog, and jsonlog. On Windows, eventlog is also supported. One or more of these destinations should be set for server log output.\n\nRationale:\n\nIf log_destination is not set, then any log messages generated by the core PostgreSQL processes will be lost.",
        "solution": "Execute the following SQL statements to remediate this setting (in this example, setting the log destination to csvlog):\n\npostgres=# alter system set log_destination = 'csvlog';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nNote: If more than one log destination is to be used, set this parameter to a list of desired log destinations separated by commas (e.g. 'csvlog, stderr').\n\nDefault Value:\n\nstderr",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_destination",
        "sql_expect": "@LOG_DEST@"
    },
    "custom_item_3": {
        "description": "3.1.3 Ensure the logging collector is enabled",
        "info": "The logging collector is a background process that captures log messages sent to stderr and redirects them into log files. The logging_collector setting must be enabled in order for this process to run. It can only be set at the server start.\n\nRationale:\n\nThe logging collector approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. One common example is dynamic-linker failure message; another may be error messages produced by scripts such as archive_command.\n\nNote: This setting must be enabled when log_destination is either stderr or csvlog or logs will be lost. Certain other logging parameters require it as well.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set logging_collector = 'on';\nALTER SYSTEM\n\nUnfortunately, this setting can only be changed at the server (re)start. As root, restart the PostgreSQL service for this change to take effect:\n\n# whoami\nroot\n# systemctl restart postgresql-13\n# systemctl status postgresql-13|grep 'ago$'\n   Active: active (running) since;s ago\n\nDefault Value:\n\non",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show logging_collector",
        "sql_expect": "on"
    },
    "custom_item_4": {
        "description": "3.1.4 Ensure the log file destination directory is set correctly",
        "info": "The log_directory setting specifies the destination directory for log files when log_destination is stderr or csvlog. It can be specified as relative to the cluster data directory ($PGDATA) or as an absolute path. log_directory should be set according to your organization's logging policy.\n\nRationale:\n\nIf log_directory is not set, it is interpreted as the absolute path '/' and PostgreSQL will attempt to write its logs there (and typically fail due to a lack of permissions to that directory). This parameter should be set to direct the logs into the appropriate directory location as defined by your organization's logging policy.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set log_directory='/var/log/postgres';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\npostgres=# show log_directory;\n log_directory\n---------------\n /var/log/postgres\n(1 row)\n\nNote: The use of /var/log/postgres, above, is an example. This should be set to an appropriate path as defined by your organization's logging requirements. Having said that, it is a good idea to have the logs outside of your PGDATA directory so that they are not included by things like pg_basebackup or pgBackRest.\n\nDefault Value:\n\nlog which is relative to the cluster's data directory (e.g. /var/lib/pgsql//data/log)",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_directory",
        "sql_expect": "@LOG_DIR@"
    },
    "custom_item_5": {
        "description": "3.1.5 Ensure the filename pattern for log files is set correctly",
        "info": "The log_filename setting specifies the filename pattern for log files. The value for log_filename should match your organization's logging policy.\n\nThe value is treated as a strftime pattern, so %-escapes can be used to specify time-varying file names. The supported %-escapes are similar to those listed in the Open Group's strftime specification. If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the partition that contains log_directory. If there are any time-zone-dependent %-escapes, the computation is done in the zone specified by log_timezone. Also, the system's strftime is not used directly, so platform-specific (nonstandard) extensions do not work.\n\nIf CSV-format output is enabled in log_destination, .csv will be appended to the log filename. (If log_filename ends in .log, the suffix is replaced instead.)\n\nRationale:\n\nIf log_filename is not set, then the value of log_directory is appended to an empty string and PostgreSQL will fail to start as it will try to write to a directory instead of a file.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set log_filename='postgresql-%Y%m%d.log';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\npostgres=# show log_filename;\n   log_filename\n-------------------\n postgresql-%Y%m%d.log\n(1 row)\n\nNote: In this example, a new log file will be created for each day (e.g. postgresql-20200804.log)\n\nDefault Value:\n\nThe default is postgresql-%a.log, which creates a new log file for each day of the week (e.g. postgresql-Mon.log, postgresql-Tue.log).",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_filename",
        "sql_expect": "@LOG_FILE_NAMES@"
    },
    "custom_item_6": {
        "description": "3.1.6 Ensure the log file permissions are set correctly",
        "info": "The log_file_mode setting determines the file permissions for log files when logging_collector is enabled. The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format, the number must start with a 0 (zero).)\n\nThe permissions should be set to allow only the necessary access to authorized personnel. In most cases, the best setting is 0600, so that only the server owner can read or write the log files. The other commonly useful setting is 0640, allowing members of the owner's group to read the files, although to make use of that, you will need to either alter the log_directory setting to store the log files outside the cluster data directory or use PGSETUP_INITDB_OPTIONS='-k -g' when initializing the cluster.\n\nRationale:\n\nLog files often contain sensitive data. Allowing unnecessary access to log files may inadvertently expose sensitive data to unauthorized personnel.",
        "solution": "Execute the following SQL statement(s) to remediate this setting (with the example assuming the desired value of 0600):\n\npostgres=# alter system set log_file_mode = '0600';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\npostgres=# show log_file_mode;\n log_file_mode\n---------------\n 0600\n(1 row)\n\nDefault Value:\n\n0600",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_file_mode",
        "sql_expect": "@LOG_FILE_PERMS@"
    },
    "custom_item_7": {
        "description": "3.1.7 Ensure 'log_truncate_on_rotation' is enabled",
        "info": "Enabling the log_truncate_on_rotation setting when logging_collector is enabled causes PostgreSQL to truncate (overwrite) existing log files with the same name during log rotation instead of appending to them. For example, using this setting in combination with a log_filename setting value like postgresql-%H.log would result in generating 24 hourly log files and then cyclically overwriting them:\n\npostgresql-00.log\n\npostgresql-01.log\n\n[...]\n\npostgresql-23.log\n\nNote: Truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation (see later in this benchmark for size-based rotation details).\n\nRationale:\n\nIf this setting is disabled, pre-existing log files will be appended to if log_filename is configured in such a way that static or recurring names are generated.\n\nEnabling or disabling the truncation should only be decided when also considering the value of log_filename and log_rotation_age/log_rotation_size. Some examples to illustrate the interaction between these settings:\n\n# truncation is moot, as each rotation gets a unique filename (postgresql-20180605.log)\n\nlog_truncate_on_rotation = on\n\nlog_filename = 'postgresql-%Y%m%d.log'\n\nlog_rotation_age = '1d'\n\nlog_rotation_size = 0\n\n# truncation every hour, losing log data every hour until the date changes\n\nlog_truncate_on_rotation = on\n\nlog_filename = 'postgresql-%Y%m%d.log'\n\nlog_rotation_age = '1h'\n\nlog_rotation_size = 0\n\n# no truncation if the date changed before generating 100M of log data, truncation otherwise\n\nlog_truncate_on_rotation = on\n\nlog_filename = 'postgresql-%Y%m%d.log'\n\nlog_rotation_age = '0'\n\nlog_rotation_size = '100M'",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set log_truncate_on_rotation = 'on';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\npostgres=# show log_truncate_on_rotation;\n log_truncate_on_rotation\n--------------------------\n on\n(1 row)\n\nDefault Value:\n\non",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_truncate_on_rotation",
        "sql_expect": "on"
    },
    "custom_item_8": {
        "description": "1.5 Ensure the Latest Security Patches are Applied",
        "info": "PostgreSQL updates are released to resolve bugs, and mitigate vulnerabilities quarterly (or sooner for drastic CVEs). It is recommended that PostgreSQL installations are kept up to date with the latest security updates. The PostgreSQL development group guarantees that point releases (or 'minor releases') will not change the behavior of an existing install and as such are 'safe' to install without fear of changes to your application's behavior.\n\nRationale:\n\nMaintaining cparity with PostgreSQL patches will help reduce the risk associated with known vulnerabilities present in the PostgreSQL server.\n\nWithout the latest security patches, PostgreSQL might have known vulnerabilities which could be used by an attacker to gain access.\n\nImpact:\n\nTo update the PostgreSQL server a restart is required which will cause a momentary service outage.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Install the latest patches available for your version:\nRHEL:\n\nsudo dnf update $(rpm -qa | grep '^postgresql')\n\nDebian:\n\nsudo apt-get install --only-upgrade $(dpkg-query -W -f '${db:Status-Status} ${Package}\\n' 'postgresql*' | awk '$1 != 'not-installed' {print $NF}')",
        "reference": "800-53|SA-22,800-53r5|SA-22,CSCv8|2.2,GDPR|32.1.b,HIPAA|164.306(a)(1),LEVEL|1M",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SHOW server_version;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_9": {
        "description": "3.1.8 Ensure the maximum log file lifetime is set correctly",
        "info": "When logging_collector is enabled, the log_rotation_age parameter determines the maximum lifetime of an individual log file (depending on the value of log_filename). After this many minutes have elapsed, a new log file will be created via automatic log file rotation. Current best practices advise log rotation at least daily, but your organization's logging policy should dictate your rotation schedule.\n\nRationale:\n\nLog rotation is a standard best practice for log management.",
        "solution": "Execute the following SQL statement(s) to remediate this setting (in this example, setting it to one hour):\n\npostgres=# alter system set log_rotation_age='1h';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\n1d (one day)",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_rotation_age",
        "sql_expect": "@LOG_ROT_AGE@"
    },
    "custom_item_10": {
        "description": "3.1.9 Ensure the maximum log file size is set correctly",
        "info": "The log_rotation_size setting determines the maximum size of an individual log file. Once the maximum size is reached, automatic log file rotation will occur.\n\nRationale:\n\nIf this is set to zero, the size-triggered creation of new log files is disabled. This will prevent automatic log file rotation when files become too large, which could put log data at increased risk of loss (unless age-based rotation is configured).",
        "solution": "Execute the following SQL statement(s) to remediate this setting (in this example, setting it to 1GB):\n\npostgres=# alter system set log_rotation_size = '1GB';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\n0",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_rotation_size",
        "sql_expect": "@LOG_ROT_SIZE@"
    },
    "custom_item_11": {
        "description": "3.1.10 Ensure the correct syslog facility is selected",
        "info": "The syslog_facility setting specifies the syslog 'facility' to be used when logging to syslog is enabled. You can choose from any of the 'local' facilities:\n\nLOCAL0\n\nLOCAL1\n\nLOCAL2\n\nLOCAL3\n\nLOCAL4\n\nLOCAL5\n\nLOCAL6\n\nLOCAL7\n\nYour organization's logging policy should dictate which facility to use based on the syslog daemon in use.\n\nRationale:\n\nIf not set to the appropriate facility, the PostgreSQL log messages may be intermingled with other applications' log messages, incorrectly routed, or potentially dropped (depending on your syslog configuration).",
        "solution": "Execute the following SQL statement(s) to remediate this setting (in this example, setting it to the LOCAL1 facility):\n\npostgres=# alter system set syslog_facility = 'LOCAL1';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\nLOCAL0",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1M,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show syslog_facility",
        "sql_expect": "@SYSLOG_FACILITY@"
    },
    "custom_item_12": {
        "description": "3.1.11 Ensure syslog messages are not suppressed",
        "info": "When logging to Syslog and syslog_sequence_numbers is on, then each message will be prefixed by an increasing sequence number (such as [2]).\n\nRationale:\n\nMany modern Syslog implementations perform a log optimization and suppress repeated log entries while emitting '--- last message repeated N times ---'. In more modern Syslog implementations, repeated message suppression can be configured (for example, $RepeatedMsgReduction in rsyslog).\n\nImpact:\n\nIf disabled, messages sent to Syslog could be suppressed and not logged. While a message is emitted stating that a given message was repeated and suppressed, the timestamp associated with these suppressed messages is lost, potentially damaging the recreation of an incident timeline.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set syslog_sequence_numbers = 'on';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\non",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show syslog_sequence_numbers",
        "sql_expect": "on"
    },
    "custom_item_13": {
        "description": "3.1.12 Ensure syslog messages are not lost due to size",
        "info": "PostgreSQL log messages can exceed 1024 bytes, which is a typical size limit for traditional Syslog implementations. When syslog_split_messages is off, PostgreSQL server log messages are delivered to the Syslog service as is, and it is up to the Syslog service to cope with the potentially bulky messages. When syslog_split_messages is on, messages are split by lines, and long lines are split so that they will fit into 1024 bytes.\n\nIf syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.\n\nRationale:\n\nImpact:\n\nDepending on the Syslog server in use, log messages exceeding 1024 bytes may be lost or, potentially, cause the Syslog server processes to abort.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set syslog_split_messages = 'on';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\non",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show syslog_split_messages",
        "sql_expect": "on"
    },
    "custom_item_14": {
        "description": "3.1.13 Ensure the program name for PostgreSQL syslog messages is correct",
        "info": "The syslog_ident setting specifies the program name used to identify PostgreSQL messages in syslog logs. An example of a possible program name is postgres.\n\nRationale:\n\nIf this is not set correctly, it may be difficult or impossible to distinguish PostgreSQL messages from other messages in Syslog logs.",
        "solution": "Execute the following SQL statement(s) to remediate this setting (in this example, assuming a program name of proddb):\n\npostgres=# alter system set syslog_ident = 'proddb';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\npostgres=# show syslog_ident;\n syslog_ident\n--------------\n proddb\n(1 row)\n\nDefault Value:\n\npostgres",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show syslog_ident",
        "sql_expect": "@SYSLOG_IDENT@"
    },
    "custom_item_15": {
        "description": "3.1.14 Ensure the correct messages are written to the server log",
        "info": "The log_min_messages setting specifies the message levels that are written to the server log. Each level includes all the levels that follow it. The lower the level (vertically, below), the fewer messages are logged.\n\nValid values are:\n\nDEBUG5 <-- exceedingly chatty\n\nDEBUG4\n\nDEBUG3\n\nDEBUG2\n\nDEBUG1\n\nINFO\n\nNOTICE\n\nWARNING <-- default\n\nERROR\n\nLOG\n\nFATAL\n\nPANIC <-- practically mute\n\nWARNING is considered the best practice unless indicated otherwise by your organization's logging policy.\n\nRationale:\n\nIf this is not set to the correct value, too many or too few messages may be written to the server log.",
        "solution": "Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to set it to warning):\n\npostgres=# alter system set log_min_messages = 'warning';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\nWARNING",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_min_messages",
        "sql_expect": "^(?i)\\b(DEBUG[1-5]|INFO|NOTICE|WARNING)\\b$"
    },
    "custom_item_16": {
        "description": "3.1.15 Ensure the correct SQL statements generating errors are recorded",
        "info": "The log_min_error_statement setting causes all SQL statements generating errors at or above the specified severity level to be recorded in the server log. Each level includes all the levels that follow it. The lower the level (vertically, below), the fewer messages are recorded. Valid values are:\n\nDEBUG5 <-- exceedingly chatty\n\nDEBUG4\n\nDEBUG3\n\nDEBUG2\n\nDEBUG1\n\nINFO\n\nNOTICE\n\nWARNING\n\nERROR <-- default\n\nLOG\n\nFATAL\n\nPANIC <-- practically mute\n\nERROR is considered the best practice setting. Changes should only be made in accordance with your organization's logging policy.\n\nNote: To effectively turn off logging of failing statements, set this parameter to PANIC.\n\nRationale:\n\nIf this is not set to the correct value, too many erring or too few erring SQL statements may be written to the server log.",
        "solution": "Execute the following SQL statement(s) as superuser to remediate this setting (in the example, to error):\n\npostgres=# alter system set log_min_error_statement = 'error';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\nERROR",
        "reference": "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_min_error_statement",
        "sql_expect": "^(?i)\\b(DEBUG[1-5]|INFO|NOTICE|WARNING|ERROR)\\b$"
    },
    "custom_item_17": {
        "description": "3.1.16 Ensure 'debug_print_parse' is disabled",
        "info": "The debug_print_parse setting enables printing the resulting parse tree for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.\n\nRationale:\n\nEnabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set debug_print_parse='off';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\noff",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show debug_print_parse",
        "sql_expect": "off"
    },
    "custom_item_18": {
        "description": "3.1.17 Ensure 'debug_print_rewritten' is disabled",
        "info": "The debug_print_rewritten setting enables printing the query rewriter output for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.\n\nRationale:\n\nEnabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.",
        "solution": "Execute the following SQL statement(s) to disable this setting:\n\npostgres=# alter system set debug_print_rewritten = 'off';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\noff",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show debug_print_rewritten",
        "sql_expect": "off"
    },
    "custom_item_19": {
        "description": "3.1.18 Ensure 'debug_print_plan' is disabled",
        "info": "The debug_print_plan setting enables printing the execution plan for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.\n\nRationale:\n\nEnabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings.",
        "solution": "Execute the following SQL statement(s) to disable this setting:\n\npostgres=# alter system set debug_print_plan = 'off';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\noff",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show debug_print_plan",
        "sql_expect": "off"
    },
    "custom_item_20": {
        "description": "3.1.19 Ensure 'debug_pretty_print' is enabled",
        "info": "Enabling debug_pretty_print indents the messages produced by debug_print_parse, debug_print_rewritten, or debug_print_plan making them significantly easier to read.\n\nRationale:\n\nIf this setting is disabled, the 'compact' format is used instead, significantly reducing the readability of the DEBUG statement log messages.\n\nImpact:\n\nBe advised that the aforementioned DEBUG printing options are disabled, but if your organizational logging policy requires them to be on then this option comes into play.",
        "solution": "Execute the following SQL statement(s) to enable this setting:\n\npostgres=# alter system set debug_pretty_print = 'on';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\non",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show debug_pretty_print",
        "sql_expect": "on"
    },
    "custom_item_21": {
        "description": "3.1.20 Ensure 'log_connections' is enabled",
        "info": "Enabling the log_connections setting causes each attempted connection to the server to be logged, as well as successful completion of client authentication. This parameter cannot be changed after the session start.\n\nRationale:\n\nPostgreSQL does not maintain an internal record of attempted connections to the database for later auditing. It is only by enabling the logging of these attempts that one can determine if unexpected attempts are being made.\n\nNote that enabling this without also enabling log_disconnections provides little value. Generally, you would enable/disable the pair together.",
        "solution": "Execute the following SQL statement(s) to enable this setting:\n\npostgres=# alter system set log_connections = 'on';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nThen, in a new connection to the database, verify the change:\n\npostgres=# show log_connections;\n log_connections\n-----------------\n on\n(1 row)\n\nNote that you cannot verify this change in the same connection in which it was changed; a new connection is needed.\n\nDefault Value:\n\noff",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_connections",
        "sql_expect": "on"
    },
    "custom_item_22": {
        "description": "3.1.21 Ensure 'log_disconnections' is enabled",
        "info": "Enabling the log_disconnections setting logs the end of each session, including session duration. This parameter cannot be changed after the session start.\n\nRationale:\n\nPostgreSQL does not maintain the beginning or ending of a connection internally for later review. It is only by enabling the logging of these that one can examine connections for failed attempts, 'over long' duration, or other anomalies.\n\nNote that enabling this without also enabling log_connections provides little value. Generally, you would enable/disable the pair together.",
        "solution": "Execute the following SQL statement(s) to enable this setting:\n\npostgres=# alter system set log_disconnections = 'on';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\noff",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_disconnections",
        "sql_expect": "on"
    },
    "custom_item_23": {
        "description": "3.1.22 Ensure 'log_error_verbosity' is set correctly",
        "info": "The log_error_verbosity setting specifies the verbosity (amount of detail) of logged messages. Valid values are:\n\nTERSE\n\nDEFAULT\n\nVERBOSE\n\nwith each containing the fields of the level above it as well as additional fields.\n\nTERSE excludes the logging of DETAIL, HINT, QUERY, and CONTEXT error information.\n\nVERBOSE output includes the SQLSTATE, error code, and the source code file name, function name, and line number that generated the error.\n\nThe appropriate value should be set based on your organization's logging policy.\n\nRationale:\n\nIf this is not set to the correct value, too many details or too few details may be logged.",
        "solution": "Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to verbose):\n\npostgres=# alter system set log_error_verbosity = 'verbose';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\nDEFAULT",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_error_verbosity",
        "sql_expect": "@LOG_ERR_VERBOSITY@"
    },
    "custom_item_24": {
        "description": "3.1.23 Ensure 'log_hostname' is set correctly",
        "info": "Enabling the log_hostname setting causes the hostname of the connecting host to be logged in addition to the host's IP address for connection log messages. Disabling the setting causes only the connecting host's IP address to be logged, and not the hostname. Unless your organization's logging policy requires hostname logging, it is best to disable this setting so as not to incur the overhead of DNS resolution for each statement that is logged.\n\nRationale:\n\nDepending on your hostname resolution setup, enabling this setting might impose a non-negligible performance penalty. Additionally, the IP addresses that are logged can be resolved to their DNS names when reviewing the logs (unless dynamic hostnames are being used as part of your DHCP setup).",
        "solution": "Execute the following SQL statement(s) to remediate this setting (in this example, to off):\n\npostgres=# alter system set log_hostname='off';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\noff",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_hostname",
        "sql_expect": "@LOG_HOSTNAME@"
    },
    "custom_item_25": {
        "description": "3.1.24 Ensure 'log_line_prefix' is set correctly",
        "info": "The log_line_prefix setting specifies a printf-style string that is prefixed to each log line. If blank, no prefix is used. You should configure this as recommended by the pgBadger development team unless directed otherwise by your organization's logging policy.\n\n% characters begin 'escape sequences' that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the logline. Some escapes are only recognized by session processes and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.\n\nAny of the following escape sequences can be used:\n\n%a = application name\n\n%u = user name\n\n%d = database name\n\n%r = remote host and port\n\n%h = remote host\n\n%b = backend type\n\n%p = process ID\n\n%P = process ID of parallel group leader\n\n%t = timestamp without milliseconds\n\n%m = timestamp with milliseconds\n\n%n = timestamp with milliseconds (as a Unix epoch)\n\n%Q = query ID (0 if none or not computed)\n\n%i = command tag\n\n%e = SQL state\n\n%c = session ID\n\n%l = session line number\n\n%s = session start timestamp\n\n%v = virtual transaction ID\n\n%x = transaction ID (0 if none)\n\n%q = stop here in non-session processes\n\n%% = '%'\n\nRationale:\n\nProperly setting log_line_prefix allows for adding additional information to each log entry (such as the user, or the database). Said information may then be of use in auditing or security reviews.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set log_line_prefix = '%m [%p]: [%l-1] db=%d,user=%u,app=%a,client=%h ';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\n%m [%p]",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_line_prefix",
        "sql_expect": "@LOG_LINE_PREFIX@[\\\\s]*"
    },
    "custom_item_26": {
        "description": "3.1.25 Ensure 'log_statement' is set correctly",
        "info": "The log_statement setting specifies the types of SQL statements that are logged. Valid values are:\n\nnone (off)\n\nddl\n\nmod\n\nall (all statements)\n\nIt is recommended this be set to ddl unless otherwise directed by your organization's logging policy.\n\nddl logs all data definition statements:\n\nCREATE\n\nALTER\n\nDROP\n\nmod logs all ddl statements, plus data-modifying statements:\n\nINSERT\n\nUPDATE\n\nDELETE\n\nTRUNCATE\n\nCOPY FROM\n\n(PREPARE, EXECUTE, and EXPLAIN ANALYZE statements are also logged if their contained command is of an appropriate type.)\n\nFor clients using extended query protocol, logging occurs when an Execute message is received, and values of the Bind parameters are included (with any embedded single-quote marks doubled).\n\nRationale:\n\nSetting log_statement to align with your organization's security and logging policies facilitates later auditing and review of database activities.",
        "solution": "Execute the following SQL statement(s) as superuser to remediate this setting:\n\npostgres=# alter system set log_statement='ddl';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\nnone",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_statement",
        "sql_expect": "@LOG_STMT@"
    },
    "custom_item_27": {
        "description": "3.1.26 Ensure 'log_timezone' is set correctly",
        "info": "The log_timezone setting specifies the time zone to use in timestamps within log messages. This value is cluster-wide, so that all sessions will report timestamps consistently. Unless directed otherwise by your organization's logging policy, set this to either GMT or UTC.\n\nRationale:\n\nLog entry timestamps should be configured for an appropriate time zone as defined by your organization's logging policy to ensure a lack of confusion around when a logged event occurred.\n\nNote that this setting affects only the timestamps present in the logs. It does not affect the time zone in use by the database itself (for example, select now()), nor does it affect the host's time zone.",
        "solution": "Execute the following SQL statement(s) to remediate this setting:\n\npostgres=# alter system set log_timezone = 'GMT';\nALTER SYSTEM\npostgres=# select pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\n\nDefault Value:\n\nBy default, the PGDG packages will set this to match the server's timezone in the Operating System.",
        "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|1A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_timezone",
        "sql_expect": "@LOG_TIMEZONE@"
    },
    "custom_item_28": {
        "description": "show pgaudit.log",
        "sql_request": "show pgaudit.log",
        "sql_expect": "(read|write|function|role|ddl|misc)"
    },
    "custom_item_29": {
        "description": "pgaudit installed",
        "sql_request": "show shared_preload_libraries",
        "sql_expect": "pgaudit"
    },
    "custom_item_30": {
        "description": "4.3 Ensure excessive administrative privileges are revoked",
        "info": "With respect to PostgreSQL administrative SQL commands, only superusers should have elevated privileges. PostgreSQL regular, or application, users should not possess the ability to create roles, create new databases, manage replication, or perform any other action deemed privileged. Typically, regular users should only be granted the minimal set of privileges commensurate with managing the application:\n\nDDL (create table, create view, create index, etc.)\n\nDML (select, insert, update, delete)\n\nFurther, it has become best practice to create separate roles for DDL and DML. Given an application called 'payroll', one would create the following users:\n\npayroll_owner\n\npayroll_user\n\nAny DDL privileges would be granted to the payroll_owner account only, while DML privileges would be given to the payroll_user account only. This prevents accidental creation/altering/dropping of database objects by application code that runs as the payroll_user account.\n\nRationale:\n\nBy not restricting global administrative commands to superusers only, regular users granted excessive privileges may execute administrative commands with unintended and undesirable results.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "If any regular or application users have been granted excessive administrative rights, those privileges should be removed immediately via the PostgreSQL ALTER ROLE SQL command. Using the same example above, the following SQL statements revoke all unnecessary elevated administrative privileges from the regular user appuser:\n\n# whoami\npostgres\n# psql -c 'ALTER ROLE appuser NOSUPERUSER;'\nALTER ROLE\n# psql -c 'ALTER ROLE appuser NOCREATEROLE;'\nALTER ROLE\n# psql -c 'ALTER ROLE appuser NOCREATEDB;'\nALTER ROLE\n# psql -c 'ALTER ROLE appuser NOREPLICATION;'\nALTER ROLE\n# psql -c 'ALTER ROLE appuser NOBYPASSRLS;'\nALTER ROLE\n# psql -c 'ALTER ROLE appuser NOINHERIT;'\nALTER ROLE\n\nVerify the appuser now passes your check by having no defined Attributes:\n\n# whoami\npostgres\n# psql -c '\\du+ appuser'\n          List of roles\nRole name | Attributes | Description\n----------+------------+-----------\nappuser   |            |",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select * from pg_user order by usename;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_31": {
        "description": "4.4 Lock Out Accounts if Not Currently in Use",
        "info": "If users with database accounts will not be using the database for some time, disabling the account will reduce the risk of attacks or inappropriate account usage.\n\nRationale:\n\nOnly actively used database accounts should be allowed to login to the database.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "To lock accounts, as a superuser, run:\n\nALTER ROLENOLOGIN;\n\nTo unlock accounts, as a superuser, runL\n\nALTER ROLELOGIN;\n\nDefault Value:\n\nAccounts created by CREATE ROLE are NOLOGIN by default. Accounts created by CREATE USER are LOGIN by default.\n\nAdditional Information:\n\nIt is possible to specify NOLOGIN when using both CREATE ROLE and CREATE USER:\n\nCREATE ROLENOLOGIN;\n\nCREATE USERNOLOGIN;",
        "reference": "800-171|3.1.1,800-53|AC-2(3),800-53r5|AC-2(3),CN-L3|7.1.3.2(e),CN-L3|8.1.4.2(c),CSCv8|5.3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ISO/IEC-27001|A.9.2.6,ITSG-33|AC-2(3),LEVEL|1M,NIAv2|AM26,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2,TBA-FIISB|36.2.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SELECT rolname FROM pg_catalog.pg_roles WHERE rolname !~ '^pg_' AND rolcanlogin;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_32": {
        "description": "4.5 Ensure excessive function privileges are revoked",
        "info": "In certain situations, to provide the required functionality, PostgreSQL needs to execute internal logic (stored procedures, functions, triggers, etc.) and/or external code modules with elevated privileges. However, if the privileges required for execution are at a higher level than the privileges assigned to organizational users invoking the functionality applications/programs, those users are indirectly provided with greater privileges than assigned by their organization. This is known as privilege elevation. Privilege elevation must be utilized only where necessary. Execute privileges for application functions should be restricted to authorized users only.\n\nRationale:\n\nIdeally, all application source code should be vetted to validate interactions between the application and the logic in the database, but this is usually not possible or feasible with available resources even if the source code is available. The DBA should attempt to obtain assurances from the development organization that this issue has been addressed and should document what has been discovered. The DBA should also inspect all application logic stored in the database (in the form of functions, rules, and triggers) for excessive privileges.",
        "solution": "Where possible, revoke SECURITY DEFINER on PostgreSQL functions. To change a SECURITY DEFINER function to SECURITY INVOKER, run the following SQL:\n\n# whoami\nroot\n# sudo -iu postgres\n# psql -c 'ALTER FUNCTION [functionname] SECURITY INVOKER;'\n\nIf it is not possible to revoke SECURITY DEFINER, ensure the function can be executed by only the accounts that absolutely need such functionality:\n\npostgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';\n     proname     |                         proacl\n-----------------+--------------------------------------------------------\n delete_customer | {=X/postgres,postgres=X/postgres,appreader=X/postgres}\n(1 row)\npostgres=# REVOKE EXECUTE ON FUNCTION delete_customer(integer,boolean) FROM appreader;\nREVOKE\npostgres=# SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';\n     proname     |                         proacl\n-----------------+--------------------------------------------------------\n delete_customer | {=X/postgres,postgres=X/postgres}\n(1 row)\n\nBased on the output above, appreader=X/postgres no longer exists in the proacl column results returned from the query and confirms appreader is no longer granted execute privilege on the function.",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1A,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SELECT nspname, proname, proargtypes, prosecdef, rolname, proconfig FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid JOIN pg_authid a ON a.oid = p.proowner WHERE proname NOT LIKE 'pgaudit%' AND (prosecdef OR NOT proconfig IS NULL);"
    },
    "custom_item_33": {
        "description": "4.7 Ensure Row Level Security (RLS) is configured correctly",
        "info": "In addition to the SQL-standard privilege system available through GRANT, tables can have row security policies that restrict, on a per-user basis, which individual rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as Row Level Security (RLS).\n\nBy default, tables do not have any policies, so if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating. Row security policies can be specific to commands, to roles, or to both. A policy can be specified to apply to ALL commands, or to any combination of SELECT, INSERT, UPDATE, or DELETE. Multiple roles can be assigned to a given policy, and normal role membership and inheritance rules apply.\n\nIf you use RLS and apply restrictive policies to certain users, it is important that the Bypass RLS privilege not be granted to any unauthorized users. This privilege overrides RLS-enabled tables and associated policies. Generally, only superusers and elevated users should possess this privilege.\n\nRationale:\n\nIf RLS policies and privileges are not configured correctly, users could perform actions on tables that they are not authorized to perform, such as inserting, updating, or deleting rows.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Again, we are using the example from the PostgreSQL documentation using the example passwd table. We will create three database roles to illustrate the workings of RLS:\n\npostgres=# CREATE USER admin;\nCREATE USER\npostgres=# CREATE USER bob;\nCREATE USER\npostgres=# CREATE USER alice;\nCREATE USER\n\nNow, we will insert known data into the passwd table:\n\npostgres=# INSERT INTO passwd VALUES\n  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');\nINSERT 0 1\npostgres=# INSERT INTO passwd VALUES\n  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');\nINSERT 0 1\npostgres=# INSERT INTO passwd VALUES\n  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');\nINSERT 0 1\n\nAnd we will enable RLS on the table:\n\npostgres=# ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;\nALTER TABLE\npostgres=# SELECT oid, relname, relrowsecurity FROM pg_class WHERE relname = 'passwd';\n  oid  | relname | relrowsecurity\n-------+---------+----------------\n 24679 | passwd  | t\n(1 row)\n\nNow that RLS is enabled, we need to define one or more policies. Create the administrator policy and allow it access to all rows:\n\npostgres=# CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);\nCREATE POLICY\n\nCreate a policy for normal users to view all rows:\n\npostgres=# CREATE POLICY all_view ON passwd FOR SELECT USING (true);\nCREATE POLICY\n\nCreate a policy for normal users that allows them to update only their own rows and to limit what values can be set for their login shell:\n\npostgres=# CREATE POLICY user_mod ON passwd FOR UPDATE\n  USING (current_user = user_name)\n  WITH CHECK (\n    current_user = user_name AND\n    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')\n  );\nCREATE POLICY\n\nGrant all the normal rights on the table to the admin user:\n\npostgres=# GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;\nGRANT\n\nGrant only select access on non-sensitive columns to everyone:\n\npostgres=# GRANT SELECT\n  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)\n  ON passwd TO public;\nGRANT\n\nGrant update to only the sensitive columns:\n\npostgres=# GRANT UPDATE\n  (pwhash, real_name, home_phone, extra_info, shell)\n  ON passwd TO public;\nGRANT\n\nEnsure that no one has been granted Bypass RLS inadvertently, by running the psql display command \\du+. If unauthorized users do have Bypass RLS granted then resolve this using the ALTER ROLENOBYPASSRLS; command.\nYou can now verify that 'admin', 'bob', and 'alice' are properly restricted by querying the passwd table as each of these roles.\n\npostgres=# set role admin;\nSET\npostgres=# table passwd;\n user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell\n-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------\n admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash\n bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh\n(3 rows)\npostgres=# set role alice;\nSET\npostgres=# table passwd;\nERROR:  permission denied for table passwd\npostgres=# select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;\n user_name | real_name |  home_phone  | extra_info | home_dir    |   shell\n-----------+-----------+--------------+------------+-------------+-----------\n admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash\n bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh\n(3 rows)\npostgres=# update passwd set user_name = 'joe';\nERROR:  permission denied for table passwd\n-- Alice is allowed to change her own real_name, but no others\npostgres=# update passwd set real_name = 'Alice Doe';\nUPDATE 1\npostgres=# update passwd set real_name = 'John Doe' where user_name = 'admin';\nUPDATE 0\npostgres=# select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;\n user_name | real_name |  home_phone  | extra_info |  home_dir   |   shell\n-----------+-----------+--------------+------------+-------------+-----------\n admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash\n bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n alice     | Alice Doe | 098-765-4321 |            | /home/alice | /bin/zsh\n(3 rows)\npostgres=# update passwd set shell = '/bin/xx';\nERROR:  new row violates WITH CHECK OPTION for 'passwd'\npostgres=# delete from passwd;\nERROR:  permission denied for table passwd\npostgres=# insert into passwd (user_name) values ('xxx');\nERROR:  permission denied for table passwd\n-- Alice can change her own password; RLS silently prevents updating other rows\npostgres=# update passwd set pwhash = 'abc';\nUPDATE 1",
        "reference": "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|1M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SELECT oid, relname, relrowsecurity FROM pg_class WHERE relrowsecurity IS TRUE;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_34": {
        "description": "4.8 Ensure the set_user extension is installed",
        "info": "PostgreSQL access to the superuser database role must be controlled and audited to prevent unauthorized access.\n\nNote: Prior to performing this audit you must create a roletree view. Here are the procedures to create this view:\n\npostgres=#\n\nDROP VIEW IF EXISTS roletree;\n\nCREATE OR REPLACE VIEW roletree AS\n\nWITH RECURSIVE\n\nroltree AS (\n\n  SELECT u.rolname AS rolname,\n\n         u.oid AS roloid,\n\n         u.rolcanlogin,\n\n         u.rolsuper,\n\n         '{}'::name[] AS rolparents,\n\n         NULL::oid AS parent_roloid,\n\n         NULL::name AS parent_rolname\n\n  FROM pg_catalog.pg_authid u\n\n  LEFT JOIN pg_catalog.pg_auth_members m on u.oid = m.member\n\n  LEFT JOIN pg_catalog.pg_authid g on m.roleid = g.oid\n\n  WHERE g.oid IS NULL\n\n  UNION ALL\n\n  SELECT u.rolname AS rolname,\n\n         u.oid AS roloid,\n\n         u.rolcanlogin,\n\n         u.rolsuper,\n\n         t.rolparents || g.rolname AS rolparents,\n\n         g.oid AS parent_roloid,\n\n         g.rolname AS parent_rolname\n\n  FROM pg_catalog.pg_authid u\n\n  JOIN pg_catalog.pg_auth_members m on u.oid = m.member\n\n  JOIN pg_catalog.pg_authid g on m.roleid = g.oid\n\n  JOIN roltree t on t.roloid = g.oid\n\n);\n\nSELECT\n\n  r.rolname,\n\n  r.roloid,\n\n  r.rolcanlogin,\n\n  r.rolsuper,\n\n  r.rolparents\n\nFROM roltree r\n\nORDER BY 1;\n\nRationale:\n\nEven when reducing and limiting the access to the superuser role as described earlier in this benchmark, it is still difficult to determine who accessed the superuser role and what actions were taken using that role. As such, it is ideal to prevent anyone from logging in as the superuser and forcing them to escalate their role. This model is used at the OS level by the use of sudo and should be emulated in the database. The set_user extension allows for this setup.\n\nImpact:\n\nMuch like the venerable sudo does for the OS, set_user manages superuser access for PostgreSQL. To complete configuration of set_user is documented at the extension's website and should be reviewed to ensure the logging entries that your organization cares about are properly configured.\n\nNote that some external tools assume they can connect as the postgres user by default and this is no longer true when set_user is deployed. You may find some tools need different options, reconfigured, or even abandoned to compensate for this.",
        "solution": "We will install the set_user extension:\n\n# whoami\nroot\n# dnf -y install set_user_13\n[snip]\nInstalled:\n  set_user_13-4.0.1-2.rhel9.1.x86_64\n\nComplete!\n\nNow that set_user is installed, we need to tell PostgreSQL to load its library:\n\n# whoami\nroot\n# vi ~postgres/13/data/postgresql.conf\n\nFind the shared_preload_libraries entry, and add 'set_user' to it (preserving any existing entries):\n\nshared_preload_libraries = 'set_user'\n\nOR\n\nshared_preload_libraries = 'set_user,pgaudit,somethingelse'\n\nRestart the PostgreSQL server for changes to take effect:\n\n# systemctl restart postgresql-13\n# systemctl status postgresql-13|grep 'ago$'\n   Active: active (running) since [timestamp]; 1s ago\n\nAnd now, we can install the extension with SQL:\n\n# su - postgres\n# psql\npostgres=# select * from pg_available_extensions where name = 'set_user';\n  name   | default_version | installed_version |                  comment\n---------+-----------------+-------------------+-----------------------------\nset_user | 4.0.1           |                   | similar to SET ROLE but with\n         |                 |                   | added logging\n(1 row)\n\npostgres=# create extension set_user;\nCREATE EXTENSION\npostgres=# select * from pg_available_extensions where name = 'set_user';\n  name   | default_version | installed_version |                  comment\n---------+-----------------+-------------------+-----------------------------\nset_user | 4.0.1           | 2.0               | similar to SET ROLE but with\n         |                 |                   | added logging\n(1 row)\n\nNow, we use GRANT to configure each DBA role to allow it to use the set_user functions. In the example below, we will configure my db user doug. (You would do this for each DBA's normal user role.)\n\npostgres=# grant execute on function set_user(text) to doug;\nGRANT\npostgres=# grant execute on function set_user_u(text) to doug;\nGRANT\n\nConnect to PostgreSQL as yourself and verify it works as expected:\n\n# whoami\npsql\n# psql -U doug -d postgres -h 127.0.0.1\npostgres=> select set_user('postgres');\nERROR:  switching to superuser not allowed\nHINT:  Use 'set_user_u' to escalate.\npostgres=> select set_user_u('postgres');\n set_user_u\n------------\n OK\n(1 row)\npostgres=# select current_user, session_user;\n current_user | session_user\n--------------+--------------\n postgres     | doug\n(1 row)\npostgres=# select reset_user();\n reset_user\n------------\n OK\n(1 row)\npostgres=> select current_user, session_user;\n current_user | session_user\n--------------+--------------\n doug         | doug\n(1 row)\n\nOnce all DBA's normal user accounts have been GRANTed permission, revoke the ability to login as the postgres (superuser) user:\n\npostgres=# ALTER USER postgres NOLOGIN;\nALTER ROLE\n\nWhich results in:\n\n$ psql\npsql: FATAL:  role 'postgres' is not permitted to log in\n$ psql -U doug -d postgres -h 127.0.0.1\npsql (13.14)\n\nRevoke SUPERUSER and/or LOGIN from any other roles that were previously identified:\n\npostgres=# ALTER USER usera NOSUPERUSER; -- revoke superuser\nALTER ROLE\npostgres=# ALTER USER usera NOLOGIN; -- revoke login\nALTER ROLE\npostgres=# ALTER USER usera NOSUPERUSER NOLOGIN; -- revoke both at once\nALTER ROLE\n\nNote that we show dropping the privileges both individually and as one. Pick an appropriate version based on your application/business needs.\nRemove any escalated privileges on users granted indirectly that were previously identified using the roletree view:\n\npostgres=# REVOKE name_of_granting_role FROM bob; -- an example only\nREVOKE ROLE",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select name from pg_available_extensions where name = 'set_user';",
        "sql_expect": "set_user"
    },
    "custom_item_35": {
        "description": "4.9 Make use of predefined roles",
        "info": "PostgreSQL provides a set of predefined roles that provide access to certain commonly needed privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.\nRationale:\nIn keeping with the principle of least privilege, judicious use of the PostgreSQL predefined roles can greatly limit the access to privileged, or superuser, access.\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "If you've determined that one or more of the predefined roles can be used, simply GRANT it:\npostgres=# GRANT pg_monitor TO doug;\nGRANT ROLE\nAnd then remove superuser from the account:\npostgres=# ALTER ROLE doug NOSUPERUSER;\nALTER ROLE\npostgres=# select rolname from pg_roles where rolsuper is true;\n rolname\n----------\n postgres\n(1 row)\nDefault Value:\nThe following predefined roles exist in PostgreSQL 14.x:\npg_read_all_data\nRead all data (tables, views, sequences), as if having SELECT rights on those objects, and USAGE rights on all schemas, even without having it explicitly. This role does not have the role attribute BYPASSRLS set. If RLS is being used, an administrator may wish to set BYPASSRLS on roles which this role is GRANTed to.\npg_write_all_data\nWrite all data (tables, views, sequences), as if having INSERT, UPDATE, and DELETE rights on those objects, and USAGE rights on all schemas, even without having it explicitly. This role does not have the role attribute BYPASSRLS set. If RLS is being used, an administrator may wish to set BYPASSRLS on roles which this role is GRANTed to.\npg_read_all_settings\nRead all configuration variables, even those normally visible only to superusers.\npg_read_all_stats\nRead all pg_stat_* views and use various statistics related extensions, even those normally visible only to superusers.\npg_stat_scan_tables\nExecute monitoring functions that may take ACCESS SHARE locks on tables, potentially for a long time.\npg_monitor\nRead/execute various monitoring views and functions. This role is a member of pg_read_all_settings, pg_read_all_stats and pg_stat_scan_tables.\npg_database_owner\nNone. Membership consists, implicitly, of the current database owner.\npg_signal_backend\nSignal another backend to cancel a query or terminate its session.\npg_read_server_files\nAllow reading files from any location the database can access on the server with COPY and other file-access functions.\npg_write_server_files\nAllow writing to files in any location the database can access on the server with COPY and other file-access functions.\npg_execute_server_program\nAllow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.\npg_checkpoint\nAllow executing the CHECKPOINT command.\npg_use_reserved_connections\nAllow use of connection slots reserved via reserved_connections.\npg_create_subscription\nAllow users with CREATE permission on the database to issue CREATE SUBSCRIPTION.\nAdministrators can grant access to these roles to users using the GRANT command.",
        "reference": "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-1,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|5.1,CSCv8|4.1,CSF|DE.AE-1,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,GDPR|32.1.b,GDPR|32.4,HIPAA|164.306(a)(1),ITSG-33|CM-1,ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|1M,NESA|M1.2.2,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|GS8b,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,NIAv2|VL7a,NIAv2|VL7b,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|7.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select rolname from pg_roles where rolsuper is true;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_36": {
        "description": "5.2 Ensure PostgreSQL is Bound to an IP Address",
        "info": "By default, listen_addresses is set to localhost which prevents any and all remote TCP connections to the PostgreSQL port.\nSome Docker images may set listen_addesses to *. * corresponds to all available IP interfaces; thus, the PostgreSQL server then accepts TCP connections on all the server's IPv6 and IPv4 interfaces. (The same is true for a setting of 0.0.0.0.)\nYou can make this configuration more restrictive by setting the listen_addresses configuration option to a specific list of IPv4 or IPv6 address so that the server only accepts TCP connections on those addresses.\nThis parameter can only be set at server start.\nRationale:\nLimiting the IP addresses that PostgreSQL listens on provides additional restrictions on where client applications/users can connect from.\nNOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.",
        "solution": "To have the PostgreSQL server only accept connections on a specific IP address, add an entry similar to this in the PostgreSQL configuration file postgresql.conf:\nlisten_addresses = ''\nTo listen on multiple addresses, a comma-separated list may be used:\nlisten_addresses = ','\nIn this case, clients can connect to the server using --host=, while connections on other server host addresses are not possible.",
        "reference": "800-171|3.13.1,800-171|3.13.2,800-53|PL-8,800-53|SA-8,800-53r5|PL-8,800-53r5|SA-8,CSCv8|16.10,CSF|ID.AM-3,CSF|PR.IP-2,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|1M,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2,QCSC-v1|4.2,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SHOW listen_addresses;",
        "sql_expect": "^(?!(\\*|0\\.0\\.0\\.0)$).*$"
    },
    "custom_item_37": {
        "description": "5.5 Ensure per-account connection limits are used",
        "info": "Limiting concurrent connections to a PostgreSQL server can be used to reduce the risk of Denial of Service (DoS) attacks.\n\nRationale:\n\nLimiting the number of concurrent sessions at the user level helps to reduce the risk of DoS attacks.",
        "solution": "Set a per-user connection limit by running:\n\nALTER USERCONNECTION LIMIT;\n\nDefault Value:\n\n-1",
        "reference": "800-53|AC-10,800-53r5|AC-10,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|AC-10,LEVEL|1A,NESA|T5.5.1,QCSC-v1|5.2.1,QCSC-v1|5.2.2",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SELECT rolname, rolconnlimit FROM pg_roles WHERE rolname NOT LIKE 'pg_%';",
        "sql_expect": ".+"
    },
    "custom_item_38": {
        "description": "ignore_system_indexes",
        "sql_request": "select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'ignore_system_indexes';",
        "sql_expect": "ignore_system_indexes"
    },
    "custom_item_39": {
        "description": "jit_debugging_support",
        "sql_request": "select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'jit_debugging_support';",
        "sql_expect": "jit_debugging_support"
    },
    "custom_item_40": {
        "description": "jit_profiling_support",
        "sql_request": "select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'jit_profiling_support';",
        "sql_expect": "jit_profiling_support"
    },
    "custom_item_41": {
        "description": "log_connections",
        "sql_request": "select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'log_connections';",
        "sql_expect": "log_connections"
    },
    "custom_item_42": {
        "description": "log_disconnections",
        "sql_request": "select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'log_disconnections';",
        "sql_expect": "log_disconnections"
    },
    "custom_item_43": {
        "description": "post_auth_delay",
        "sql_request": "select name, setting from pg_settings where context in ('backend', 'superuser-backend') and name = 'post_auth_delay';",
        "sql_expect": "post_auth_delay"
    },
    "custom_item_44": {
        "description": "6.3 Ensure 'Postmaster' Runtime Parameters are Configured",
        "info": "PostgreSQL runtime parameters that are executed by the postmaster process.\n\nRationale:\n\nThe postmaster process is the supervisory process that assigns a backend process to an incoming client connection. The postmaster manages key runtime parameters that are either shared by all backend connections or needed by the postmaster process itself to run.\n\nImpact:\n\nAll changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Once detected, the unauthorized/undesired change can be corrected by editing the altered configuration file and executing a server restart. In the case where the parameter has been specified on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.\nDetecting a change is possible by one of the following methods:\n\nQuery the view pg_settings and compare with previous query outputs for any changes\n\nReview the configuration files postgresql.conf and postgresql.auto.conf and compare with previously archived file copies for any changes\n\nExamine the process output and look for parameters that were used at server startup:\n\nps -few | grep -E -- '[p]ost.*-[D]'\n\nExamine the contents of $PGDATA/postmaster.opts",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select name, setting from pg_settings where context = 'postmaster' order by 1"
    },
    "custom_item_45": {
        "description": "6.4 Ensure 'SIGHUP' Runtime Parameters are Configured",
        "info": "PostgreSQL runtime parameters that are executed by the SIGHUP signal.\n\nRationale:\n\nIn order to define server behavior and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration files postgresql.conf and pg_hba.conf. Alternatively, those parameters found in postgresql.conf can also be changed using a server login session and executing the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.\n\nImpact:\n\nAll changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Restore all values in the PostgreSQL configuration files and invoke the server to reload the configuration files.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select name, setting from pg_settings where context = 'sighup' order by 1"
    },
    "custom_item_46": {
        "description": "6.5 Ensure 'Superuser' Runtime Parameters are Configured",
        "info": "PostgreSQL runtime parameters that can only be executed by the server's superuser, postgres.\n\nRationale:\n\nIn order to improve and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration file postgresql.conf. Alternatively, they can be changed in a PostgreSQL login session via the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.\n\nImpact:\n\nAll changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files. A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "The exploit is made in the configuration files. These changes are effected upon server restart. Once detected, the unauthorized/undesired change can be made by editing the altered configuration file and executing a server restart. In the case where the parameter has been set on the command-line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.\nDetecting a change is possible by one of the following methods:\n\nQuery the view pg_settings and compare with previous query outputs for any changes.\n\nReview the configuration files postgreql.conf and postgreql.auto.conf and compare with previously archived file copies for any changes\n\nExamine the process output and look for parameters that were used at server startup:\n\nps aux | grep -E -- '[p]ost.*-[D]'\n\nExamine the contents of $PGDATA/postmaster.opts",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select name, setting from pg_settings where context = 'superuser' order by 1"
    },
    "custom_item_47": {
        "description": "6.6 Ensure 'User' Runtime Parameters are Configured",
        "info": "These PostgreSQL runtime parameters are managed at the user account (ROLE) level.\n\nRationale:\n\nIn order to improve performance and optimize features, a ROLE has the privilege of setting numerous parameters in a transaction, session, or entity attribute. Any ROLE can alter any of these parameters.\n\nImpact:\n\nA denial of service is possible by the over-allocating of limited resources, such as RAM. Changing VACUUM parameters can force a server shutdown which is standard procedure preventing data corruption from transaction ID wraparound. Data can be corrupted by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Logging can be altered and obfuscated to inhibit root cause analysis.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "In the matter of a user session, the login sessions must be validated that it is not executing undesired parameter changes. In the matter of attributes that have been changed in entities, they must be manually reverted to their default value(s).",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select name, setting from pg_settings where context = 'user' order by 1"
    },
    "custom_item_48": {
        "description": "show ssl",
        "sql_request": "show ssl;",
        "sql_expect": "on"
    },
    "custom_item_49": {
        "description": "SELECT from system catalog view",
        "sql_request": "SELECT name, setting, source FROM pg_settings WHERE name = 'ssl';",
        "sql_expect": "ssl"
    },
    "custom_item_50": {
        "description": "6.11 Ensure the pgcrypto extension is installed and configured correctly",
        "info": "PostgreSQL must implement cryptographic mechanisms to prevent unauthorized disclosure or modification of organization-defined information at rest (to include, at a minimum, PII and classified information) on organization-defined information system components.\n\nRationale:\n\nPostgreSQL instances handling data that requires 'data at rest' protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to PostgreSQL or implemented via additional software or operating system/file system settings, as appropriate to the situation. Information at rest refers to the state of information when it is located on a secondary storage device (e.g. disk drive, tape drive) within an organizational information system.\n\nThe selection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e. full disk encryption) or encrypt specific data structures (e.g. files, records, or fields). Organizations may also optionally choose to implement both to implement layered security.\n\nThe decision of whether, and what, to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protection, as appropriate. If the confidentiality and integrity of application data are not protected, the data will be open to compromise and unauthorized modification.\n\nThe PostgreSQL pgcrypto extension provides cryptographic functions for PostgreSQL and is intended to address the confidentiality and integrity of user and system information at rest in non-mobile devices.\n\nImpact:\n\nWhen considering or undertaking any form of encryption, it is critical to understand the state of the encrypted data at all stages of the data lifecycle. The use of pgcrypto ensures that the data at rest in the tables (and therefore on disk) is encrypted, but for the data to be accessed by any users or applications, said users/applications will, by necessity, have access to the encrypt and decrypt keys and the data in question will be encrypted/decrypted in memory and then transferred to/from the user/application in that form.",
        "solution": "The pgcrypto extension is included with the PostgreSQL 'contrib' package. Although included, it needs to be created in the database.\nAs the database administrator, run the following:\n\npostgres=# CREATE EXTENSION pgcrypto;\nCREATE EXTENSION\n\nVerify pgcrypto is installed:\n\npostgres=# SELECT * FROM pg_available_extensions WHERE name='pgcrypto';\n   name   | default_version | installed_version |         comment\n----------+-----------------+-------------------+-------------------------\n pgcrypto | 1.3             | 1.3               | cryptographic functions\n(1 row)",
        "reference": "800-171|3.5.2,800-171|3.13.16,800-53|IA-5(1),800-53|SC-28,800-53|SC-28(1),800-53r5|IA-5(1),800-53r5|SC-28,800-53r5|SC-28(1),CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv7|14.8,CSCv8|3.11,CSF|PR.AC-1,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(d),HIPAA|164.312(e)(2)(ii),ITSG-33|IA-5(1),ITSG-33|SC-28,ITSG-33|SC-28a.,ITSG-33|SC-28(1),LEVEL|1M,NESA|T5.2.3,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1,TBA-FIISB|28.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SELECT * FROM pg_available_extensions where name='pgcrypto'",
        "sql_expect": "pgcrypto"
    },
    "custom_item_51": {
        "description": "6.9 Ensure the TLSv1.0 and TLSv1.1 Protocols are Disabled",
        "info": "Transport Layer Security (TLS), and its predecessor Secure Sockets Layer (SSL) are cryptographic protocols which can be used to encrypt data sent between client and server.\n\nRationale:\n\nThe TLSv1.0 protocol is vulnerable to the BEAST attack when used in CBC mode (October 2011). TLSv1.0 uses CBC modes for all of the block mode ciphers, which only leaves the RC4 streaming cipher which is also weak and therefore not recommended. Therefore, it is recommended that the TLSv1.0 protocol is disabled. The TLSv1.1 protocol does not support Authenticated Encryption with Associated Data (AEAD) which is designed to simultaneously provide confidentiality, integrity, and authenticity. All major up-to-date browsers support TLSv1.2, and most recent versions of Firefox and Chrome support the newer TLSv1.3 protocol, since 2017.\n\nIETF deprecated TLSv1.0 and TLSv1.1 in March 2021 (see RFC 8996).",
        "solution": "Adjust the ssl_min_protocol_version to at least TLSv1.2:\n\nALTER SYSTEM SET ssl_min_protocol_version = 'TLSv1.2';\n\nor (preferred):\n\nALTER SYSTEM SET ssl_min_protocol_version = 'TLSv1.3';\n\nIn either case, make the change active:\n\nSELECT pg_reload_conf();\nSHOW ssl_min_protocol_version;",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1A,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SHOW ssl_min_protocol_version;",
        "sql_expect": "TLSv1\\.(2|3)"
    },
    "custom_item_52": {
        "description": "7.1 Ensure a replication-only user is created and used for streaming replication",
        "info": "Create a new user specifically for use by streaming replication instead of using the superuser account.\nRationale:\nAs it is not necessary to be a superuser to initiate a replication connection, it is proper to create an account specifically for replication. This allows further 'locking down' the uses of the superuser account and follows the general principle of using the least privileges necessary.\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "It will be necessary to create a new role for replication purposes:\npostgres=# create user replication_user REPLICATION encrypted password 'XXX';\nCREATE ROLE\npostgres=# select rolname from pg_roles where rolreplication is true;\n     rolname\n------------------\n postgres\n replication_user\n(2 rows)\nWhen using pg_basebackup (or other replication tools) on your standby server, you would use the replication_user (and its password).\nEnsure you allow the new user via your pg_hba.conf file:\n# note that 'replication' in the 2nd column is required and is a special\n# keyword, not a real database\nhostssl replication     replication_user    0.0.0.0/0         scram-sha-256",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select rolname from pg_roles where rolreplication is true;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_53": {
        "description": "7.2 Ensure logging of replication commands is configured",
        "info": "Enabling the log_replication_commands setting causes each attempted replication from the server to be logged.\nRationale:\nA successful replication connection allows for a complete copy of the data stored within the data cluster to be offloaded to another, potentially insecure, host. As such, it is advisable to log all replication commands that are executed in your database cluster to ensure the data is not off-loaded to an unexpected/undesired location.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "To enable the logging of replication commands, execute the following:\npostgres=# ALTER SYSTEM SET log_replication_commands = 'on';\nALTER SYSTEM\npostgres=# SELECT pg_reload_conf();\n pg_reload_conf\n----------------\n t\n(1 row)\npostgres=# show log_replication_commands ;\n log_replication_commands\n--------------------------\n on\n(1 row)",
        "reference": "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|1M,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "show log_replication_commands",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_54": {
        "description": "Archive Check",
        "sql_request": "SELECT name, setting FROM pg_settings WHERE name in ('archive_mode','archive_command','archive_library') AND setting IS NOT NULL AND setting <> 'off' AND setting <> '(disabled)' AND setting <> '';",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_55": {
        "description": "Change Check",
        "sql_request": "SELECT * FROM pg_stat_archiver;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_56": {
        "description": "7.5 Ensure streaming replication parameters are configured correctly",
        "info": "Streaming replication from a PRIMARY host transmits DDL, DML, passwords, and other potentially sensitive activities and data. These connections should be protected with Secure Sockets Layer (SSL).\nRationale:\nUnencrypted transmissions could reveal sensitive information to unauthorized parties. Unauthenticated connections could enable man-in-the-middle attacks.\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Review prior sections in this benchmark regarding TLS certificates, replication user, and WAL archiving.\nConfirm the file $PGDATA/standby.signal is present on the STANDBY host and $PGDATA/postgresql.auto.conf contains lines similar to the following:\nprimary_conninfo = 'user=replication_user password=mypassword host=mySrcHost port=5432 sslmode=require sslcompression=1'",
        "reference": "800-171|3.1.13,800-171|3.5.2,800-171|3.13.8,800-53|AC-17(2),800-53|IA-5,800-53|IA-5(1),800-53|SC-8,800-53|SC-8(1),800-53r5|AC-17(2),800-53r5|IA-5,800-53r5|IA-5(1),800-53r5|SC-8,800-53r5|SC-8(1),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.1(c),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv7|14.4,CSCv8|3.10,CSF|PR.AC-1,CSF|PR.AC-3,CSF|PR.DS-2,CSF|PR.DS-5,CSF|PR.PT-4,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ISO/IEC-27001|A.6.2.2,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|AC-17(2),ITSG-33|IA-5,ITSG-33|IA-5(1),ITSG-33|SC-8,ITSG-33|SC-8a.,ITSG-33|SC-8(1),LEVEL|1M,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T5.2.3,NESA|T5.4.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|AM37,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS5d,NIAv2|NS6b,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|2.1,SWIFT-CSCv1|2.6,SWIFT-CSCv1|4.1,TBA-FIISB|29.1",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select rolname from pg_roles where rolreplication is true;",
        "sql_expect": "^Manual Review Required$"
    },
    "custom_item_57": {
        "description": "8.1 Ensure PostgreSQL subdirectory locations are outside the data cluster",
        "info": "The PostgreSQL cluster is organized to carry out specific tasks in subdirectories. For the purposes of performance, reliability, and security some of these subdirectories should be relocated outside the data cluster.\n\nRationale:\n\nSome subdirectories contain information, such as logs, which can be of value to others such as developers. Other subdirectories can gain a performance benefit when placed on fast storage devices. Other subdirectories contain temporary files created and used during processing. Finally, relocating a subdirectory to a separate and distinct partition mitigates denial of service and involuntary server shutdown when excessive writes fill the data cluster's partition, e.g. pg_wal, pg_log, and temp_tablespaces.\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Perform the following steps to remediate the subdirectory locations and permissions:\n\nDetermine appropriate data, log, and tablespace directories and locations based on your organization's security policies. If necessary, relocate all listed directories outside the data cluster.\n\nIf not relocating temp_tablespaces, the temp_file_limit parameter must be changed from its default value.\n\nEnsure file permissions are restricted as much as possible, i.e. only superuser read access.\n\nWhen directories are relocated to other partitions, ensure that they are of sufficient size to mitigate against excessive space utilization.\n\nLastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.\n\nTo relocate temp_tablespaces to an existing mount point outside the data cluster is accomplished by:\n\npostgres=# CREATE TABLESPACE temp_tablespc LOCATION '/path/to/existing/desired/mount/point';\npostgres=# ALTER SYSTEM SET temp_tablespaces = 'temp_tablespc';\npostgres=# SELECT pg_reload_conf();\n\nDefault Value:\n\nThe default for data_directory is ConfigDir and the default for log_directory is log (based on absolute path of data_directory). The defaults for tablespace settings are null, or not set, upon cluster creation.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "select name, setting from pg_settings where (name ~ '_directory$' or name ~ '_tablespace')"
    },
    "custom_item_58": {
        "description": "8.3 Ensure miscellaneous configuration settings are correct",
        "info": "This recommendation covers non-regular, special files, and dynamic libraries.\n\nPostgreSQL permits local logins via the UNIX DOMAIN SOCKET and, for the most part, anyone with a legitimate Unix login account can make the attempt. Limiting PostgreSQL login attempts can be made by relocating the UNIX DOMAIN SOCKET to a subdirectory with restricted permissions.\n\nThe creation and implementation of user-defined dynamic libraries is an extraordinary powerful capability. In the hands of an experienced DBA/programmer, it can significantly enhance the power and flexibility of the RDBMS; but new and unexpected behavior can also be assigned to the RDBMS, resulting in a very dangerous environment in what should otherwise be trusted.\n\nRationale:\n\nNOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.",
        "solution": "Follow these steps to remediate the configuration:\n\nDetermine permissions based on your organization's security policies.\n\nRelocate all files and ensure their permissions are restricted as much as possible, i.e. only superuser read access.\n\nEnsure all directories where these files are located have restricted permissions such that the superuser can read but not write.\n\nLastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.\n\nDefault Value:\n\nThe dynamic_library_path default is $libdir and unix_socket_directories default is /var/run/postgresql, /tmp. The default for external_pid_file and all library parameters are initially null, or not set, upon cluster creation.",
        "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|18.11,CSCv8|16.7,CSF|PR.IP-1,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
        "see_also": "https://workbench.cisecurity.org/benchmarks/17003",
        "sql_request": "SELECT name, setting FROM pg_settings WHERE name IN ('external_pid_file' ,'unix_socket_directories' ,'shared_preload_libraries' ,'dynamic_library_path' ,'local_preload_libraries' ,'session_preload_libraries' )"
    }
}